[{"title":"Github Tutorial","url":"/2023/12/02/Github-Tutorial/","content":"BasicClone a repogit clone &#123;url.git&#125;\n\nAdd some filesgit add &#123;filename&#125;\n\nGet commit historygit log\n\nCommitgit commit -m &quot;text&quot;\n\nPullgit pull\n\nPushgit push &#123;branch-name&#125;\n\nBranchGet now branch and all branch listgit branch\n\nCreate branchgit branch &#123;branch-name&#125;\n\nBranch Naming Examplegit branch feat/&#123;id&#125;-xxx   # add new featuregit branch fix/&#123;id&#125;-xxx    # fix some bugsgit branch refactor/&#123;id&#125;-xxx # Refactor the codegit branch docs/&#123;id&#125;-xxx   # Update Filesgit branch style/&#123;id&#125;-xxx  # Coding style, formattergit branch chore/&#123;id&#125;-xxx  # Change working process, tools ...etc\n\nSwitch branchgit switch &#123;branch-name&#125;git switch -c &#123;branch-name&#125; # if branch not exist, auto create\n\nMerge branchgit switch &#123;Target-branch-name&#125;git merge &#123;branch-name&#125;git push origin &#123;Target-branch-name&#125;\n\ncheckoutcheck commit and filesgit checkout &#123;commit-id&#125;git checkout &#123;commit-id&#125; -- &#123;file-path&#125;git checkout main\n\nWith DockerLogin ghcr.io with docker on terminal\nGet a “personal access token (classic)” from Developer Page\n\nlogin by terminal\n\n\nexport CR_PAT=ghp_xxxxxecho $CR_PAT | docker login ghcr.io -u &#123;Github ID&#125; --password-stdin\n","categories":["GitHub"]},{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用 Docker 時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -e port1=5001 -e port2=5002 \\        -p 5001:443 -p 5002:5002 au2a/hakka-website\n\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址port1為外部的網頁 portport2為外部的解碼用 port\n-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\n\nwhisper 解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每 90 天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n\n安裝 cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n\n如果要獨立裝 driver，就把 driver 取消\ndriversudo apt-get install nvidia-driver-470\n\nHuggingface 金鑰申請請到huggingface 官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n\n登入 hugging face將訓練完成的模型上傳到存放在 huggingface，可以減少本地端空間占用。Token請自行去 huggingface 申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n\n載入 Openai 建立好的模型使用 openai 提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n\n語料轉換取樣率音檔取樣率轉換成 16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\n\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\n\ncompute_metrics計算 CER(或 WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\n\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\n\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\n\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n\n開始訓練trainer.train()\n\n從本地上傳模型到 HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,    &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n\n從 HuggingFace 下載模型你需要更改要下載 model 的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning Script by FSR2023","url":"/2023/08/28/Openai-Whisper-Fine-Tuning-Script-by-FSR2023/","content":"連結Github\n重點專案結構whisper-hakka ┗┳━ custom_data  ┃   ┗━ data_prep.py 資料檢查、產生binary檔案  ┣━ data-char 放字單位的文本  ┃   ┣━ dev  ┃   ┃   ┣━ audio_paths symbolic link to wav.scp  ┃   ┃   ┣━ spk2utt 語者ID與其語料ID  ┃   ┃   ┣━ text    語料ID與語料文本  ┃   ┃   ┣━ utt2spk 語料ID與其語者ID  ┃   ┃   ┗━ wav.scp 語料ID與語料路徑  ┃   ┣━ test  ┃   ┃   ┗━ 同(dev)  ┃   ┗━ train  ┃       ┗━ 同(dev)  ┣━ data-pinyin 放詞單位的文本  ┃   ┗━ 同(data-char)  ┣━ evaluate  ┃   ┗━ evaluate_on_custom_dataset.py 驗證腳本  ┣━ train  ┃   ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本  ┃   ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本  ┣━ requirements.txt library套件  ┗━ run.sh 所有會執行的指令\n\n安裝虛擬環境建議用虛擬環境 virtual environment 建置 python 環境，可以避免原始套件衝突。\n# 建立虛擬環境# python3 -m venv name-of-venvpython3 -m venv env# 啟動虛擬環境source env/bin/activate\n\n當成功使用虛擬環境時，命令列左側會顯示在虛擬環境中。\n# beforeuser@SERVER:/path-to-project$# after(env) user@SERVER:/path-to-project$\n\n安裝 Python 套件python3 -m pip install --upgrade pippip install -r requirements.txt\n\n資料準備接著進行資料準備，所有集合都放在data-char底下，一個資料夾為一個集合。需準備的資料有：text\nID_1 text-in-ID_1ID_2 text-in-ID_2ID_3 text-in-ID_3\n\nwav.scp\nID_1 path-to-ID_1ID_2 path-to-ID_2ID_3 path-to-ID_3\n\n建議data-char放中文字的 text(字為單位)，data-pinyin放英文字的 text(詞為單位)。\n接下來可以使用run.sh內的指令進行驗證，執行後會在output_data_dir的地方放生成後的 binary 檔案。\npython3 custom_data/data_prep.py \\--source_data_dir path-to-your-location \\--output_data_dir path-to-your-data-locationEx:python3 custom_data/data_prep.py \\--source_data_dir data-pinyin/train \\--output_data_dir output_data-pinyin/train\n\n如果輸出Data preparation done代表沒問題，可以進行下一步。\n開始訓練資料準備完成後，即可進行訓練，可以執行以下指令(以字元為例)nproc_per_node為 GPU 數量\ntorchrun --nproc_per_node=1 train/fine-tune_on_custom_dataset.py \\--model_name openai/whisper-base \\  # 基礎模型--language zh \\ # 調適的語言--sampling_rate 16000 \\    # 取樣率--num_proc 4 \\             # 同時只用多少CPU核心執行取樣轉換，越快越好--train_strategy epoch \\   # 訓練週期單位(epoch/steps)--learning_rate 6.25e-6 \\  # 學習率--warmup 1000 \\--train_batchsize 12 \\  # 訓練batch--eval_batchsize 6 \\    # 驗證batch--num_epochs 20 \\       # 訓練週期數--resume_from_ckpt None \\--output_dir op_dir_epoch-char \\           # 輸出路徑資料夾名，記得修改，不然容易忘記--train_datasets output_data-char/train  \\ # 訓練集路徑--eval_datasets output_data-char/dev       # 驗證集路徑\n\n完成訓練後，可以透過終端上每個checkpoint的 WER 去評估哪個模型比較好。\n訓練好的模型資料結構(僅說明重點)以預設名op_dir_epoch-char舉例\nwhisper-hakka ┗━━ op_dir_epoch-char      ┣━ checkpoint-(num)      ┃   ┣━ config.json 參數檔      ┃   ┗━ pytorch_model.bin 模型      ┣━ 每個checkpoint資料夾內的檔案      ┗━ README.md 訓練狀態\n\n測試選擇好最好的 checkpoint 後，就可以進行測試看看該模型效果如何，通常 checkpoint 前 3 名都有機會有好的結果，不一定會是 checkpoint 最好的為最好模型。\npython3 evaluate/evaluate_on_custom_dataset.py \\--is_public_repo False \\--ckpt_dir &quot;op_dir_epoch-char/checkpoint&quot; \\  # checkpoint路徑--temp_ckpt_folder &quot;temp-char&quot; \\         # 暫存位置--language zh \\                          # 語言--eval_datasets output_data-char/test \\  # 測試集路徑--device 0 \\--batch_size 8 \\                   # 測試batch--output_dir predictions_dir-char  # 測試後輸出檔案\n\n測試後即可跟去輸出的 WER(詞錯誤率)與 CER(字錯誤率)去選擇最好的模型。\n輸出模型此腳本並無提供模型輸出的指令，可以使用以下我寫的程式碼：\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;path-to-checkpoint&#x27;whisper_checkpoint_path = &#x27;model-name.pt&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\n此方法生成的模型可以使用在 python 的 whisper 套件。\n","categories":["HakkaASR"]},{"title":"Docker Tutorial","url":"/2024/05/02/Docker-Tutorial/","content":"ContainerContainer statusdocker psdocker ps -q # Only get running Container ID\n\nRun containerdocker run --name=&#123;NAME&#125; \\  # Container name            -d \\            # Running in the background            -e &#123;PARAM-NAME&#125;=&#123;PARAM-VALUE&#125; \\    # Parameters            -v &#123;OUTSIDE-PATH&#125;:&#123;INSIDE-PATH&#125; \\  # Volume PATH            -p &#123;OUTSIDE-PORT&#125;:&#123;INSIDE-PORT&#125; \\  # Port forwarding            &#123;REPOSITORY/IMAGE-Name&#125;\n\nStart containerdocker start &#123;CONTAINER-ID/NAMES&#125;\n\nStop containerdocker stop &#123;CONTAINER-ID/NAMES&#125;\n\nControl containerdocker exec -it &#123;CONTAINER-ID/NAMES&#125; bash\n\nRemove containerdocker rm &#123;CONTAINER-ID/NAMES&#125;\n\nContainer logsdocker logs &#123;CONTAINER-ID/NAMES&#125;\n\nimagesImages listdocker image ls\n\nRemove imagedocker image rm &#123;REPOSITORY&#125;\n\nBuild imagedocker build -t &#123;IMAGE-Name&#125; &#123;PATH&#125;\n\nPush imagedocker push &#123;IMAGE-Name&#125;\n\nWith GithubLogin ghcr.io with docker on terminal\nGet a “personal access token (classic)” from Developer Page\n\nlogin by terminal\n\n\nexport CR_PAT=ghp_xxxxxecho $CR_PAT | docker login ghcr.io -u &#123;Github ID&#125; --password-stdin\n","categories":["Docker"]},{"title":"APCS-2022-01","url":"/2025/09/14/APCS/APCS-2022-01/","content":"1. 程式交易解題步驟\n讀取輸入資料: 讀取股票天數 n、價差 D，以及 n 天的每日價格。\n初始化交易狀態:\n設定總利潤 ans 為 0。\n根據規則 1，在時間點 1 (索引 0) 買進，設定目前持有股票的成本 x 為 a[0]。\n設定一個變數 y 來記錄上一次的賣出價格。\n我們將使用一個特殊值（例如 -1）來表示 x，代表當下未持有股票。\n\n\n模擬交易過程: 使用 for 迴圈從第二天 (索引 1) 開始遍歷到第 n 天。\n判斷當前狀態 (持有&#x2F;未持有): 在迴圈中，檢查 x 是否為 -1。\n若持有股票 (x != -1): 檢查是否滿足賣出條件 (規則 2)。如果 a[i] &gt;= x + D，則賣出：\n將利潤 a[i] - x 加入 ans。\n更新狀態為未持有 (設定 x = -1)。\n記錄本次賣出價格 y = a[i]。\n\n\n若未持有股票 (x == -1): 檢查是否滿足買進條件 (規則 3)。如果 a[i] &lt;= y - D，則買進：\n更新狀態為持有，並記錄買進成本 x = a[i]。\n\n\n\n\n輸出總利潤: 迴圈結束後，ans 即為總利潤，將其輸出。\n\n分段步驟程式碼讀取輸入資料int n, D;cin&gt;&gt;n&gt;&gt;D;vector&lt;int&gt; a(n,0);for(int i=0;i&lt;n;i++)&#123;    cin&gt;&gt;a[i];&#125;\n\n這段程式碼讀取 n 和 D，並使用一個 vector 容器 a 來儲存 n 天的股票價格。\n初始化交易狀態int ans=0,x=a[0],y=0;\n\n\nans：初始化總利潤為 0。\nx：代表目前持有股票的買進價格。根據規則 1，我們在第一天就買進，所以 x 初始為 a[0]。在後續邏輯中，x 若被設為 -1 則代表「未持有」股票。\ny：代表上一次的賣出價格，用於判斷下一次的買進時機。\n\n模擬交易過程for(int i=1;i&lt;n;i++)&#123;    if(x!=-1)&#123;        if(a[i]&gt;=x+D)&#123;            ans += a[i] - x;            x = -1;            y = a[i];        &#125;    &#125;    else&#123;        if(a[i]&lt;=y-D)&#123;            x = a[i];        &#125;    &#125;&#125;\n\n這段程式碼是核心的模擬邏輯，從第二天 (索引 i=1) 開始：\n\nif(x != -1)：檢查是否持有股票。\nif(a[i] &gt;= x + D)：(規則 2) 檢查當前價格是否達到賣出門檻。若是，則計算利潤、將狀態改為未持有 (x = -1)、並記錄賣出價格 y。\n\n\nelse：若未持有股票 (x == -1)。\nif(a[i] &lt;= y - D)：(規則 3) 檢查當前價格是否達到買進門檻。若是，則買進股票，將 x 設為當前的買進價格 a[i]。\n\n\n\n輸出總利潤cout&lt;&lt;ans&lt;&lt;endl;\n\n這段程式碼輸出在整個過程中累計的總利潤 ans。\n完整程式碼#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n, D;    cin&gt;&gt;n&gt;&gt;D;    vector&lt;int&gt; a(n,0);    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    int ans=0,x=a[0],y=0;    for(int i=1;i&lt;n;i++)&#123;        if(x!=-1)&#123;            if(a[i]&gt;=x+D)&#123;                ans += a[i] - x;                x = -1;                y = a[i];            &#125;        &#125;        else&#123;            if(a[i]&lt;=y-D)&#123;                x = a[i];            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;\n\n2. 贏家預測解題步驟\n讀取輸入: 讀取人數 n 和淘汰敗場數 m。\n儲存初始能力: 分別讀取 n 個人的戰力 $S$ 和應變力 $T$，存入兩個 vector&lt;int&gt; S 和 T。\n初始化比賽序列:\n建立一個 vector&lt;vector&lt;int&gt;&gt; info 來儲存當前所有參賽者的資訊。\ninfo 中的每個元素 info[i] 都是一個 vector&lt;int&gt;，包含 4 個值：[戰力, 應變力, 編號, 目前敗場數]。\n依照輸入的「初始排列順序」，讀取每個編號 idx，然後從 S 和 T 陣列中 (使用 idx-1 索引) 查找對應的戰力和應變力，連同編號 idx 和初始敗場 0，一起存入 info 向量。\n\n\n模擬比賽 (主迴圈):\n使用一個 while(info.size() != 1) 迴圈，表示只要參賽人數大於 1，比賽就繼續進行。\n\n\n執行一輪比賽 (Round):\n在 while 迴圈內部，建立兩個新的暫存 vector：win (勝利組) 和 lose (失敗組)。\n使用 for 迴圈遍歷 info 向量，兩兩一組 (i, i+1) 進行配對競賽。\n勝負判斷: 取出 $a, b, c, d$ 四個值。注意：計算 $a \\times b$ 和 $c \\times d$ 時必須使用 long long int 以避免溢位。\n更新數值: 根據 $a \\times b \\ge c \\times d$ 的結果，按照題目規則計算勝者和敗者的新戰力與新應變力。\n分組: 將更新後的勝者資訊 (敗場數不變) push_back 到 win 向量；將更新後的敗者資訊 (敗場數 +1) push_back 到 lose 向量。\n\n\n處理奇數人數:\n在 for 迴圈結束後，檢查 info.size() 是否為奇數。\n如果是奇數，表示最後一個人 (info[info.size()-1]) 烙單，將他不經修改地 push_back 到 win 向量，直接晉級。\n\n\n重組下一輪名單:\n將 info 向量更新為 win 向量 (即 info = win;)。\n接著遍歷 lose 向量。\n對於 lose 中的每一個人，檢查其敗場數 (lose[i][3])。如果不等於 m (即未達淘汰標準)，則將他 push_back 到 info 向量的尾端。\n\n\n輸出贏家:\n當 while 迴圈結束時，info 向量中只會剩下一個元素 (即最終贏家)。\n輸出這位贏家的編號 info[0][2]。\n\n\n\n分段步驟程式碼讀取 N, M 與 S, T 陣列int n,m,idx;cin &gt;&gt;n&gt;&gt;m;vector&lt;int&gt; S(n), T(n);vector&lt;vector&lt;int&gt;&gt; info(n,vector&lt;int&gt;(4,0));for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; S[i];&#125;for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; T[i];&#125;\n\n這段程式碼讀取 n、m，並初始化 S、T 陣列來儲存所有人的初始戰力與應變力。同時初始化 info 向量準備存放參賽者資訊。\n初始化比賽序列 infofor(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; idx;    info[i][0]=S[idx-1]; // 根據編號 (idx-1) 填入 S    info[i][1]=T[idx-1]; // 根據編號 (idx-1) 填入 T    info[i][2]=idx;      // 填入原始編號    // info[i][3] (敗場數) 已被初始化為 0&#125;\n\n這段程式碼讀取初始的排列順序，並依照順序將每個人的 S, T, 編號, 初始敗場(0) 填入 info 向量中。\n模擬比賽主迴圈while(info.size()!=1)&#123;    vector&lt;vector&lt;int&gt;&gt; win,lose;    // (內部迴圈 - 兩兩配對)    // ...    // (處理奇數人數)    // ...    // (重組名單)    // ...&#125;\n\n這是比賽的主迴圈，只要參賽人數不為 1，就繼續進行新的一輪。每輪開始時，都會建立新的 win 和 lose 暫存向量。\n兩兩配對競賽與更新for(int i=0;i+1&lt;info.size();i+=2)&#123;    // 使用 long long 避免 ab 和 cd 相乘溢位    long long int a=info[i][0],b=info[i][1],c=info[i+1][0],d=info[i+1][1];    if(a*b&gt;=c*d)&#123;        // info[i] 獲勝        win.push_back (&#123;a+c*d/(2*b),b+c*d/(2*a),info[i][2],info[i][3]&#125;);        // info[i+1] 戰敗        lose.push_back(&#123;c+c/2,d+d/2,info[i+1][2],info[i+1][3]+1&#125;);    &#125;else&#123;        // info[i+1] 獲勝        win.push_back (&#123;c+a*b/(2*d),d+a*b/(2*c),info[i+1][2],info[i+1][3]&#125;);        // info[i] 戰敗        lose.push_back(&#123;a+a/2,b+b/2,info[i][2],info[i][3]+1&#125;);    &#125;&#125;\n\n這段程式碼遍歷當前的 info 列表，兩兩一組 (i, i+1) 進行比賽。根據 $a \\times b$ 和 $c \\times d$ 的比較結果，計算並更新雙方的數值，勝者放入 win，敗者敗場+1 後放入 lose。\n處理烙單與重組名單if(info.size()%2==1)&#123;    // 奇數人數，最後一人 (info[info.size()-1]) 直接晉級    win.push_back(info[info.size()-1]);&#125;info = win; // 勝利組成為新名單的前半部for(int i=0;i&lt;lose.size();i++)&#123;    if(lose[i][3]!=m)&#123;        // 敗場未達 m 的人，接在勝利組後面        info.push_back(lose[i]);    &#125;&#125;\n\n這段程式碼首先檢查是否有烙單的人，有則直接加入 win。然後，將 info 更新為 win（勝利組），接著遍歷 lose 列表，將未被淘汰 (敗場 != m) 的人加回 info 的尾端，形成下一輪的比賽名單。\n輸出最終贏家cout&lt;&lt;info[0][2];\n\n當 while 迴圈結束時，info 向量中只會剩下一個元素，即 info[0]。我們輸出其編號 info[0][2]。\n完整程式碼#include&lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int n,m,idx;    cin &gt;&gt;n&gt;&gt;m;    vector&lt;int&gt; S(n), T(n);    vector&lt;vector&lt;int&gt;&gt; info(n,vector&lt;int&gt;(4,0));    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; S[i];    &#125;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; T[i];    &#125;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; idx;        info[i][0]=S[idx-1];        info[i][1]=T[idx-1];        info[i][2]=idx;    &#125;    while(info.size()!=1)&#123;        vector&lt;vector&lt;int&gt;&gt; win,lose;        for(int i=0;i+1&lt;info.size();i+=2)&#123;            long long int a=info[i][0],b=info[i][1],c=info[i+1][0],d=info[i+1][1];            if(a*b&gt;=c*d)&#123;                win.push_back (&#123;a+c*d/(2*b),b+c*d/(2*a),info[i][2],info[i][3]&#125;);                lose.push_back(&#123;c+c/2,d+d/2,info[i+1][2],info[i+1][3]+1&#125;);            &#125;else&#123;                win.push_back (&#123;c+a*b/(2*d),d+a*b/(2*c),info[i+1][2],info[i+1][3]&#125;);                lose.push_back(&#123;a+a/2,b+b/2,info[i][2],info[i][3]+1&#125;);            &#125;        &#125;        if(info.size()%2==1)&#123;            win.push_back(info[info.size()-1]);        &#125;        info = win;        for(int i=0;i&lt;lose.size();i++)&#123;            if(lose[i][3]!=m)&#123;                info.push_back(lose[i]);            &#125;        &#125;    &#125;    cout&lt;&lt;info[0][2];&#125;\n","categories":["APCS"]},{"title":"APCS-2021-11","url":"/2025/10/26/APCS/APCS-2021-11/","content":"1. 修補圍籬解題步驟\n讀取圍籬數量和高度：讀取圍籬的總數量 n，接著使用迴圈讀取 n 個圍籬各自的高度，並存入一個 vector（或陣列）fence 中。\n初始化成本變數：宣告一個整數變數 ans 並將其初始化為 0，用來累計修補圍籬所需的總成本。\n遍歷圍籬並判斷：使用 for 迴圈從頭到尾檢查每一個圍籬（索引 i 從 0 到 n-1）。\n檢查是否損壞：在迴圈中，判斷 fence[i] 是否等於 0。如果等於 0，表示這個位置的圍籬斷了，需要修補。\n處理邊界與中間情況：\n左邊界：如果 i == 0（第一個圍籬），則成本增加其右側鄰居 fence[1] 的高度。\n右邊界：如果 i == n-1（最後一個圍籬），則成本增加其左側鄰居 fence[n-2] 的高度。\n中間：如果不是邊界，則比較其左側 fence[i-1] 和右側 fence[i+1] 的高度，取較小的那個高度加入總成本 ans。\n\n\n輸出最終成本：迴圈結束後，ans 中儲存的就是修補所有斷掉圍籬的總成本，將其輸出。\n\n分段步驟程式碼讀取圍籬數量和高度#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int n; //圍籬數量    cin &gt;&gt; n;    vector&lt;int&gt; fence(n); //圍籬高度    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; fence[i];    &#125;\n\n這段程式碼首先引入必要的函式庫，然後讀取圍籬數量 n，並宣告一個大小為 n 的 vector 叫 fence。接著，它使用一個 for 迴圈來讀取 n 次，將每個圍籬的高度存入 vector 中。\n初始化成本並遍歷計算int ans=0;for(int i=0;i&lt;n;i++)&#123;    if(fence[i]==0)&#123; // 判斷圍籬是否為 0 (斷掉)        if(i == 0)&#123; // 情況 1: 斷在最左邊            ans += fence[1];        &#125;        else if(i == n-1)&#123; // 情況 2: 斷在最右邊            ans += fence[n-2];        &#125;        else&#123; // 情況 3: 斷在中間            // ans += 判斷式?成立程式碼:否定程式碼            // 使用三元運算子取左右兩邊較小的高度            ans += fence[i-1] &gt; fence[i+1] ? fence[i+1] : fence[i-1];        &#125;    &#125;&#125;\n\n這段程式碼是解題的核心。\n\n初始化 ans = 0 來計算總成本。\nfor(int i=0; i&lt;n; i++)：遍歷所有圍籬。\nif(fence[i]==0)：檢查當前圍籬是否斷掉。\n接著的三個 if-else if-else 區塊分別處理了題目中提到的三種情況：斷在最左邊、斷在最右邊、以及斷在中間。\n對於中間情況，ans += fence[i-1] &gt; fence[i+1] ? fence[i+1] : fence[i-1]; 是一個三元運算子，它等同於 ans += min(fence[i-1], fence[i+1])，即取左右兩側較小的值加入成本。\n\n輸出最終成本    cout &lt;&lt; ans;&#125;\n\n在所有計算完成後，這行程式碼會印出累計的總成本 ans，並結束 main 函式。\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int n; //圍籬數量    cin &gt;&gt; n;    vector&lt;int&gt; fence(n); //圍籬高度    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; fence[i];    &#125;    int ans=0;    for(int i=0;i&lt;n;i++)&#123;        if(fence[i]==0)&#123;            if(i == 0)&#123;                ans += fence[1];            &#125;            else if(i == n-1)&#123;                ans += fence[n-2];            &#125;            else&#123;                // ans += 判斷式?成立程式碼:否定程式碼                ans += fence[i-1] &gt; fence[i+1] ? fence[i+1] : fence[i-1];            &#125;        &#125;    &#125;    cout &lt;&lt; ans;&#125;\n\n2. 動線安排解題步驟\n讀取輸入與初始化: 讀取展場大小 $m, n$ 和操作次數 $h$。宣告一個 $m \\times n$ 的二維陣列 arr 來模擬展場狀態。我們使用 -1 代表木樁，0 代表空地，正數代表該格被線經過的次數。同時初始化最大面積 mx 為 0。\n定義輔助函數:\nnowArea(): 遍歷整個 arr 陣列，計算值不為 0 (即有木樁或有線) 的格子總數，並返回該總數作為當前面積。\nhaveStake(r, c, dir): 檢查從 $(r, c)$ 往 dir (0&#x3D;右, 1&#x3D;左, 2&#x3D;上, 3&#x3D;下) 方向搜尋，路徑上是否會遇到木樁 (-1)。\nadd(r, c, dir): 從 $(r, c)$ 往 dir 方向，將路徑上所有格子的計數值 ++，直到遇到木樁 (-1) 或碰到邊界為止。\nrmv(r, c, dir): 從 $(r, c)$ 往 dir 方向，將路徑上所有格子的計數值 --，直到遇到木樁 (-1)、空地 (0) 或碰到邊界為止。\n\n\n模擬 $h$ 次操作: 使用 for 迴圈執行 $h$ 次操作。在每次迴圈中：\n讀取操作位置 $(r, c)$ 和操作類型 $t$。\n若 $t &#x3D;&#x3D; 0$ (加入木樁):\n首先檢查 arr[r][c] 是否大於 0 (即有線經過)。如果是，表示需要先拆除舊線。透過 haveStake 檢查四個方向，若有木樁，則呼叫 rmv 移除該方向的連線。\n將 arr[r][c] 設為 -1，表示放置木樁。\n透過 haveStake 檢查四個方向，若有木樁，則呼叫 add 建立該方向的新連線。\n\n\n若 $t &#x3D;&#x3D; 1$ (移除木樁):\n將 arr[r][c] 設為 0，表示移除木樁。\n透過 haveStake 檢查四個方向，若有木樁，則呼叫 rmv 移除該方向的連線。\n\n\n\n\n更新最大面積: 在每次操作（加入或移除）完成後，呼叫 nowArea() 計算當前面積，並使用 mx = max(mx, nowArea()) 來更新過程中的最大面積。\n輸出結果: $h$ 次操作全部完成後，輸出 mx (過程最大面積) 和最後一次呼叫 nowArea() (最終面積) 的結果。\n\n分段步驟程式碼讀取輸入與全域變數#include&lt;iostream&gt;using namespace std;int m, n, h, r, c, t, arr[100][100] = &#123;&#125;, mx = 0;\n\n這段程式碼包含必要的標頭檔，並宣告所有需要的全域變數，包括 $m, n, h$，當前操作的 $r, c, t$，以及 $100 \\times 100$ 的展場陣列 arr 和最大面積 mx。\n移除連線 (rmv)void rmv(int r,int c,int dir)&#123;    if(dir == 0)&#123; // 向右        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1||arr[r][i]==0) return;            if(arr[r][i]&gt;0) arr[r][i]--;        &#125;    &#125;    else if(dir == 1)&#123; // 向左        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1||arr[r][i]==0) return;            if(arr[r][i]&gt;0) arr[r][i]--;        &#125;    &#125;    else if(dir == 2)&#123; // 向上        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1||arr[i][c]==0) return;            if(arr[i][c]&gt;0) arr[i][c]--;        &#125;    &#125;    else if(dir == 3)&#123; // 向下        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1||arr[i][c]==0) return;            if(arr[i][c]&gt;0) arr[i][c]--;        &#125;    &#125;&#125;\n\n此函數根據指定方向 dir，將 $(r, c)$ 到下一個木樁 (-1) 或空地 (0) 之間的線 (&gt;0) 計數減 1。\n加入連線 (add)void add(int r,int c,int dir)&#123;    if(dir == 0)&#123; // 向右        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1) return;            arr[r][i]++;        &#125;    &#125;    else if(dir == 1)&#123; // 向左        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1) return;            arr[r][i]++;        &#125;    &#125;    else if(dir == 2)&#123; // 向上        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1) return;            arr[i][c]++;        &#125;    &#125;    else if(dir == 3)&#123; // 向下        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1) return;            arr[i][c]++;        &#125;    &#125;&#125;\n\n此函數根據指定方向 dir，將 $(r, c)$ 到下一個木樁 (-1) 之間的線計數加 1。\n檢查木樁 (haveStake)bool haveStake(int r, int c, int dir)&#123;    if(dir == 0)&#123; // 向右        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 1)&#123; // 向左        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 2)&#123; // 向上        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 3)&#123; // 向下        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1) return true;        &#125;        return false;    &#125;    return false;&#125;\n\n此函數檢查從 $(r, c)$ 沿指定方向 dir 是否存在木樁 (-1)。\n計算面積 (nowArea)int nowArea()&#123;    int cnt=0;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            if(arr[i][j]!=0) cnt++;        &#125;    &#125;    return cnt;&#125;\n\n此函數遍歷 $m \\times n$ 展場，計算所有非 0 (有木樁或線) 的格子數量。\n主程式：處理操作與輸出int main()&#123;    cin &gt;&gt; m &gt;&gt; n &gt;&gt; h;    for(int hh=0;hh&lt;h;hh++)&#123;        // 陣列值: 0=沒東西,-1是木樁,正數是線的數量        cin &gt;&gt; r &gt;&gt; c &gt;&gt;t;        if(t==0)&#123; // 加入木樁            if(arr[r][c]!=0)&#123; // 如果有線經過，先拆線                if(haveStake(r,c,0))rmv(r,c,0);                if(haveStake(r,c,1))rmv(r,c,1);                if(haveStake(r,c,2))rmv(r,c,2);                if(haveStake(r,c,3))rmv(r,c,3);            &#125;            arr[r][c]=-1; // 放置木樁            // 建立新連線            if(haveStake(r,c,0))add(r,c,0);            if(haveStake(r,c,1))add(r,c,1);            if(haveStake(r,c,2))add(r,c,2);            if(haveStake(r,c,3))add(r,c,3);        &#125;        else&#123;     // 移除木樁            arr[r][c]=0; // 移除木樁            // 移除相關連線            if(haveStake(r,c,0))rmv(r,c,0);            if(haveStake(r,c,1))rmv(r,c,1);            if(haveStake(r,c,2))rmv(r,c,2);            if(haveStake(r,c,3))rmv(r,c,3);  _       &#125;        mx = max(mx,nowArea()); // 更新最大面積    &#125;    cout &lt;&lt; mx &lt;&lt; endl &lt;&lt; nowArea(); // 輸出最大面積與最終面積&#125;\n\n這是程式的主體。它首先讀取 $m, n, h$，然後進入 $h$ 次迴圈，根據 $t$ 的值執行加入或移除木樁的邏輯，並在每次操作後更新最大面積 mx。最後輸出 mx 和 $h$ 次操作後的最終面積。\n完整程式碼#include&lt;iostream&gt;using namespace std;int m, n, h, r, c, t, arr[100][100] = &#123;&#125;, mx = 0;void rmv(int r,int c,int dir)&#123;    if(dir == 0)&#123;        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1||arr[r][i]==0) return;            if(arr[r][i]&gt;0) arr[r][i]--;        &#125;    &#125;    else if(dir == 1)&#123;        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1||arr[r][i]==0) return;            if(arr[r][i]&gt;0) arr[r][i]--;        &#125;    &#125;    else if(dir == 2)&#123;        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1||arr[i][c]==0) return;            if(arr[i][c]&gt;0) arr[i][c]--;        &#125;    &#125;    else if(dir == 3)&#123;        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1||arr[i][c]==0) return;            if(arr[i][c]&gt;0) arr[i][c]--;        &#125;    &#125;&#125;void add(int r,int c,int dir)&#123;    if(dir == 0)&#123;        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1) return;            arr[r][i]++;        &#125;    &#125;    else if(dir == 1)&#123;        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1) return;            arr[r][i]++;        &#125;    &#125;    else if(dir == 2)&#123;        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1) return;            arr[i][c]++;        &#125;    &#125;    else if(dir == 3)&#123;        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1) return;            arr[i][c]++;        &#125;    &#125;&#125;bool haveStake(int r, int c, int dir)&#123;    if(dir == 0)&#123;        for(int i=c+1;i&lt;n;i++)&#123;            if(arr[r][i]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 1)&#123;        for(int i=c-1;i&gt;=0;i--)&#123;            if(arr[r][i]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 2)&#123;        for(int i=r-1;i&gt;=0;i--)&#123;            if(arr[i][c]==-1) return true;        &#125;        return false;    &#125;    else if(dir == 3)&#123;        for(int i=r+1;i&lt;m;i++)&#123;            if(arr[i][c]==-1) return true;        &#125;        return false;    &#125;    return false;&#125;int nowArea()&#123;    int cnt=0;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            if(arr[i][j]!=0) cnt++;        &#125;    &#125;    return cnt;&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n &gt;&gt; h;    for(int hh=0;hh&lt;h;hh++)&#123;        // 陣列值: 0=沒東西,-1是木樁,正數是線的數量        cin &gt;&gt; r &gt;&gt; c &gt;&gt;t;        if(t==0)&#123; // 加入木樁            if(arr[r][c]!=0)&#123;                if(haveStake(r,c,0))rmv(r,c,0);                if(haveStake(r,c,1))rmv(r,c,1);                if(haveStake(r,c,2))rmv(r,c,2);                if(haveStake(r,c,3))rmv(r,c,3);            &#125;            arr[r][c]=-1;            if(haveStake(r,c,0))add(r,c,0);            if(haveStake(r,c,1))add(r,c,1);            if(haveStake(r,c,2))add(r,c,2);            if(haveStake(r,c,3))add(r,c,3);        &#125;        else&#123;     // 移除木樁            arr[r][c]=0;            if(haveStake(r,c,0))rmv(r,c,0);            if(haveStake(r,c,1))rmv(r,c,1);            if(haveStake(r,c,2))rmv(r,c,2);            if(haveStake(r,c,3))rmv(r,c,3);        &#125;        mx = max(mx,nowArea());    &#125;    cout &lt;&lt; mx &lt;&lt; endl &lt;&lt; nowArea();&#125;\n","categories":["APCS"]},{"title":"APCS-2022-10","url":"/2025/08/17/APCS/APCS-2022-10/","content":"1. 巴士站牌解題步驟\n讀取輸入並初始化: 讀取站牌總數 n 和第一個巴士站的座標 (px, py)。\n初始化最大&#x2F;最小值: 初始化最大距離 maxn 為 0（或一個極小值），最小距離 minn 為一個極大值（例如 1000，根據題目範圍 400 已經足夠）。\n迴圈處理剩餘站牌: 使用 for 迴圈，從 $i&#x3D;1$ 迭代到 $n-1$，處理剩下的 $n-1$ 個巴士站（即從第 2 個站到第 $n$ 個站）。\n讀取並計算距離: 在迴圈中，讀取下一個巴士站的座標 (x, y)。接著計算目前站 (x, y) 與前一個站 (px, py) 之間的曼哈頓距離 d。\n更新最大值和最小值: 比較剛算出的距離 d 與 maxn 和 minn。\n如果 d 大於 maxn，則更新 maxn = d。\n如果 d 小於 minn，則更新 minn = d。\n\n\n更新前一站位置: 在迴圈結束前，將目前的座標 (x, y) 存為 “前一個” 座標 (px, py)，供下次迴圈計算距離時使用。\n輸出結果: 迴圈結束後，maxn 和 minn 即為所求的最大值和最小值，將它們依序輸出。\n\n分段步驟程式碼讀取輸入並初始化#include&lt;iostream&gt;using namespace std;int main()&#123;    int n, x, y, px, py, maxn = 0, minn = 1000, d;    cin &gt;&gt; n &gt;&gt; px &gt;&gt; py;\n\n這段程式碼包含了必要的標頭檔和命名空間。在 main 函式中，宣告所有需要的變數。n 是總站數，x 和 y 用於儲存當前讀取的座標，px 和 py 用於儲存前一個站的座標，maxn 和 minn 初始化為 0 和 1000，d 用於儲存距離。接著，讀取總站數 n 以及第一個站的座標 px 和 py。\n迴圈處理、計算距離並更新最大最小值    for(int i=1;i&lt;n;i++)&#123;        cin &gt;&gt; x &gt;&gt; y;        d = abs(px - x) + abs(py - y);        if(maxn &lt; d)&#123;            maxn = d;        &#125;        if(minn &gt; d)&#123;            minn = d;        &#125;        px = x;        py = y;    &#125;\n\n這段程式碼是解題的核心。for 迴圈會執行 n-1 次，剛好對應 $n$ 個站之間的 $n-1$ 段路程。在迴圈內部：\n\n讀取下一個站的座標 x 和 y。\n計算前一站 (px, py) 到這一站 (x, y) 的曼哈頓距離 d。\n使用 if 判斷式更新 maxn 和 minn。\n最後，將 x 和 y 的值賦給 px 和 py，這樣在下一次迴圈時，px 和 py 就代表了 “前一個站” 的座標。\n\n輸出最終位置    cout &lt;&lt; maxn &lt;&lt; &#x27; &#x27; &lt;&lt; minn;&#125;\n\n迴圈結束後，maxn 和 minn 已經儲存了所有相鄰站之間距離的最大值和最小值。這段程式碼將它們用一個空格隔開並輸出，然後結束程式。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n, x, y, px, py, maxn = 0, minn = 1000, d;    // 讀取總站數 n 和第一個站的座標    cin &gt;&gt; n &gt;&gt; px &gt;&gt; py;       // 迴圈處理第 2 個到第 n 個站    for(int i=1;i&lt;n;i++)&#123;        // 讀取下一個站的座標        cin &gt;&gt; x &gt;&gt; y;               // 計算與前一站的曼哈頓距離        d = abs(px - x) + abs(py - y);               // 更新最大距離        if(maxn &lt; d)&#123;            maxn = d;        &#125;               // 更新最小距離        if(minn &gt; d)&#123;            minn = d;        &#125;               // 將目前座標設為 &#x27;前一個&#x27; 座標，供下次迴圈使用        px = x;        py = y;    &#125;       // 輸出最大值和最小值    cout &lt;&lt; maxn &lt;&lt; &#x27; &#x27; &lt;&lt; minn;&#125;\n\n1. 跳柵遊戲解題步驟\n讀取初始生命值和陷阱條件: 讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值: 初始化位置 p 為 0，生命值為 k。\n模擬遊戲過程: 使用 while 迴圈模擬遊戲過程，直到生命值小於等於 0。\n更新位置和生命值: 在每次迴圈中，根據當前生命值更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失。\n輸出最終位置: 當生命值小於等於 0 時，輸出當前位置 p。\n\n分段步驟程式碼讀取初始生命值和陷阱條件int k, x1, x2, y1, y2;cin &gt;&gt; k;cin &gt;&gt; x1 &gt;&gt; y1;cin &gt;&gt; x2 &gt;&gt; y2;\n\n這段程式碼讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值int p = 0;\n\n這段程式碼初始化位置 p 為 0。\n模擬遊戲過程while(k &gt; 0)&#123;    p += k;    int dmg = 0;    if(p % x1 == 0)&#123;        dmg += y1;    &#125;    if(p % x2 == 0)&#123;        dmg += y2;    &#125;    k -= dmg;&#125;\n\n這段程式碼模擬遊戲過程。在每次迴圈中，根據當前生命值 k 更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失 dmg。然後，更新生命值 k。\n輸出最終位置cout &lt;&lt; p;\n\n這段程式碼輸出最終位置 p。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int k, x1, x2, y1, y2;    cin &gt;&gt; k;    cin &gt;&gt; x1 &gt;&gt; y1;    cin &gt;&gt; x2 &gt;&gt; y2;    int p = 0;    while(k&gt;0)&#123;        p += k;        int dmg = 0;        if(p % x1 == 0)&#123;            dmg += y1;        &#125;        if(p % x2 == 0)&#123;            dmg += y2;        &#125;        k -= dmg;    &#125;    cout &lt;&lt; p;&#125;\n\n2.運貨站運貨站要管理$n$個五種不同形狀的貨物，下圖標示出貨物的形狀以及對應的英文代碼。![](file://1.png)現在這$n$個貨物要按照順序堆放在一個容量大小為$R \\times C$的倉庫內，第$i$個貨物的形狀為$t_i$，並且和倉庫的頂部距離為$y_i$(見下圖)。貨物堆放置倉庫內時必須維持和倉庫頂端的高度由右向左推到不能前進為止，並且過程中不行將貨物的方向做旋轉。若有一個貨物不能完整放入倉庫內，則該貨物會被貨運站丟棄。請輸出依序放完這$n$個貨物後，倉庫內有多少剩餘空格，以及被丟棄的貨物有幾個。![](file://2.png)(該貨物類別為 B, 並且離倉庫頂端距離為 2)保證輸入內貨物距離倉庫頂部的高度不會讓貨物底部低於地面，並且不會有任何貨物卡在倉庫門口的情形。## 輸入說明第一行輸入三個數字$R(1 \\le R \\le 30)$,$C(1 \\le C \\le 50)$,$n(1 \\le n \\le 200)$，代表倉庫大小為$R \\times C$以及有$n$個貨物。接下來有$n$行，第$i$行有一個大寫英文字母$t_i$和一個數字$y_i$代表貨物的種類以及和倉庫頂部的距離，貨物種類只會是 A 到 E 的大寫字母。子題配分- (20%) : 只會出現Ｂ類型- (40%) : 只會出現Ａ,Ｂ,Ｃ類型- (40%) : ５種類型都會出現## 輸出說明輸出倉庫剩餘的空格數量，以及被丟棄的貨物數量。## 範例 1### 輸入\n\n5 4 6B 0B 3B 1B 3B 1B 2\n### 輸出\n\n8 2\n## 範例 2### 輸入\n\n5 6 6C 1A 1E 0E 0B 0A 0\n### 輸出\n\n13 2\n\n\n答案\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int r, c, n, out = 0, y;    char t;    cin &gt;&gt; r &gt;&gt; c &gt;&gt; n;    int arr[r][c + 4];    for (int i=0; i&lt;r; i++)&#123;        for(int j=0; j&lt;c+4; j++)&#123;            arr[i][j] = 0;        &#125;    &#125;    for(int i=0; i &lt; r; i++)&#123;        arr[i][0] = 1;    &#125;    for(int nn=0;nn&lt;n;nn++)&#123;        cin &gt;&gt; t &gt;&gt; y;        if(t==&#x27;A&#x27;)&#123;            for(int i=c+1;i&gt;=0;i--)&#123;                if(arr[y][i] || arr[y+1][i] || arr[y+2][i] || arr[y+3][i])&#123;                    if(i+1&lt;c+1)&#123;                        arr[y][i+1] = 1;                        arr[y+1][i+1] = 1;                        arr[y+2][i+1] = 1;                        arr[y+3][i+1] = 1;                    &#125;else&#123;                        out++;                    &#125;                    break;                &#125;            &#125;        &#125;else if(t==&#x27;B&#x27;)&#123;            for(int i=c+1;i&gt;=0;i--)&#123;                if(arr[y][i])&#123;                    if(i+3 &lt; c+1)&#123;                        arr[y][i+1] = 1;                        arr[y][i+2] = 1;                        arr[y][i+3] = 1;                    &#125;else&#123;                        out++;                    &#125;                    break;                &#125;            &#125;        &#125;else if(t==&#x27;C&#x27;)&#123;            for(int i=c+1;i&gt;=0;i--)&#123;                if(arr[y][i] || arr[y+1][i])&#123;                    if(i+2 &lt; c+1)&#123;                        arr[y][i+1] = 1;                        arr[y][i+2] = 1;                        arr[y+1][i+1] = 1;                        arr[y+1][i+2] = 1;                    &#125;else&#123;                        out++;                    &#125;                    break;                &#125;            &#125;        &#125;else if(t==&#x27;D&#x27;)&#123;            for(int i=c+1;i&gt;=0;i--)&#123;                if(arr[y+1][i] || arr[y][i+2])&#123;                    if(i+3 &lt; c+1)&#123;         // 0 0 1                        arr[y+1][i+1] = 1; // 1 1 1                        arr[y+1][i+2] = 1;                        arr[y+1][i+3] = 1;                        arr[y][i+3] = 1;                    &#125;else&#123;                        out++;                    &#125;                    break;                &#125;            &#125;        &#125;else if(t==&#x27;E&#x27;)&#123;            for(int i=c+1;i&gt;=0;i--)&#123;                if(arr[y][i+1] || arr[y+1][i] || arr[y+2][i])&#123;                    if(i+2 &lt; c+1)&#123;         // 0 1                        arr[y][i+2] = 1;   // 1 1                        arr[y+1][i+1] = 1; // 1 1                        arr[y+1][i+2] = 1;                        arr[y+2][i+1] = 1;                        arr[y+2][i+2] = 1;                    &#125;else&#123;                        out++;                    &#125;                    break;                &#125;            &#125;        &#125;        // for (int i=0; i&lt; r; i++)&#123;        //     for(int j=0; j &lt; c+1;j++)&#123;        //         cout&lt;&lt;arr[i][j]&lt;&lt; &#x27; &#x27;;        //     &#125;cout&lt;&lt;endl;        // &#125;        // cout&lt;&lt;&quot;----&quot;&lt;&lt;endl;    &#125;    int blank = 0;    for (int i=0; i&lt; r; i++)&#123;        for(int j=0; j &lt; c+1;j++)&#123;            if(arr[i][j]==0)&#123;                blank++;            &#125;        &#125;    &#125;    cout &lt;&lt; blank &lt;&lt; &#x27; &#x27; &lt;&lt; out;&#125;// 2 0 0 0 0 0 0 _ _ _// 2 0 0 0 0 0 0 1 1 1// 2 0 0 0 0 0 0 _// 2 0 0 0 0 0 0 _// 2 0 0 0 0 0 0 _\n","categories":["APCS"]},{"title":"APCS-2023-01","url":"/2025/08/10/APCS/APCS-2023-01/","content":"1. 程式考試解題步驟\n讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。\n迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。\n讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。\n如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。\n否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。\n如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。\n如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。\n\n\n計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。\n處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。\n輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。\n\n分段步驟程式碼讀取提交次數與初始化變數int n,t,s,maxtime=0,maxScore=-1,errors=0;cin &gt;&gt; n;\n\n這段程式碼讀取總提交次數 n。並初始化四個重要變數：\n\nt 和 s 用於在迴圈中儲存每次讀取的時間和分數。\nmaxtime 用於儲存第一次獲得最高分的時間。\nmaxScore 儲存目前為止的最高分，初始化為 -1，因為 0 是一個有效的最低分。\nerrors 用於計算嚴重錯誤 (-1) 的次數。\n\n迴圈處理每次提交for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; t &gt;&gt; s;    if(s == -1)&#123;        errors++;    &#125;else if(maxScore &lt; s)&#123;        maxtime = t;        maxScore = s;    &#125;&#125;\n\n這段程式碼使用 for 迴圈遍歷 n 筆提交紀錄。\n\n每次讀入時間 t 和分數 s。\n使用 if-else if 結構來判斷：\n如果 s == -1，errors 計數器加 1。\n否則，如果 s &gt; maxScore ( else if(maxScore &lt; s) )，表示這是一個新的最高分，此時更新 maxScore 和 maxtime。\n\n\n注意：如果 s == maxScore，這個條件不會觸發，maxtime 不會被更新，這就保證了 maxtime 儲存的是第一次達到最高分的時間。\n\n計算總分並輸出結果int score = maxScore - n - errors * 2;if(score &lt; 0)&#123;    cout &lt;&lt; &quot;0&quot;;&#125;else&#123;    cout &lt;&lt; score;&#125;cout &lt;&lt; &quot; &quot; &lt;&lt; maxtime;\n\n這段程式碼在迴圈結束後執行。\n\n首先根據題目公式 最高分 - 總提交次數 - 總嚴重錯誤次數 * 2 計算總分 score。\n接著，判斷 score 是否小於 0。如果是，則按題目要求輸出 0；否則輸出計算出的 score。\n最後，輸出一個空格和儲存的 maxtime。\n\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n,t,s,maxtime=0,maxScore=-1,errors=0;    cin &gt;&gt; n;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; t &gt;&gt; s;        if(s == -1)&#123;            errors++;        &#125;else if(maxScore &lt; s)&#123;            maxtime = t;            maxScore = s;        &#125;    &#125;    int score = maxScore - n - errors * 2;    if(score &lt; 0)&#123;        cout &lt;&lt; &quot;0&quot;;    &#125;else&#123;        cout &lt;&lt; score;    &#125;    cout &lt;&lt; &quot; &quot; &lt;&lt; maxtime;&#125;\n\n2. 造字程式解題步驟\n讀取基本資訊: 讀取字串長度 k、修改次數 q、輸出行數 r，以及初始字串 s。\n宣告儲存陣列: 宣告一個 2D 字元陣列 c[q][k]，用來儲存 q 次修改後的所有字串結果。同時宣告一個 1D 陣列 p[k] 用於暫存每次讀取的排列。\n模擬 Q 次修改: 使用一個 for 迴圈，從 i = 0 到 q-1，模擬每一次修改操作。\n執行單次修改:\n在迴圈內部，首先讀取當次的排列 p。\n建立一個暫存字串 tmp 並使其等於當前的字串 s（即舊字串）。\n再用一個 for 迴圈，根據排列 p 的規則，將 tmp 的字元複製到 s 中對應的位置，產生新字串。 (核心邏輯：s[p[j]-1] = tmp[j])\n\n\n儲存結果: 將本次修改產生的新字串 s 存入 2D 陣列 c 的第 i 列 (row) 中。\n依格式輸出: 所有修改完成後，使用巢狀迴圈來輸出。\n外層迴圈 i 從 0 到 r-1（代表要輸出的第 i 個字元，共 r 行）。\n內層迴圈 j 從 0 到 q-1（代表第 j 次修改的結果）。\n在內層迴圈中輸出 c[j][i]，即第 j 次修改結果的第 i 個字元。\n外層迴圈每跑完一次，就輸出一行換行符。\n\n\n\n分段步驟程式碼讀取基本資訊與宣告陣列int k, q, r;string s;cin &gt;&gt; k &gt;&gt; q &gt;&gt; r &gt;&gt; s;int p[k];char c[q][k];\n\n這段程式碼讀取 k, q, r 和初始字串 s。並宣告 p 陣列用來儲存每次讀入的排列，c 陣列用來儲存 q 次修改的全部結果。\n模擬修改過程並儲存結果for(int i=0;i&lt;q;i++)&#123;    for(int j=0;j&lt;k;j++)&#123;        cin &gt;&gt; p[j];    &#125;    string tmp = s;    for(int j=0;j&lt;k;j++)&#123;        s[p[j]-1] = tmp[j];    &#125;    for(int j=0;j&lt;k;j++)&#123;        c[i][j] = s[j];    &#125;&#125;\n\n這段程式碼是解題的核心。\n\n外層迴圈 for(int i=0;i&lt;q;i++) 執行 q 次修改。\ncin &gt;&gt; p[j]; 讀取該次的排列。\nstring tmp = s; 將當前的字串 s (舊字串) 複製到 tmp。\ns[p[j]-1] = tmp[j]; 根據排列 p，將 tmp (舊字串) 的第 j 個字元，放到 s (新字串) 的第 p[j]-1 個位置上。\nc[i][j] = s[j]; 將剛產生出來的新字串 s，完整複製到 c[i] 這一列，以便後續輸出。\n\n依格式輸出for(int i=0;i&lt;r;i++)&#123;    for(int j=0;j&lt;q;j++)&#123;        cout &lt;&lt; c[j][i];    &#125;    cout&lt;&lt;endl;&#125;\n\n這段程式碼負責最後的輸出。\n\n外層迴圈 i 跑 r 次，代表要輸出 r 行。\n內層迴圈 j 跑 q 次，代表 q 次修改的結果。\ncout &lt;&lt; c[j][i]; 輸出的順序是：\n第 1 行 (i=0)：輸出 c[0][0], c[1][0], c[2][0]… (所有結果的第 1 個字元)\n第 2 行 (i=1)：輸出 c[0][1], c[1][1], c[2][1]… (所有結果的第 2 個字元)\n…\n第 r 行 (i=r-1)：輸出 c[0][r-1], c[1][r-1], c[2][r-1]… (所有結果的第 r 個字元)\n\n\n這恰好符合題目要求的「轉置」輸出格式。\n\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int k, q, r;    string s;    cin &gt;&gt; k &gt;&gt; q &gt;&gt; r &gt;&gt; s;    int p[k];    char c[q][k];    for(int i=0;i&lt;q;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin &gt;&gt; p[j];        &#125;        string tmp = s;        for(int j=0;j&lt;k;j++)&#123;            s[p[j]-1] = tmp[j];        &#125;        for(int j=0;j&lt;k;j++)&#123;            c[i][j] = s[j];        &#125;    &#125;    for(int i=0;i&lt;r;i++)&#123;        for(int j=0;j&lt;q;j++)&#123;            cout &lt;&lt; c[j][i];        &#125;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS"]},{"title":"APCS-2022-06","url":"/2025/09/07/APCS/APCS-2022-06/","content":"1. 數字遊戲解題步驟\n初始化變數: 宣告一個大小為 9 的整數陣列 cnt 用於計算 1 到 9 每個數字出現的次數，並將其全部初始化為 0。宣告一個整數 max_cnt 用於儲存「出現最多次的次數」，並初始化為 0。\n讀取輸入與統計: 使用 for 迴圈執行 3 次。在迴圈中：\n讀取一個整數 P。\n將 cnt[P-1] 的值加 1（例如，讀到 6，就增加 cnt[5] 的計數）。\n檢查 cnt[P-1] 是否大於 max_cnt，如果是，則更新 max_cnt = cnt[P-1]。\n\n\n輸出最大次數: 迴圈結束後，max_cnt 儲存的就是出現最多次的數字的次數（即 $P$），將其輸出。\n輸出不重複數字: 使用一個 for 迴圈，從 9 遞減到 1 (變數 i 從 9 到 1)。\n在迴圈中，檢查 cnt[i-1] 是否大於 0。\n如果大於 0，表示數字 i 在輸入中出現過，將 i 輸出。\n\n\n\n分段步驟程式碼初始化變數與計數陣列int P, max_cnt = 0;int cnt[9] = &#123;0&#125;;\n\n這段程式碼宣告了用於讀取輸入的變數 P、儲存最大次數的 max_cnt，以及一個大小為 9 的陣列 cnt 來儲存 1~9 的出現次數，並初始化所有值為 0。\n讀取輸入、統計次數並更新最大次數for(int i=0;i&lt;3;i++)&#123;    cin &gt;&gt; P;    cnt[P-1]++;    if(cnt[P-1]&gt;max_cnt)&#123;        max_cnt = cnt[P-1];    &#125;&#125;\n\n這段程式碼使用迴圈讀取 3 個數字。每讀到一個數字 P，就對應增加 cnt[P-1] 的計數。同時，它會不斷檢查並更新 max_cnt，以確保 max_cnt 始終儲存當前為止出現過的最大次數。\n輸出最大次數cout &lt;&lt; max_cnt &lt;&lt; &#x27; &#x27;;\n\n這段程式碼輸出在前面步驟中計算出來的最大次數，即題目要求的 $P$。\n依序輸出不重複數字for(int i=9;i&gt;=1;i--)&#123;    if(cnt[i-1]&gt;0)&#123;        cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;    &#125;&#125;\n\n這段程式碼從 9 開始反向遍歷到 1。透過檢查 cnt[i-1] 是否大於 0，來判斷數字 i 是否在輸入中出現過。如果出現過，就將其輸出。由於是從 9 向下檢查，因此能確保輸出是「由大到小」的順序。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int P, max_cnt = 0;    int cnt[9] = &#123;0&#125;;    for(int i=0;i&lt;3;i++)&#123;        cin &gt;&gt; P;        cnt[P-1]++;        if(cnt[P-1]&gt;max_cnt)&#123;            max_cnt = cnt[P-1];        &#125;    &#125;    cout &lt;&lt; max_cnt &lt;&lt; &#x27; &#x27;;    for(int i=9;i&gt;=1;i--)&#123;        if(cnt[i-1]&gt;0)&#123;            cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;        &#125;    &#125;&#125;\n\n2. 字串解碼解題步驟\n讀取輸入資料: 讀取加密層數 m、字串長度 n。接著使用 vector&lt;string&gt; 儲存 m 個加密鍵 keys，最後讀取經過 m 層加密後的字串 encode。\n建立反向解密迴圈: 加密是從第 0 層進行到第 m-1 層。因此，解密必須反向操作，使用一個 for 迴圈從 i = m-1 迭代到 0。\n反向解密 - 步驟 2 (重建字串): 在每一層解密中，我們需要反轉加密的步驟 2。\n加密是「從 S 的頭&#x2F;尾取字元，放到 T 的尾端」。\n解密就是「從 encode (即 T) 的尾端取字元，根據 key 放回 decode (即 S) 的頭端或尾端」。\n我們從 j = n-1 迭代到 0 來反向讀取 key。\n如果 key[j] == &#39;1&#39; (加密時從 S 尾端取)，解密時就將 encode.back() 放到 decode 的 _尾端_。\n如果 key[j] == &#39;0&#39; (加密時從 S 前端取)，解密時就將 encode.back() 放到 decode 的 _前端_。\n\n\n計算 ‘1’ 的數量: 在執行步驟 3 的同時，計算當前 key 中 ‘1’ 的總數 cnt。\n反向解密 - 步驟 1 (交換字串): 檢查 cnt 是否為奇數。如果是，代表加密時曾執行過「交換字串」的操作。因此在解密時，我們需要執行 反向 的交換（將後半部移到前面，前半部移到後面）來還原字串。\n更新字串狀態: 將當前層解密完成的 decode 字串，賦值回 encode 變數，作為下一層解密迴圈的輸入。\n輸出最終結果: 當 m 層迴圈全部解密完畢後，encode 變數中儲存的即為原始字串，將其輸出。\n\n分段步驟程式碼讀取輸入資料int m,n;cin &gt;&gt; m &gt;&gt; n;string encode;vector&lt;string&gt; keys(m);for(int i=0;i&lt;m;i++)&#123;    cin &gt;&gt; keys[i];&#125;cin &gt;&gt; encode;\n\n這段程式碼讀取加密層數 m 和字串長度 n，宣告一個 vector&lt;string&gt; 來儲存 m 個加密鍵，並讀取最終的加密字串 encode。\n反向解密迴圈for(int i=m-1;i&gt;=0;i--)&#123;    string key = keys[i];    int cnt = 0;    string decode = &quot;&quot;;    // ... (步驟 2 和 步驟 1 的反向邏輯) ...    encode = decode; // 更新 encode 以進行下一層解密&#125;\n\n這段程式碼建立一個for 迴圈，從最後一層密鑰 m-1 開始反向迭代到第 0 層。每次迴圈都會處理一層解密，並將解密結果 decode 存回 encode，供上一個解密層使用。\n反向步驟 2 (重建字串)        for(int j=n-1;j&gt;=0;j--)&#123;            if(key[j]==&#x27;1&#x27;)&#123;                cnt++;                decode = decode + encode.back();                encode.pop_back();            &#125;else&#123;                decode = encode.back() + decode;                encode.pop_back();            &#125;        &#125;\n\n這段程式碼反向執行加密的步驟 2。它從 n-1 開始迭代 key，並從 encode 的尾端 pop_back() 取出字元。根據 key[j] 是 ‘1’ 還是 ‘0’，將取出的字元加到 decode 的尾端或前端，同時計算 ‘1’ 的數量 cnt。\n反向步驟 1 (交換字串)        if(cnt%2==1)&#123;            if(n%2==1)&#123;                decode = decode.substr((n-1)/2+1,n)                       + decode[(n-1)/2]                       + decode.substr(0,(n-1)/2);            &#125;else&#123;                decode = decode.substr(n/2,n)                       + decode.substr(0,n/2);            &#125;        &#125;\n\n在重建完 decode 字串後，檢查 cnt 是否為奇數。如果是，則執行反向的交換操作，將 decode 的後半段和前半段對調（並正確處理奇數長度的中間字元），以還原加密步驟 1 的交換。\n輸出最終結果cout &lt;&lt; encode;\n\n在所有 m 層迴圈都執行完畢後，encode 變數中儲存的即是完全解密後的原始字串，將其輸出。\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int m,n;    cin &gt;&gt; m &gt;&gt; n;    string encode;    vector&lt;string&gt; keys(m);    for(int i=0;i&lt;m;i++)&#123;        cin &gt;&gt; keys[i];    &#125;    cin &gt;&gt; encode;    for(int i=m-1;i&gt;=0;i--)&#123;        string key = keys[i];        int cnt = 0;        string decode = &quot;&quot;;        for(int j=n-1;j&gt;=0;j--)&#123;            if(key[j]==&#x27;1&#x27;)&#123;                cnt++;                decode = decode + encode.back();                encode.pop_back();            &#125;else&#123;                decode = encode.back() + decode;                encode.pop_back();            &#125;        &#125;        if(cnt%2==1)&#123;            if(n%2==1)&#123;                decode = decode.substr((n-1)/2+1,n)                       + decode[(n-1)/2]                       + decode.substr(0,(n-1)/2);            &#125;else&#123;                decode = decode.substr(n/2,n)                       + decode.substr(0,n/2);            &#125;        &#125;        encode = decode;    &#125;    cout &lt;&lt; encode;&#125;\n","categories":["APCS"]},{"title":"APCS-2023-06","url":"/2025/08/03/APCS/APCS-2023-06/","content":"1. 路徑偵測解題步驟\n讀取輸入: 讀取座標點的總數 n。\n初始化狀態:\n定義 d 來表示目前方向 (1&#x3D;右, 2&#x3D;上, 3&#x3D;左, 4&#x3D;下)。\n根據題目，初始方向為向右，所以 d = 1。\n初始化左轉 l、右轉 r、迴轉 re 的計數器為 0。\n讀取第一個點的座標 (x, y)，這將作為我們路徑的起始位置。\n\n\n迴圈處理路徑: 使用 for 迴圈，從 i=1 到 n-1，讀取剩下的 n-1 個點。\n讀取下一個點: 在迴圈中，讀取下一個點的座標 (nx, ny)。\n判斷轉向:\n使用 if-else if 結構，根據目前方向 d 進行判斷。\n在d 的條件下，比較目前座標 (x, y) 和下一個座標 (nx, ny) 的相對位置。\n例如：如果 d=1 (目前向右)，而 ny &gt; y (下一個點在上方)，這代表一次左轉。此時 l++ 並更新 d=2 (新方向為上)。\n如果 d=1 (目前向右)，而 nx &lt; x (下一個點在左方)，這代表一次迴轉。此時 re++ 並更新 d=3 (新方向為左)。\n依此類推，完成所有四個方向的判斷。\n\n\n更新目前位置: 在判斷完轉向後，將 x = nx 和 y = ny，使下一個點成為新的目前位置，以供下一次迴圈判斷。\n輸出結果: 迴圈結束後，輸出 l, r, re 的值。\n\n分段步驟程式碼初始化狀態並讀取第一個點int n,x,y,nx,ny,d=1,l=0,r=0,re=0;cin&gt;&gt;n;cin&gt;&gt;x&gt;&gt;y;\n\n這段程式碼讀取點的總數 n。初始化目前方向 d=1 (向右)，左轉 l、右轉 r、迴轉 re 計數器為 0。讀取第一個點的座標 x, y，這也確立了我們的初始位置。\n迴圈處理所有轉向for(int i=1;i&lt;n;i++)&#123;    cin&gt;&gt;nx&gt;&gt;ny;    if(d==1)&#123; // 目前向右        if(ny &gt; y)&#123; // 向上 (左轉)            l++;            d=2;        &#125;else if(ny &lt; y)&#123; // 向下 (右轉)            r++;            d=4;        &#125;else if(nx &lt; x)&#123; // 向左 (迴轉)            re++;            d=3;        &#125;    &#125;else if(d==2)&#123; // 目前向上        if(nx &gt; x)&#123; // 向右 (右轉)            r++;            d=1;        &#125;else if(nx &lt; x)&#123; // 向左 (左轉)            l++;            d=3;        &#125;else if(ny &lt; y)&#123; // 向下 (迴轉)            re++;            d=4;        &#125;    &#125;else if(d==3)&#123; // 目前向左        if(ny &gt; y)&#123; // 向上 (右轉)            r++;            d=2;        &#125;else if(ny &lt; y)&#123; // 向下 (左轉)            l++;            d=4;        &#125;else if(nx &gt; x)&#123; // 向右 (迴轉)            re++;            d=1;        &#125;    &#125;else if(d==4)&#123; // 目前向下        if(nx &gt; x)&#123; // 向右 (左轉)            l++;            d=1;        &#125;else if(nx &lt; x)&#123; // 向左 (右轉)            r++;            d=3;        &#125;else if(ny &gt; y)&#123; // 向上 (迴轉)            re++;            d=2;        &#125;    &#125;    x=nx; // 更新目前位置    y=ny;&#125;\n\n這段程式碼是解題的核心。它遍歷 n-1 次，每次讀取下一個點 (nx, ny)。接著，它檢查目前的方向 d：\n\nd=1 (向右): 檢查 Y 軸變化（ny &gt; y 左轉, ny &lt; y 右轉）或 X 軸變化（nx &lt; x 迴轉）。\nd=2 (向上): 檢查 X 軸變化（nx &gt; x 右轉, nx &lt; x 左轉）或 Y 軸變化（ny &lt; y 迴轉）。\nd=3 (向左): 檢查 Y 軸變化（ny &gt; y 右轉, ny &lt; y 左轉）或 X 軸變化（nx &gt; x 迴轉）。\nd=4 (向下): 檢查 X 軸變化（nx &gt; x 左轉, nx &lt; x 右轉）或 Y 軸變化（ny &gt; y 迴轉）。\n\n每次偵測到轉向，就增加對應的計數器 (l, r, re) 並更新方向 d。如果沒有轉向（例如 d=1 且 nx &gt; x），則 d 保持不變。最後，將 x 和 y 更新為 nx 和 ny，為下一次迴圈做準備。\n輸出結果cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;re;\n\n迴圈結束後，l, r, re 已記錄所有轉向次數，將它們依序輸出。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n,x,y,nx,ny,d=1,l=0,r=0,re=0;    cin&gt;&gt;n;    cin&gt;&gt;x&gt;&gt;y;    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;nx&gt;&gt;ny;        if(d==1)&#123;            if(ny &gt; y)&#123;                l++;                d=2;            &#125;else if(ny &lt; y)&#123;                r++;                d=4;            &#125;else if(nx &lt; x)&#123;                re++;                d=3;            &#125;        &#125;else if(d==2)&#123;            if(nx &gt; x)&#123;                r++;                d=1;            &#125;else if(nx &lt; x)&#123;                l++;                d=3;            &#125;else if(ny &lt; y)&#123;                re++;                d=4;            &#125;        &#125;else if(d==3)&#123;            if(ny &gt; y)&#123;                r++;                d=2;            &#125;else if(ny &lt; y)&#123;                l++;                d=4;            &#125;else if(nx &gt; x)&#123;                re++;                d=1;            &#125;        &#125;else if(d==4)&#123;            if(nx &gt; x)&#123;                l++;                d=1;            &#125;else if(nx &lt; x)&#123;                r++;                d=3;            &#125;else if(ny &gt; y)&#123;                re++;                d=2;            &#125;        &#125;        x=nx;        y=ny;    &#125;    cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;re;&#125;\n\n2. 特殊位置解題步驟\n讀取矩陣維度和內容: 讀取 $n$、$m$ 以及 $n \\times m$ 矩陣 a 的所有元素。\n初始化答案儲存: 宣告一個 vector&lt;pair&lt;int, int&gt;&gt; ans 來儲存所有特殊位置的座標。\n遍歷所有位置: 使用兩層 for 迴圈，依序檢查矩陣中的每一個位置 (i, j)。\n計算範圍內總和: 對於當前位置 (i, j)，令 x = a[i][j]。接著使用兩層 for 迴圈遍歷矩陣中所有位置 (x_pos, y_pos)。\n檢查曼哈頓距離: 計算 (i, j) 與 (x_pos, y_pos) 的曼哈頓距離 |i - x_pos| + |j - y_pos|。\n累加總和: 如果距離小於等於 x (即 a[i][j])，則將 a[x_pos][y_pos] 加入總和 sum。\n檢查特殊位置條件: 對於 (i, j)，計算完 sum 後，檢查 sum % 10 是否等於 x (即 a[i][j])。如果相等，則將 (i, j) 存入 ans 中。\n輸出結果: 遍歷結束後，首先輸出 ans 的大小 (即特殊位置的總數)，然後依序（字典序）輸出 ans 中儲存的每一個座標。\n\n分段步驟程式碼讀取矩陣維度和內容int n,m;cin &gt;&gt; n &gt;&gt; m;int a[n][m];for(int i=0;i&lt;n;i++)&#123;    for(int j=0;j&lt;m;j++)&#123;        cin &gt;&gt; a[i][j];    &#125;&#125;\n\n這段程式碼讀取矩陣的維度 $n$ 和 $m$，並使用兩層迴圈讀取 $n \\times m$ 個矩陣元素，存儲在 a 陣列中。\n初始化答案儲存vector&lt;pair&lt;int, int&gt;&gt; ans;\n\n這段程式碼初始化一個 vector，其元素型別為 pair&lt;int, int&gt;，用來儲存所有找到的特殊位置座標。\n遍歷、計算並檢查特殊位置for(int i=0;i&lt;n;i++)&#123;    for(int j=0;j&lt;m;j++)&#123;        int sum = 0;        for(int x=0;x&lt;n;x++)&#123;            for(int y=0;y&lt;m;y++)&#123;                if( (abs(i-x) + abs(j-y)) &lt;= a[i][j])&#123;                    sum+=a[x][y];                &#125;            &#125;        &#125;        if(sum%10==a[i][j])&#123;            ans.push_back(&#123;i,j&#125;);        &#125;    &#125;&#125;\n\n這是解題的核心。\n\n最外層的兩層迴圈 (i, j) 用於遍歷矩陣中的每一個位置。\n對於每個 (i, j)，初始化 sum = 0。\n內層的兩層迴圈 (x, y) 用於遍歷所有矩陣位置，以計算曼哈頓距離。\nif 判斷式檢查 (x, y) 是否在 (i, j) 的曼哈頓距離 a[i][j] 範圍內。\n如果在範圍內，將 a[x][y] 累加到 sum。\n內層迴圈結束後，檢查 sum % 10 是否等於 a[i][j]。如果成立，表示 (i, j) 是一個特殊位置，將其座標 (i, j) 加入 ans 中。\n\n輸出最終答案cout &lt;&lt; ans.size() &lt;&lt; endl;for(int i=0;i&lt;ans.size();i++)&#123;    cout &lt;&lt; ans[i].first &lt;&lt; &#x27; &#x27; &lt;&lt; ans[i].second &lt;&lt; endl;&#125;\n\n這段程式碼首先輸出 ans.size()，即特殊位置的總數。接著，使用一個迴圈遍歷 ans，並依序輸出儲存的每個座標。由於 ans 是按照 (i, j) 字典序（先行後列）的順序加入的，因此輸出時自然會符合字典序。\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt; // 雖然 abs 在 iostream 中常被隱含，但標準 C++ 中 abs(int) 在 &lt;cmath&gt;using namespace std;int main()&#123;    int n,m;    cin &gt;&gt; n &gt;&gt; m;    int a[n][m];    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;    vector&lt;pair&lt;int, int&gt;&gt; ans;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            int sum = 0;            for(int x=0;x&lt;n;x++)&#123;                for(int y=0;y&lt;m;y++)&#123;                    if( (abs(i-x) + abs(j-y)) &lt;= a[i][j])&#123;                        sum+=a[x][y];                    &#125;                &#125;            &#125;            if(sum%10==a[i][j])&#123;                ans.push_back(&#123;i,j&#125;);            &#125;        &#125;    &#125;    cout &lt;&lt; ans.size() &lt;&lt; endl;    for(int i=0;i&lt;ans.size();i++)&#123;        cout &lt;&lt; ans[i].first &lt;&lt; &#x27; &#x27; &lt;&lt; ans[i].second &lt;&lt; endl;    &#125;&#125;\n","categories":["APCS"]},{"title":"APCS-2023-10","url":"/2025/07/06/APCS/APCS-2023-10/","content":"1. 機械鼠解題步驟\n讀取初始位置和食物數量：讀取老鼠的初始位置 x 和食物的總數 n。\n初始化變數：\nmin：用來儲存最左邊食物的位置，初始為一個極大值 (例如 101)。\nmax：用來儲存最右邊食物的位置，初始為一個極小值 (例如 -101)。\nstep：用來計算老鼠左邊的食物數量，初始為 0。\nnow：用來暫存當前讀取的食物位置。\n\n\n遍歷所有食物：使用 for 迴圈讀取 n 個食物的位置。\n分類食物位置：\n在迴圈中，檢查每個食物的位置 now。\n如果 now &lt; x，表示食物在老鼠左邊。將左邊食物計數 step 加 1，並更新 min (如果 now 比當前的 min 更小)。\n如果 now &gt; x，表示食物在老鼠右邊。更新 max (如果 now 比當前的 max 更大)。\n\n\n計算右側食物數量：迴圈結束後，右側食物的數量即為 n - step。\n比較並輸出：\n比較左側食物數量 step 和右側食物數量 n - step。\n如果 step 比較大，表示往左走能吃到更多食物。輸出 step 和最左邊的位置 min。\n否則 (右側數量大於或等於左側數量)，表示往右走能吃到更多或相等數量的食物。輸出 n - step 和最右邊的位置 max。\n\n\n\n分段步驟程式碼讀取輸入並初始化變數int x, n;cin &gt;&gt; x &gt;&gt; n;int min = 101, max = -101, step = 0, now;\n\n這段程式碼讀取老鼠的初始位置 x 和食物數量 n。接著初始化四個變數：\n\nmin 設為 101 (大於最大可能位置 100)，用來找最小值。\nmax 設為 -101 (小於最小可能位置 -100)，用來找最大值。\nstep 設為 0，用來計算左側食物的數量。\nnow 用於在迴圈中儲存當前讀取的食物位置。\n\n遍歷並分類食物for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; now;    if(now&lt;x)&#123;        step++;        if(now&lt;min)min=now;    &#125;else&#123;        if(now&gt;max)max=now;    &#125;&#125;\n\n這段程式碼使用 for 迴圈讀取 n 個食物的位置。\n\n如果當前食物位置 now 小於 x，表示食物在老鼠左側。step (左側計數) 加 1，並檢查 now 是否比當前的 min 更小，是的話就更新 min。\n否則 (食物在右側)，檢查 now 是否比當前的 max 更大，是的話就更新 max。\n\n比較並輸出結果if(step &gt; n - step)&#123;    cout &lt;&lt; step &lt;&lt; &quot; &quot; &lt;&lt; min;&#125;else&#123;    cout &lt;&lt; n - step &lt;&lt; &quot; &quot; &lt;&lt; max;&#125;\n\n這段程式碼比較左側食物的數量 step 和右側食物的數量 n - step。\n\n如果 step (左側) 比較多，就輸出左側的數量 step 和最左側的位置 min。\n如果 n - step (右側) 比較多或兩者相等，就輸出右側的數量 n - step 和最右側的位置 max。\n\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123;    int x, n;    cin &gt;&gt; x &gt;&gt; n;    int min = 101, max = -101, step = 0, now;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; now;        if(now&lt;x)&#123;            step++;            if(now&lt;min)min=now;        &#125;else&#123;            if(now&gt;max)max=now;        &#125;    &#125;    if(step &gt; n - step)&#123;        cout &lt;&lt; step &lt;&lt; &quot; &quot; &lt;&lt; min;    &#125;else&#123;        cout &lt;&lt; n - step &lt;&lt; &quot; &quot; &lt;&lt; max;    &#125;&#125;\n\n2. 卡牌遊戲解題步驟\n讀取表格大小和內容: 讀取 $n$、$m$ 以及 $n \\times m$ 表格的所有數字。\n初始化分數: 初始化總分 score = 0。\n模擬消除過程: 使用一個 while 迴圈來模擬消除過程。這個迴圈會一直執行，直到某一輪「沒有任何一對牌」被成功消除為止。\n標記本輪狀態: 在 while 迴圈的開頭，設定一個布林變數 chk = false，用來追蹤這一輪是否發生了消除。\n遍歷尋找配對:\n使用兩層 for 迴圈遍歷表格中的每個格子 (i, j)。\n如果格子 (i, j) 尚未被消除 (我們用 $\\geq 0$ 的值表示尚未消除)，則開始尋找配對。\n\n\n檢查垂直方向:\n從 (i, j) 向下 (即 r 從 i+1 到 n-1) 檢查同一行 j 上的格子 (r, j)。\n如果找到 num[i][j] == num[r][j]，表示找到配對。此時：\n將 num[i][j] 的值加入 score。\n將 num[i][j] 和 num[r][j] 都設為 -1 (標記為已消除)。\n設定 chk = true (表示本輪有成功消除)。\nbreak 停止垂直搜尋。\n\n\n如果在找到配對前，先遇到一個 num[r][j] &gt;= 0 (即一個尚未消除的 不同 數字)，表示路徑被阻擋，break 停止垂直搜尋。\n\n\n檢查水平方向:\n(在檢查水平前，再次檢查 num[i][j] 是否 $\\geq 0$，因為它可能剛好在垂直檢查中被消除了)。\n從 (i, j) 向右 (即 r 從 j+1 到 m-1) 檢查同一列 i 上的格子 (i, r)。\n套用與垂直檢查相同的邏輯：找到配對就加分、標記為 -1、設 chk = true 並 break；遇到障礙物也 break。\n\n\n輸出最終分數: 當 while 迴圈結束 (因為 chk 保持為 false) 時，表示所有可消除的配對都已處理完畢，輸出總分 score。\n\n分段步驟程式碼讀取輸入與初始化int n,m;cin &gt;&gt; n &gt;&gt; m;int num[n][m] = &#123;&#125;, score = 0;for(int i=0;i&lt;n;i++)&#123;    for(int j=0;j&lt;m;j++)&#123;        cin &gt;&gt; num[i][j];    &#125;&#125;\n\n這段程式碼讀取表格的行數 n 和列數 m。接著，宣告一個 $n \\times m$ 的二維陣列 num 來儲存表格內容，並初始化分數 score 為 0。最後，使用巢狀迴圈讀取所有格子的數值。\n模擬消除迴圈bool chk = true;while(chk)&#123;    chk = false;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            // ... 檢查邏輯 ...        &#125;    &#125;&#125;\n\n這段程式碼是模擬的核心。while(chk) 迴圈會持續執行，只要上一輪 (chk = true) 有成功消除。每輪開始時，先將 chk 重設為 false。接著，使用兩層 for 迴圈遍歷表格中的每一個格子 (i, j)。\n檢查垂直與水平配對            if(num[i][j] &lt; 0) continue; // 如果 (i, j) 已消除，跳過            // 檢查垂直方向            for(int r=i+1;r&lt;n;r++)&#123;                if(num[i][j]==num[r][j])&#123; // 找到配對                    score += num[i][j];                    num[i][j] = -1; // 標記為已消除                    num[r][j] = -1; // 標記為已消除                    chk = true; // 標記本輪有消除                    break; // 停止垂直搜尋                &#125;                if(num[r][j]&gt;=0)&#123; // 遇到障礙物                    break; // 停止垂直搜尋                &#125;            &#125;            if(num[i][j] &lt; 0) continue; // 再次檢查 (可能被垂直消除了)            // 檢查水平方向            for(int r=j+1;r&lt;m;r++)&#123;                if(num[i][j]==num[i][r])&#123; // 找到配對                    score += num[i][j];                    num[i][j] = -1; // 標記為已消除                    num[i][r] = -1; // 標記為已消除                    chk = true; // 標記本輪有消除                    break; // 停止水平搜尋                &#125;                if(num[i][r]&gt;=0)&#123; // 遇到障礙物                    break; // 停止水平搜尋                &#125;            &#125;\n\n這段程式碼位於 for(j...) 迴圈內部。\n\n首先檢查 (i, j) 是否已被消除 (值 &lt; 0)，若是則 continue。\n垂直檢查: 向下搜尋 (r, j)。如果找到相同的值，則加分、將兩者都設為 -1、將 chk 設為 true，並 break。如果先找到 $\\geq 0$ 的不同值 (障礙物)，也 break。\n水平檢查: 再次檢查 (i, j) (因為它可能剛被垂直檢查消除)。如果未被消除，則向右搜尋 (i, r)，執行與垂直檢查相同的邏輯。\n\n輸出最終分數cout &lt;&lt; score;\n\n當 while(chk) 迴圈結束 (即 chk 在一整輪中都保持為 false)，表示沒有更多可以消除的配對。此時，輸出累計的總分 score。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n,m;    cin &gt;&gt; n &gt;&gt; m;    int num[n][m] = &#123;&#125;, score = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin &gt;&gt; num[i][j];        &#125;    &#125;    bool chk = true;    while(chk)&#123;        chk = false;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                if(num[i][j] &lt; 0) continue;                for(int r=i+1;r&lt;n;r++)&#123;                    if(num[i][j]==num[r][j])&#123;                        score += num[i][j];                        num[i][j] = -1;                        num[r][j] = -1;                        chk = true;                        break;                    &#125;                    if(num[r][j]&gt;=0)&#123;                        break;                    &#125;                &#125;                if(num[i][j] &lt; 0) continue;                for(int r=j+1;r&lt;m;r++)&#123;                    if(num[i][j]==num[i][r])&#123;                        score += num[i][j];                        num[i][j] = -1;                        num[i][r] = -1;                        chk = true;                        break;                    &#125;                  _ if(num[i][r]&gt;=0)&#123;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; score;&#125;\n","categories":["APCS"]},{"title":"APCS-2024-06","url":"/2025/05/25/APCS/APCS-2024-06/","content":"1. 特技表演解題步驟\n讀取輸入資料: 讀取大樓的總數 n，接著使用一個 for 迴圈讀取 n 棟大樓分別的高度，並將它們儲存在一個陣列 h 中。\n初始化變數: 初始化兩個整數變數。max_d 用來儲存找到的「最長」滑翔路徑長度，初始為 0。d 用來儲存「當前」正在計算的連續滑翔路徑長度，初始為 1（因為任何一棟大樓本身都構成長度為 1 的路徑）。\n遍歷大樓陣列: 使用 for 迴圈從第一棟大樓 (i = 0) 檢查到倒數第二棟大樓 (i &lt; n-1)。\n判斷路徑是否延伸: 在迴圈中，比較目前大樓 h[i] 和下一棟大樓 h[i+1] 的高度。\n如果 h[i] &gt; h[i+1]，表示符合「越來越低」的條件，滑翔路徑可以繼續，因此將當前路徑長度 d 增加 1 (d++)。\n如果 h[i] &lt;= h[i+1]，表示路徑中斷（高度沒有變低），因此重置當前路徑長度 d 為 1（從 h[i+1] 重新開始計算）。\n\n\n更新最長路徑: 在每次判斷（或重置）d 之後，都要檢查 d 是否大於 max_d。如果 d 更大，就更新 max_d = d。\n輸出結果: 迴圈結束後，max_d 中儲存的就是整個過程中最長的路徑長度，將其輸出。\n\n分段步驟程式碼讀取輸入資料int n;cin &gt;&gt; n;int h[n];for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; h[i];&#125;\n\n這段程式碼首先讀取大樓的數量 n，然後宣告一個大小為 n 的陣列 h，並使用迴圈讀取每棟大樓的高度。\n初始化變數int max_d = 0, d=1;\n\n這段程式碼初始化 max_d 為 0（最終的最長路徑）和 d 為 1（當前計算的路徑）。\n遍歷、比較並更新最長路徑for(int i=0;i&lt;n-1;i++)&#123;    if(h[i]&gt;h[i+1])&#123;        d++;    &#125;    else&#123;        d = 1;    &#125;    if(d&gt;max_d)&#123;        max_d = d;    &#125;&#125;\n\n這段程式碼是解題的核心。它遍歷 n-1 次（比較 h[0] 和 h[1]、h[1] 和 h[2]…）。\n\n如果 h[i] &gt; h[i+1]，當前路徑 d 增加。\n否則，路徑中斷，d 重置為 1。\n每一次迴圈都會檢查 d 是否是新的最大值 max_d。\n\n輸出結果cout &lt;&lt; max_d;\n\n這段程式碼在所有比較完成後，輸出儲存的最長路徑 max_d。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int h[n];    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; h[i];    &#125;    int max_d = 0, d=1;    for(int i=0;i&lt;n-1;i++)&#123;        if(h[i]&gt;h[i+1])&#123;            d++;        &#125;        else&#123;            d = 1;        &#125;        if(d&gt;max_d)&#123;            max_d = d;        &#125;    &#125;    cout &lt;&lt; max_d;&#125;\n\n2. 電子畫布解題步驟\n引入函式庫與宣告: 引入 iostream (用於輸入輸出) 和 vector (用於建立二維畫布)。\n宣告輔助函式: 宣告一個計算曼哈頓距離的函式 m_dis 的原型。\n讀取基本資訊: 在 main 函式中，讀取畫布高度 h、寬度 w 和操作次數 n。\n初始化畫布: 使用 vector&lt;vector&lt;int&gt;&gt; 建立一個 h x w 的二維向量 board，並將所有初始值設為 0。\n模擬操作: 使用一個 for 迴圈執行 n 次：\n讀取該次操作的座標 (r, c)、範圍 t 和顏色值 x。\n使用 巢狀迴圈 遍歷畫布上的 每一個 座標 (hh, ww) (從 0 到 h-1，0 到 w-1)。\n呼叫 m_dis(hh, ww, r, c) 計算當前座標與操作中心 (r, c) 的曼哈頓距離。\n如果距離小於等於 t，則將 board[hh][ww] 的值加上 x。\n\n\n輸出結果: n 次操作都完成後，使用巢狀迴圈遍歷 board，並依序印出每個格子的最終數值。\n實作輔助函式: 在 main 函式之後，實作 m_dis 函式，計算並回傳 |hh - r| + |ww - c|。\n\n分段步驟程式碼引入函式庫與函式原型#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// 宣告計算曼哈頓距離的函式原型int m_dis(int,int,int,int);\n\n這段程式碼引入必要的函式庫，並宣告 m_dis 函式，以便 main 函式可以呼叫它。\n讀取輸入與初始化畫布int main()&#123;    int h, w, n;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; n;    // 使用 vector 建立 h x w 的二維畫布，並全部初始化為 0    vector&lt;vector&lt;int&gt;&gt; board(h,vector&lt;int&gt;(w,0));    // ...&#125;\n\n這段程式碼讀取畫布尺寸和操作次數，並動態建立一個 h x w 的二維向量 board。\n模擬 N 次畫筆操作    int r, c, t, x;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t &gt;&gt; x; // 讀取單次操作        // 遍歷畫布上的每一個點        for(int hh=0;hh&lt;h;hh++)&#123;            for(int ww=0;ww&lt;w;ww++)&#123;                // 檢查是否在曼哈頓距離 t 以內                if(m_dis(hh, ww, r, c)&lt;=t)&#123;                    board[hh][ww] += x; // 累加顏色值                &#125;            &#125;        &#125;    &#125;\n\n這段程式碼是解題的核心。它使用一個迴圈來處理 n 次操作。對於每次操作，它都會遍歷 整個 畫布，檢查每個格子是否在影響範圍內，並如果是，就累加顏色值。\n輸出畫布狀態    // 遍歷畫布並輸出最終狀態    for(int hh=0;hh&lt;h;hh++)&#123;        for(int ww=0;ww&lt;w;ww++)&#123;            cout&lt;&lt; board[hh][ww]&lt;&lt; &#x27; &#x27;;        &#125;        cout&lt;&lt;endl; // 每印完一行就換行    &#125;&#125; // main 函式結束\n\n這段程式碼在所有操作完成後，依序印出二維向量 board 中的所有值。\n曼哈頓距離函式實作// 實作 m_dis 函式int m_dis(int hh, int ww, int r, int c)&#123;    int h_diff = hh-r;    int w_diff = ww-c;    // 計算絕對值    if(h_diff&lt;0) h_diff*=-1;    if(w_diff&lt;0) w_diff*=-1;    // 回傳曼哈頓距離    return h_diff + w_diff;&#125;\n\n這段程式碼實作了計算曼哈頓距離的輔助函式。它計算兩個座標 (hh, ww) 和 (r, c) 之間 x 座標差的絕對值與 y 座標差的絕對值之和。\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// 曼哈頓距離函式原型int m_dis(int,int,int,int);int main()&#123;    int h, w, n;    int r, c, t, x;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; n;       // 初始化 h x w 畫布，全為 0    vector&lt;vector&lt;int&gt;&gt; board(h,vector&lt;int&gt;(w,0));    // 進行 n 次操作    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t &gt;&gt; x;        // 遍歷所有格子        for(int hh=0;hh&lt;h;hh++)&#123;            for(int ww=0;ww&lt;w;ww++)&#123;                // 如果在範圍內，就加上顏色                if(m_dis(hh, ww, r, c)&lt;=t)&#123;                    board[hh][ww] += x;                &#125;            &#125;        &#125;    &#125;    // 輸出最終畫布狀態    for(int hh=0;hh&lt;h;hh++)&#123;        for(int ww=0;ww&lt;w;ww++)&#123;            cout&lt;&lt; board[hh][ww]&lt;&lt; &#x27; &#x27;;        &#125;        cout&lt;&lt;endl;    &#125;&#125;// 曼哈頓距離函式實作int m_dis(int hh, int ww, int r, int c)&#123;    int h_diff = hh-r;    int w_diff = ww-c;    // 取絕對值    if(h_diff&lt;0) h_diff*=-1;    if(w_diff&lt;0) w_diff*=-1;    return h_diff + w_diff;&#125;\n","categories":["APCS"]},{"title":"APCS-2024-01","url":"/2025/06/22/APCS/APCS-2024-01/","content":"1. 遊戲選角解題步驟\n讀取角色數量和資料：讀取角色總數 n。使用迴圈讀取 n 次，每次讀取一個角色的攻擊力 a 和防禦力 d。\n儲存資料：使用一個二維 vector (或結構陣列) 來儲存每個角色的攻擊力和防禦力。vector&lt;vector&lt;int&gt;&gt; s 中，s[i][0] 儲存第 i 個角色的攻擊力，s[i][1] 儲存防禦力。\n定義比較函式：要根據「能力值」（$攻擊力^2 + 防禦力^2$）來排序。我們需要自訂一個比較函式 cmp，它接受兩個角色資料 (例如 vector&lt;int&gt; a 和 vector&lt;int&gt; b)。\n實作比較邏輯：在 cmp 函式中，計算 a 的能力值 (a[0]*a[0]+a[1]*a[1]) 和 b 的能力值 (b[0]*b[0]+b[1]*b[1])。為了得到第二大的值，我們需要從大到小 (descending) 排序，所以函式應回傳 a 的能力值是否大於 b 的能力值。\n排序：使用 std::sort 函式，搭配自訂的 cmp 比較函式，對儲存所有角色資料的 vector 進行排序。\n輸出結果：排序後，vector 中的第 0 個元素 ( s[0] ) 具有最大的能力值。因此，第 1 個元素 ( s[1] ) 具有第二大的能力值。輸出 s[1][0] (攻擊力) 和 s[1][1] (防禦力)。\n\n分段步驟程式碼包含函式庫與自訂比較函式#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// 自訂比較函式// 根據能力值 (a*a + d*d) 由大到小排序bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;    return a[0]*a[0]+a[1]*a[1] &gt; b[0]*b[0]+b[1]*b[1];&#125;\n\n這段程式碼包含了必要的函式庫 (iostream, vector, algorithm)。並定義了一個比較函式 cmp，用於 sort。它計算兩個輸入 vector (分別代表兩個角色) 的能力值平方和，並回傳第一個是否大於第二個，以實現降冪排序。\n讀取輸入並儲存int main()&#123;    int n;    cin &gt;&gt; n ;    // 宣告一個 n x 2 的二維 vector 來儲存 n 個角色的攻擊力和防禦力    vector&lt;vector&lt;int&gt;&gt; s(n,vector&lt;int&gt;(2));    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; s[i][0] &gt;&gt; s[i][1];    &#125;    // ...\n\n在 main 函式中，首先讀取角色數量 n。然後，宣告一個名為 s 的二維 vector，它有 n 列，每列有 2 個元素。接著，使用迴圈讀取 n 行輸入，將攻擊力和防禦力分別存入 s[i][0] 和 s[i][1]。\n排序與輸出    // ...    // 使用 std::sort 並傳入自訂的 cmp 函式來排序    sort(s.begin(),s.end(),cmp);    // 排序後，s[0] 是能力值最大的，s[1] 是第二大的    // 輸出 s[1] 的攻擊力和防禦力    cout &lt;&lt; s[1][0] &lt;&lt; &#x27; &#x27; &lt;&lt; s[1][1];&#125;\n\n這段程式碼呼叫 std::sort，對 s 向量從頭到尾 (s.begin() 到 s.end()) 進行排序，並使用 cmp 函式作為排序的標準。排序完成後，s[1] 中儲存的就是能力值第二大的角色資料。最後，輸出 s[1][0] (攻擊力) 和 s[1][1] (防禦力)，並以空格分隔。\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// 自訂比較函式// 比較兩個角色 (a, b) 的能力值// 能力值 = 攻擊力^2 + 防禦力^2// 回傳 true 表示 a 應該排在 b 前面 (降冪排序)bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;    return a[0]*a[0]+a[1]*a[1] &gt; b[0]*b[0]+b[1]*b[1];&#125;int main()&#123;    int n;    cin &gt;&gt; n ; // 讀取角色數量    // 宣告 n x 2 的二維 vector 儲存資料    vector&lt;vector&lt;int&gt;&gt; s(n,vector&lt;int&gt;(2));    // 迴圈讀取 n 個角色的攻擊力 (s[i][0]) 和防禦力 (s[i][1])    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; s[i][0] &gt;&gt; s[i][1];    &#125;    // 使用 std::sort 和自訂的 cmp 函式對角色    // 根據能力值進行降冪排序    sort(s.begin(),s.end(),cmp);    // 排序後，s[0] 是第一名，s[1] 是第二名    // 輸出第二名角色的攻擊力和防禦力    cout &lt;&lt; s[1][0] &lt;&lt; &#x27; &#x27; &lt;&lt; s[1][1];&#125;\n\n2. 蜜蜂觀察解題步驟\n讀取輸入: 讀取蜂巢大小 $m$、$n$ 以及總步數 $k$。\n儲存蜂巢地圖: 建立一個 $m \\times n$ 的二維資料結構（例如 vector&lt;string&gt;），並讀取 $m$ 行字串來儲存蜂巢上每個格子的字母。\n初始化狀態:\n設定 Bob 的起始位置 (x, y) 在左下角，即 (m-1, 0)。\n建立一個大小為 52 的整數陣列 abc 並全部初始化為 0，用來分別統計 26 個大寫字母和 26 個小寫字母出現的次數。\n\n\n模擬移動過程:\n使用一個 for 迴圈執行 $k$ 次，代表 Bob 的 $k$ 步移動。\n在迴圈中，首先讀取該步驟的移動方向 step。\n檢查邊界並移動: 根據 step 的值 (0-5)，判斷移動後的新位置是否會超出蜂巢邊界（撞牆）。\n如果不會超出邊界，則更新 x 和 y 座標。\n如果會超出邊界，x 和 y 座標保持不變（停在原地）。\n\n\n記錄路徑與字元:\n輸出當前位置 (x, y) 上的字元 comb[x][y]。\n將 abc 陣列中對應的字元計數加 1。需區分大小寫，例如 ‘A’-‘Z’ 對應 0-25，’a’-‘z’ 對應 26-51。\n\n\n\n\n計算並輸出字元種類數:\n迴圈結束後，宣告一個變數 diff 來計算種類數。\n遍歷 abc 陣列 (0 到 51)，如果 abc[i] &gt; 0（表示該字元至少出現過一次），則將 diff 加 1。\n最後，換行並輸出 diff 的值。\n\n\n\n分段步驟程式碼讀取輸入與儲存蜂巢地圖int m,n,k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;vector&lt;string&gt; comb(m);for(int i=0;i&lt;m;i++)&#123;    cin &gt;&gt; comb[i];&#125;\n\n這段程式碼讀取蜂巢大小 $m$、$n$ 和步數 $k$。然後使用 vector&lt;string&gt; 讀取並儲存 $m \\times n$ 的蜂巢地圖。\n初始化狀態int x=m-1,y=0, step;int abc[52] = &#123;&#125;;\n\n這段程式碼初始化 Bob 的起始位置 x=m-1、y=0（左下角）。並初始化一個大小為 52 的計數陣列 abc 為全 0，用來統計 52 種（大小寫相異）字母的出現次數。\n模擬移動過程 (迴圈與移動邏輯)for(int i=0;i&lt;k;i++)&#123;    cin &gt;&gt; step;    if(step==0)&#123;        if(x-1&gt;=0)&#123; // 往上 (Up)            x--;        &#125;    &#125;    else if(step==1)&#123;        if(y+1&lt;n)&#123; // 往右 (Right)            y++;        &#125;    &#125;    else if(step==2)&#123;        if(x+1&lt;m &amp;&amp; y+1&lt;n)&#123; // 往右下 (Down-Right)            x++;            y++;        &#125;    &#125;    else if(step==3)&#123;        if(x+1&lt;m)&#123; // 往下 (Down)            x++;        &#125;    &#125;    else if(step==4)&#123;        if(y-1&gt;=0)&#123; // 往左 (Left)            y--;        &#125;    &#125;    else if(step==5)&#123;        if(x-1&gt;=0 &amp;&amp; y-1&gt;=0)&#123; // 往左上 (Up-Left)            x--;            y--;        &#125;    &#125;    // ... (記錄路徑與字元)\n\n這段程式碼是 k 步移動的主迴圈。\n\n讀取每一步的方向 step。\n使用 if-else if 結構判斷 6 種方向。\n在更新座標 x 和 y 之前，先檢查新位置是否仍在 $m \\times n$ 的範圍內。如果超出範圍（撞牆），則不更新座標，Bob 停在原地。\n\n記錄路徑與字元 (在迴圈內)    cout &lt;&lt; comb[x][y];    if (comb[x][y] &gt;= &#x27;a&#x27;)&#123;        abc[comb[x][y]-&#x27;a&#x27;+26]++;    &#125;else&#123;        abc[comb[x][y]-&#x27;A&#x27;]++;    &#125;&#125; // for 迴圈結束\n\n這段程式碼在 for 迴圈內，緊接在移動邏輯之後。\n\ncout &lt;&lt; comb[x][y]; 輸出當前（移動後或停在原地）位置的字元，累加成路徑字串。\nif-else 判斷當前字元是小寫還大寫：\n大寫：’A’ 對應 abc[0]，’B’ 對應 abc[1] …\n小寫：’a’ 對應 abc[26]，’b’ 對應 abc[27] …並將對應的計數器加 1。\n\n\n\n計算並輸出字元種類數int diff = 0;for(int i=0;i&lt;52;i++)&#123;    diff += abc[i]&gt;0 ;&#125;cout&lt;&lt;endl&lt;&lt;diff;\n\n這段程式碼在 for 迴圈結束後執行。\n\n初始化種類數 diff 為 0。\n遍歷 abc 陣列，abc[i] &gt; 0 這個布林表達式在 C++ 中會被轉為 1 (true) 或 0 (false)。\n因此，diff 只會累加那些至少出現過一次 (計數 &gt; 0) 的字元種類。\n最後，cout &lt;&lt; endl; 換行，並輸出總種類數 diff。\n\n完整程式碼#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int m,n,k;    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;    vector&lt;string&gt; comb(m);    for(int i=0;i&lt;m;i++)&#123;        cin &gt;&gt; comb[i];    &#125;    int x=m-1,y=0, step;    int abc[52] = &#123;&#125;;    for(int i=0;i&lt;k;i++)&#123;        cin &gt;&gt; step;        if(step==0)&#123;            if(x-1&gt;=0)&#123;                x--;            &#125;        &#125;        else if(step==1)&#123;            if(y+1&lt;n)&#123;                y++;            &#125;        &#125;        else if(step==2)&#123;            if(x+1&lt;m &amp;&amp; y+1&lt;n)&#123;                x++;                y++;            &#125;        &#125;        else if(step==3)&#123;            if(x+1&lt;m)&#123;                x++;            &#125;        &#125;        else if(step==4)&#123;            if(y-1&gt;=0)&#123;                y--;            &#125;        &#125;        else if(step==5)&#123;            if(x-1&gt;=0 &amp;&amp; y-1&gt;=0)&#123;                x--;                y--;            &#125;        &#125;        cout &lt;&lt; comb[x][y];        if (comb[x][y] &gt;= &#x27;a&#x27;)&#123;            abc[comb[x][y]-&#x27;a&#x27;+26]++;        &#125;else&#123;            abc[comb[x][y]-&#x27;A&#x27;]++;        &#125;    &#125;    int diff = 0;    for(int i=0;i&lt;52;i++)&#123;        diff += abc[i]&gt;0 ;    &#125;    cout&lt;&lt;endl&lt;&lt;diff;&#125;\n","categories":["APCS"]},{"title":"APCS-2024-10","url":"/2025/05/18/APCS/APCS-2024-10/","content":"1. 裝飲料解題步驟\n讀取輸入資料: 讀取倒飲料的次數 n，以及杯子兩層的維度 w1, w2, h1, h2。\n計算容量並初始化: 根據維度計算下層的容量 low (即 $w_1 \\times w_1 \\times h_1$) 以及杯子的總容量 high (即 low + $w_2 \\times w_2 \\times h_2$)。\n初始化狀態變數: 初始化總裝入容量 total 為 0，前一次的高度 prev 為 0，以及答案 (最大高度變化) ans 為 0。\n模擬倒水過程: 使用 for 迴圈執行 n 次。\n更新總容量與當前高度: 在迴圈中，讀取該次倒入的容量 water，並將其加入 total。\n判斷水位高度:\n如果 total &lt;= low，表示水位還在下層，curr 高度為 total / (w1*w1)。\n如果 total &lt;= high，表示水位已達上層，curr 高度為 h1 + (total - low) / (w2*w2)。\n如果 total &gt; high，表示水已裝滿，curr 高度為 h1 + h2。\n\n\n更新最大變化量: 計算本次的高度變化 curr - prev，如果這個值大於 ans，則更新 ans。\n更新前次高度: 將 prev 更新為 curr，以供下次迴圈使用。\n輸出結果: 迴圈結束後，輸出 ans。\n\n分段步驟程式碼讀取輸入資料int n, w1, w2, h1, h2, water;cin&gt;&gt;n;cin&gt;&gt;w1&gt;&gt;w2&gt;&gt;h1&gt;&gt;h2;\n\n這段程式碼讀取倒飲料的次數 n 和杯子的四個維度參數。\n計算容量並初始化變數int low = w1*w1*h1, high = low + w2*w2*h2;int total = 0, prev=0, curr, ans=0;\n\n這段程式碼計算下層容量 low 和總容量 high。並初始化總容量 total、前次高度 prev 和最大高度差 ans。\n模擬 n 次倒水過程並計算高度for(int i=0;i&lt;n;i++)&#123;    cin&gt;&gt;water;    total+=water;    if(total&lt;=low)&#123;        curr = total/(w1*w1);    &#125;else if(total&lt;=high)&#123;        curr = h1+(total-low)/(w2*w2);    &#125;else&#123;        curr = h1+h2;    &#125;    if(curr-prev &gt; ans)&#123;        ans = curr-prev;    &#125;    prev = curr;&#125;\n\n這段程式碼是解題的核心。它迴圈 n 次，每次：\n\n讀取當次倒入的容量 water。\n更新總容量 total。\n根據 total 和 low、high 的關係，計算出當前的水位高度 curr。\n計算本次的高度變化 curr - prev，並更新最大變化量 ans。\n將 prev 設為 curr，為下一次計算做準備。\n\n輸出最大變化量cout&lt;&lt;ans;\n\n這段程式碼在所有倒入動作完成後，輸出記錄到的最大高度變化 ans。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int n, w1, w2, h1, h2, water;    cin&gt;&gt;n;    cin&gt;&gt;w1&gt;&gt;w2&gt;&gt;h1&gt;&gt;h2;    int low = w1*w1*h1, high = low + w2*w2*h2;    int total = 0, prev=0, curr, ans=0;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;water;        total+=water;        if(total&lt;=low)&#123;            curr = total/(w1*w1);        &#125;else if(total&lt;=high)&#123;            curr = h1+(total-low)/(w2*w2);        &#125;else&#123;            curr = h1+h2;        &#125;        if(curr-prev &gt; ans)&#123;            ans = curr-prev;        &#125;        prev = curr;        // cout&lt;&lt;ans&lt;&lt;endl;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n\n2. 蒐集寶石解題步驟\n讀取輸入: 讀取地圖大小 M、N，倍數 k，以及機器人初始位置 r、c。\n初始化地圖與邊界: 宣告一個比 M x N 稍大的二維陣列 (例如 102 x 102)。讀取 M x N 的地圖資訊，並在地圖的四周圍上一圈牆壁 (-1)。這樣可以簡化後續的邊界判斷。\n初始化機器人狀態:\n初始化方向 d = 0 (0:右, 1:下, 2:左, 3:上)。\n初始化分數 score = 0。\n初始化撿到的寶石數 ans = 0。\n將 r 和 c 加 1，以配合我們在地圖周圍加上的牆壁邊界 (變為 1-based 索引)。\n\n\n模擬遊戲過程 (主迴圈): 使用 while 迴圈模擬遊戲，迴圈繼續的條件是機器人當前位置 g[r][c] 的寶石數不為 0 (規則 1)。\n執行規則 2 (撿寶石):\nans 增加 1。\nscore 加上 g[r][c] 的寶石數。\ng[r][c] 減 1 (撿走一顆)。\n\n\n執行規則 3 (檢查分數): 檢查 score 是否為 k 的倍數。如果是，方向 d 向右轉 90 度 (d = (d + 1) % 4)。\n執行規則 4 (移動與轉向):\n使用一個 for 迴圈（最多 4 次）來尋找下一步。\n根據當前方向 d 計算出下一步的座標 (new_r, new_c)。\n檢查 g[new_r][new_c] 是否為牆壁 (-1)。\n如果不是牆壁: 更新機器人位置 r = new_r, c = new_c，並 break 這個 for 迴圈（代表成功移動，準備進入下一次 while 迴圈）。\n如果是牆壁: 機器人向右轉 90 度 (d = (d + 1) % 4)，並繼續 for 迴圈，嘗試新的方向。\n\n\n輸出結果: 當 while 迴圈結束時 (機器人停在寶石數為 0 的格子)，輸出 ans。\n\n分段步驟程式碼讀取輸入與初始化邊界int M,N,k,r,c;int g[102][102];cin&gt;&gt;M&gt;&gt;N&gt;&gt;k&gt;&gt;r&gt;&gt;c;// 初始化四周邊界為牆壁 (-1)for(int i=0;i&lt;=M+1;i++)&#123;    g[i][0]=-1;    g[i][N+1]=-1;&#125;for(int i=0;i&lt;=N+1;i++)&#123;    g[0][i]=-1;    g[M+1][i+1]=-1; // 注意：這裡應為 g[M+1][i]&#125;// 讀取地圖資訊for(int i=1;i&lt;=M;i++)&#123;    for(int j=1;j&lt;=N;j++)&#123;        cin&gt;&gt;g[i][j];    &#125;&#125;\n\n\n(註：原始程式碼中 g[M+1][i+1] 應為 g[M+1][i] 才能正確關閉下邊界，但在此範例中不影響主要邏輯)\n這段程式碼讀取基本參數，並在 g[1][1] 到 g[M][N] 的外圍都填上 -1，這樣機器人移動時無需額外判斷是否超出 M x N 範圍，只要檢查是否撞牆 (-1) 即可。\n\n初始化機器人狀態int d=0, score=0, ans=0;r++;c++;\n\n\nd=0 代表初始方向向右。\nscore 和 ans 均從 0 開始。\nr++ 和 c++ 將 0-based 索引的輸入轉換為 1-based 索引，以對應我們加了邊界的地圖。\n\n模擬遊戲過程while(g[r][c]!=0)&#123;    // 規則 2: 撿寶石並更新分數    ans++;    score += g[r][c];    g[r][c]--;    // 規則 3: 根據分數判斷是否右轉    if(score%k==0)&#123;        d = (d+1)%4;    &#125;    // 規則 4: 尋找下一步並移動    for(int j=0;j&lt;4;j++)&#123;        int new_r=r,new_c=c;        if(d==0) new_c++;        else if(d==1) new_r++;        else if(d==2) new_c--;        else if(d==3) new_r--;        if(g[new_r][new_c]!=-1)&#123; // 檢查是否為牆壁            r=new_r;            c=new_c;            break; // 找到路，移動並結束        &#125;        d = (d+1)%4; // 撞牆，向右轉    &#125;&#125;\n\n\nwhile(g[r][c]!&#x3D;0): 這是規則 1，只要當前格子寶石數不為 0 就繼續。\n規則 2 &amp; 3: 程式碼直接對應題目規則。\n規則 4 (for 迴圈): 這是最關鍵的部分。\n它首先嘗試當前方向 d。\n如果 g[new_r][new_c] 不是 -1 (牆壁)，就更新 r, c 並 break，完成移動。\n如果 g[new_r][new_c] 是 -1，就執行 d = (d+1)%4 (向右轉)，for 迴圈繼續，嘗試新的方向。\n這個 for 迴圈保證機器人最終會找到一個非牆壁的方向並移動過去。\n\n\n\n輸出最終結果cout&lt;&lt;ans&lt;&lt;endl;\n\n\n當 while 迴圈終止 (踩到 0)，輸出總共撿到的寶石數 ans。\n\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int M,N,k,r,c;    int g[102][102];    cin&gt;&gt;M&gt;&gt;N&gt;&gt;k&gt;&gt;r&gt;&gt;c;    // 初始化邊界 (padding)    for(int i=0;i&lt;=M+1;i++)&#123;        g[i][0]=-1;        g[i][N+1]=-1;    &#125;    // 修正：應為 g[M+1][i]    for(int i=0;i&lt;=N+1;i++)&#123;        g[0][i]=-1;        g[M+1][i]=-1; // 修正原始碼中的 g[M+1][i+1]    &#125;    // 讀取地圖    for(int i=1;i&lt;=M;i++)&#123;        for(int j=1;j&lt;=N;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    // 初始化機器人狀態    int d=0, score=0, ans=0;    r++;c++; // 轉為 1-based 索引    // 遊戲主迴圈    while(g[r][c]!=0)&#123;        // 規則 2        ans++;        score += g[r][c];        g[r][c]--;        // 規則 3        if(score%k==0)&#123;            d = (d+1)%4;        &#125;        // 規則 4        for(int j=0;j&lt;4;j++)&#123;            int new_r=r,new_c=c;            if(d==0) new_c++;       // 右            else if(d==1) new_r++;  // 下            else if(d==2) new_c--;  // 左            else if(d==3) new_r--;  // 上            if(g[new_r][new_c]!=-1)&#123; // 檢查是否撞牆                r=new_r;                c=new_c;                break; // 成功移動            &#125;            d = (d+1)%4; // 撞牆，右轉        &#125;    &#125;    // 輸出結果    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS"]},{"title":"APCS-2025-01","url":"/2025/05/11/APCS/APCS-2025-01/","content":"1. 等紅綠燈解題步驟\n讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。\n計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。\n遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。\n讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。\n判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。\n累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。\n輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。\n\n分段步驟程式碼讀取輸入與初始化int green, red, n, t, delay = 0;cin &gt;&gt; green &gt;&gt; red &gt;&gt; n;int loop = green + red;\n\n這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。\n遍歷小朋友並計算等待時間for(int i=0;i&lt;n;i++)&#123;    cin &gt;&gt; t;    t %= loop;    if(t &gt;= green)&#123;        delay += loop - t;    &#125;&#125;\n\n這段程式碼使用 for 迴圈處理 n 個小朋友。\n\ncin &gt;&gt; t;：讀取當前小朋友騎完一圈的時間 t。\nt %= loop;：這是解題的關鍵。我們只關心小朋友在紅綠燈週期的 哪個時間點 抵達，而不在乎他繞了幾圈。取 t 對 loop 的餘數，可以得到他在週期中的抵達時間（範圍會是 0 到 loop-1）。\nif(t &gt;= green)：判斷這個抵達時間是否在紅燈時段。綠燈時段是 [0, green-1]，紅燈時段是 [green, loop-1]。\ndelay += loop - t;：如果是在紅燈時段（t）抵達，他需要等到週期結束（loop），因此等待時間為 loop - t。將這段時間累加到 delay。\n\n輸出總等待時間cout &lt;&lt; delay ;\n\n迴圈結束後，delay 已經累計了所有小朋友的等待時間，將其輸出。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int green, red, n, t, delay = 0;    cin &gt;&gt; green &gt;&gt; red &gt;&gt; n;    int loop = green + red;    for(int i=0;i&lt;n;i++)&#123;        cin &gt;&gt; t;        t %= loop;        if(t &gt;= green)&#123;            delay += loop - t;        &#125;    &#125;    cout &lt;&lt; delay ;    return 0;&#125;\n\n2. 字串操作解題步驟\n讀取輸入與初始化: 讀取初始字串 s 和操作次數 k。並儲存字串的長度 s_len 以方便後續使用。\n迴圈處理 K 次操作: 使用一個 for 迴圈，從 i=0 到 k-1，執行 k 次操作。\n讀取並判斷操作類型: 在 for 迴圈中，首先讀取當次的操作類型 op。\n執行操作:\n如果 op == 0 (兩兩交換): 寫一個 for 迴圈，j 從 0 開始，每次遞增 2 (即 0, 2, 4, …)。在迴圈中，使用一個 temp 變數來交換 s[j] 和 s[j+1]。\n如果 op == 1 (兩兩排序): 同樣使用一個 j 迴圈 (步長為 2)。在迴圈中，檢查 if(s[j] &gt; s[j+1])，如果條件成立（即順序錯誤），則交換 s[j] 和 s[j+1]。\n如果 op == 2 (完美重排): 宣告一個暫存字串 s_temp 並將 s 複製過去。接著，寫一個 for 迴圈，i 從 0 跑到 s_len/2 - 1。在迴圈中，將 s_temp 的前半段 s_temp[i] 放到 s 的偶數索引 s[2*i]，並將 s_temp 的後半段 s_temp[i + s_len/2] 放到 s 的奇數索引 s[2*i+1]。\n\n\n輸出最終字串: 在 k 次操作的 for 迴圈結束後，輸出最終的字串 s。\n\n分段步驟程式碼讀取輸入與初始化string s;int k, op;cin &gt;&gt; s &gt;&gt; k;int s_len = s.length();\n\n這段程式碼讀取初始字串 s 和操作次數 k，並將 s 的長度儲存在 s_len 變數中。\n迴圈處理 K 次操作for(int i=0;i&lt;k;i++)&#123;    cin &gt;&gt; op;    // ... 根據 op 執行對應操作 ...&#125;\n\n這段程式碼建立一個迴圈，會執行 k 次。在每次迴圈開始時，讀取使用者輸入的操作類型 op。\n操作 0: 兩兩交換if(op == 0)&#123;    for(int j=0;j&lt;s_len;j+=2)&#123;        char temp = s[j];        s[j]   = s[j+1];        s[j+1] = temp;    &#125;&#125;\n\n如果 op 為 0，此迴圈會遍歷字串的索引 0, 2, 4, …，並將 s[j] 和 s[j+1] 進行交換。\n操作 1: 兩兩排序else if(op == 1)&#123;    for(int j=0;j&lt;s_len;j+=2)&#123;        if(s[j] &gt; s[j+1])&#123;            char temp = s[j];            s[j]   = s[j+1];            s[j+1] = temp;        &#125;    &#125;&#125;\n\n如果 op 為 1，此迴圈同樣遍歷索引 0, 2, 4, …。但只在 s[j] 的字典序大於 s[j+1] 時才進行交換，確保每對字元都按字典序排列。\n操作 2: 完美重排else&#123;    string s_temp = s;    for(int i=0;i&lt;s_len/2;i++)&#123;        s[2*i] = s_temp[i];        s[2*i+1] = s_temp[i+s_len/2];    &#125;&#125;\n\n如果 op 為 2，首先建立一個 s_temp 來保存 s 的原始狀態。然後迴圈 i 從 0 執行到 s_len/2 - 1，將 s_temp 的前半段 s_temp[i] 和後半段 s_temp[i + s_len/2] 交錯放入 s 的 s[2*i] 和 s[2*i+1] 位置。\n輸出最終結果cout &lt;&lt; s;\n\n在 k 次操作全部執行完畢後，輸出字串 s 的最終內容。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    string s;    int k, op;    cin &gt;&gt; s &gt;&gt; k;    int s_len = s.length();    for(int i=0;i&lt;k;i++)&#123;        cin &gt;&gt; op;        if(op == 0)&#123;            for(int j=0;j&lt;s_len;j+=2)&#123;                char temp = s[j];                s[j]   = s[j+1];                s[j+1] = temp;            &#125;        &#125;        else if(op == 1)&#123;            for(int j=0;j&lt;s_len;j+=2)&#123;                if(s[j] &gt; s[j+1])&#123;                    char temp = s[j];                    s[j]   = s[j+1];                    s[j+1] = temp;                &#125;            &#125;        &#125;        else&#123;            string s_temp = s;            for(int i=0;i&lt;s_len/2;i++)&#123;                s[2*i] = s_temp[i];                s[2*i+1] = s_temp[i+s_len/2];            &#125;        &#125;    &#125;    cout &lt;&lt; s;    return 0;&#125;\n","categories":["APCS"]},{"title":"LeetCode 2023/08","url":"/2023/08/14/LeetCode/LeetCode-2023-08/","content":"Week1108. Convert Sorted Array to Binary Search TreeLeetcode Link My Solution\n303. Range Sum Query - ImmutableLeetcode Link My Solution\n202. Happy NumberLeetcode Link My Solution\n232. Implement Queue using StacksLeetcode Link My Solution\n2162. Minimum Cost to Set Cooking TimeLeetcode Link My Solution\n2810. Faulty KeyboardLeetcode Link My Solution\n2811. Check if it is Possible to Split ArrayLeetcode Link My Solution\n2812. Find the Safest Path in a GridLeetcode Link My Solution\n2813. Maximum Elegance of a K-Length SubsequenceLeetcode Link My Solution\nWeek22441. Largest Positive Integer That Exists With Its NegativeLeetcode Link My Solution\n2520. Count the Digits That Divide a NumberLeetcode Link My Solution\n2299. Strong Password Checker IILeetcode Link My Solution\n2423. Remove Letter To Equalize FrequencyLeetcode Link My Solution\n957. Prison Cells After N DaysLeetcode Link My Solution\n900. RLE IteratorLeetcode Link My Solution\n2815. Max Pair Sum in an ArrayLeetcode Link My Solution\n2816. Double a Number Represented as a Linked ListLeetcode Link My Solution\nWeek31929. Concatenation of ArrayLeetcode Link My Solution\n1886. Determine Whether Matrix Can Be Obtained By RotationLeetcode Link My Solution\n1752. Check if Array Is Sorted and RotatedLeetcode Link My Solution\n1518. Water BottlesLeetcode Link My Solution\n57. Insert IntervalLeetcode Link My Solution\n229. Majority Element IILeetcode Link My Solution\n2828. Check if a String Is an Acronym of WordsLeetcode Link My Solution\n2829. Determine the Minimum Sum of a k-avoiding ArrayLeetcode Link My Solution\n2831. Find the Longest Equal SubarrayLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"APCS-2025-06","url":"/2025/06/15/APCS/APCS-2025-06/","content":"1. 跳柵遊戲解題步驟\n讀取初始生命值和陷阱條件: 讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值: 初始化位置 p 為 0，生命值為 k。\n模擬遊戲過程: 使用 while 迴圈模擬遊戲過程，直到生命值小於等於 0。\n更新位置和生命值: 在每次迴圈中，根據當前生命值更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失。\n輸出最終位置: 當生命值小於等於 0 時，輸出當前位置 p。\n\n分段步驟程式碼讀取初始生命值和陷阱條件int k, x1, x2, y1, y2;cin &gt;&gt; k;cin &gt;&gt; x1 &gt;&gt; y1;cin &gt;&gt; x2 &gt;&gt; y2;\n\n這段程式碼讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值int p = 0;\n\n這段程式碼初始化位置 p 為 0。\n模擬遊戲過程while(k &gt; 0)&#123;    p += k;    int dmg = 0;    if(p % x1 == 0)&#123;        dmg += y1;    &#125;    if(p % x2 == 0)&#123;        dmg += y2;    &#125;    k -= dmg;&#125;\n\n這段程式碼模擬遊戲過程。在每次迴圈中，根據當前生命值 k 更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失 dmg。然後，更新生命值 k。\n輸出最終位置cout &lt;&lt; p;\n\n這段程式碼輸出最終位置 p。\n完整程式碼#include&lt;iostream&gt;using namespace std;int main()&#123;    int k, x1, x2, y1, y2;    cin &gt;&gt; k;    cin &gt;&gt; x1 &gt;&gt; y1;    cin &gt;&gt; x2 &gt;&gt; y2;    int p = 0;    while(k&gt;0)&#123;        p += k;        int dmg = 0;        if(p % x1 == 0)&#123;            dmg += y1;        &#125;        if(p % x2 == 0)&#123;            dmg += y2;        &#125;        k -= dmg;    &#125;    cout &lt;&lt; p;&#125;\n\n2. 轉盤得分解題步驟\n讀取輸入: 讀取輪盤數量 m、每個輪盤的字元數量 n、以及遊戲回合數 k。接著讀取 m 個輪盤的初始狀態（字串）。\n模擬遊戲過程: 對於每個遊戲回合，讀取每個輪盤的轉動距離，並根據轉動距離更新輪盤的狀態。\n計算每回合的分數: 對於每個回合，統計每個位置上出現次數最多的字元，將其出現次數累加到該回合的分數中。\n累加總分: 將每個回合的分數累加到總分中。\n輸出總分: 最終輸出遊戲的總分。\n\n分段步驟程式碼讀取輸入int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;vector&lt;string&gt; wheel(m);for (int i = 0; i &lt; m; i++) &#123;    cin &gt;&gt; wheel[i];&#125;\n\n這段程式碼讀取輸入的 m、n、k，並使用 vector&lt;string&gt; 儲存 m 個輪盤的初始狀態。\n模擬遊戲過程for (int loop = 0; loop &lt; k; loop++) &#123;    for (int i = 0; i &lt; m; i++) &#123;        cin &gt;&gt; rotate;        rotate %= n;        if (rotate &lt; 0) rotate += n;        string rotated_wheel = &quot;&quot;;        for (int j = n - rotate; j &lt; n; j++) &#123;            rotated_wheel += wheel[i][j];        &#125;        for (int j = 0; j &lt; n - rotate; j++) &#123;            rotated_wheel += wheel[i][j];        &#125;        wheel[i] = rotated_wheel;    &#125;&#125;\n\n這段程式碼模擬每個遊戲回合的過程。對於每個輪盤，讀取轉動距離 rotate，並將其對 n 取模以確保轉動距離在 [0, n) 範圍內。如果 rotate 為負數，則加上 n 以轉換為等效的正轉動距離。接著，根據 rotate 更新輪盤的狀態。\n計算每回合的分數int score = 0;for (int i = 0; i &lt; n; i++) &#123;    int count[26] = &#123;0&#125;;    for (int j = 0; j &lt; m; j++) &#123;        count[wheel[j][i] - &#x27;a&#x27;]++;    &#125;    int max_count = 0;    for (int j = 0; j &lt; 26; j++) &#123;        if (count[j] &gt; max_count) max_count = count[j];    &#125;    score += max_count;&#125;\n\n這段程式碼計算每個回合的分數。對於每個位置 i，統計 m 個輪盤對應位置的字元出現次數，並找出出現次數最多的字元 max_count。將 max_count 累加到 score 中。\n累加總分與輸出total_score += score;cout &lt;&lt; total_score;\n\n這段程式碼將每個回合的分數 score 累加到總分 total_score 中，並最終輸出 total_score。\n完整程式碼#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    // 讀取輸入    int m, n, k;    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;    vector&lt;string&gt; wheel(m);    for (int i = 0; i &lt; m; i++) &#123;        cin &gt;&gt; wheel[i];    &#125;    int rotate;    int total_score = 0;    // 模擬遊戲過程    for (int loop = 0; loop &lt; k; loop++) &#123;        for (int i = 0; i &lt; m; i++) &#123;            cin &gt;&gt; rotate;            // 計算等效轉動距離            rotate %= n;            if (rotate &lt; 0) rotate += n;            string rotated_wheel = &quot;&quot;;            // 更新輪盤狀態            for (int j = n - rotate; j &lt; n; j++) &#123;                rotated_wheel += wheel[i][j];            &#125;            for (int j = 0; j &lt; n - rotate; j++) &#123;                rotated_wheel += wheel[i][j];            &#125;            wheel[i] = rotated_wheel;        &#125;        // 計算每回合的分數        int score = 0;        for (int i = 0; i &lt; n; i++) &#123;            int count[26] = &#123;0&#125;;  // 統計字元出現次數            for (int j = 0; j &lt; m; j++) &#123;                count[wheel[j][i] - &#x27;a&#x27;]++;            &#125;            int max_count = 0;  // 找出出現次數最多的字元            for (int j = 0; j &lt; 26; j++) &#123;                if (count[j] &gt; max_count) max_count = count[j];            &#125;            score += max_count;        &#125;        // 累加總分        total_score += score;        // cout&lt;&lt;score&lt;&lt;endl; // 可用於 debug    &#125;    // 輸出總分    cout &lt;&lt; total_score;    return 0;&#125;\n","categories":["APCS"]},{"title":"LeetCode 2023/07","url":"/2023/07/03/LeetCode/LeetCode-2023-07/","content":"Week11232. Check If It Is a Straight LineLeetcode Link My Solution\n1071. Greatest Common Divisor of StringsLeetcode Link My Solution\n1160. Find Words That Can Be Formed by CharactersLeetcode Link My Solution\n1323. Maximum 69 NumberLeetcode Link My Solution\n858. Mirror ReflectionLeetcode Link My Solution\n946. Validate Stack SequencesLeetcode Link My Solution\n2748. Number of Beautiful PairsLeetcode Link My Solution\n2750. Ways to Split Array Into Good SubarraysLeetcode Link My Solution\nWeek22418. Sort the PeopleLeetcode Link My Solution\n2437. Number of Valid Clock TimesLeetcode Link My Solution\n2383. Minimum Hours of Training to Win a CompetitionLeetcode Link My Solution\n2363. Merge Similar ItemsLeetcode Link My Solution\n2461. Maximum Sum of Distinct Subarrays With Length KLeetcode Link My Solution\n2419. Longest Subarray With Maximum Bitwise ANDLeetcode Link My Solution\n2760. Longest Even Odd Subarray With ThresholdLeetcode Link My Solution\n2761. Prime Pairs With Target SumLeetcode Link My Solution\nWeek3557. Reverse Words in a String IIILeetcode Link My Solution\n345. Reverse Vowels of a StringLeetcode Link My Solution\n463. Island PerimeterLeetcode Link My Solution\n160. Intersection of Two Linked ListsLeetcode Link My Solution\n6. Zigzag ConversionLeetcode Link My Solution\n1366. Rank Teams by VotesLeetcode Link My Solution\n2769. Find the Maximum Achievable NumberLeetcode Link My Solution\n6899. Maximum Number of Jumps to Reach the Last IndexLeetcode Link My Solution\n6912. Longest Non-decreasing Subarray From Two ArraysLeetcode Link My Solution\nWeek42656. Maximum Sum With Exactly K ElementsLeetcode Link My Solution\n2475. Number of Unequal Triplets in ArrayLeetcode Link My Solution\n2558. Take Gifts From the Richest PileLeetcode Link My Solution\n2278. Percentage of Letter in StringLeetcode Link My Solution\n275. H-Index IILeetcode Link My Solution\n227. Basic Calculator IILeetcode Link My Solution\n2778. Sum of Squares of Special ElementsLeetcode Link My Solution\n2779. Maximum Beauty of an Array After Applying OperationLeetcode Link My Solution\n2780. Minimum Index of a Valid SplitLeetcode Link My Solution\nWeek41394. Find Lucky Integer in an ArrayLeetcode Link My Solution\n1332. Remove Palindromic SubsequencesLeetcode Link My Solution\n1281. Subtract the Product and Sum of Digits of an IntegerLeetcode Link My Solution\n1013. Partition Array Into Three Parts With Equal SumLeetcode Link My Solution\n2249. Count Lattice Points Inside a CircleLeetcode Link My Solution\n2256. Minimum Average DifferenceLeetcode Link My Solution\n2788. Split Strings by SeparatorLeetcode Link My Solution\n2789. Largest Element in an Array after Merge OperationsLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/09","url":"/2023/09/12/LeetCode/LeetCode-2023-09/","content":"Week12341. Maximum Number of Pairs in ArrayLeetcode Link My Solution\n2331. Evaluate Boolean Binary TreeLeetcode Link My Solution\n2500. Delete Greatest Value in Each RowLeetcode Link My Solution\n2744. Find Maximum Number of String PairsLeetcode Link My Solution\n2833. Furthest Point From OriginLeetcode Link My Solution\n2834. Find the Minimum Possible Sum of a Beautiful ArrayLeetcode Link My Solution\nWeek2404. Sum of Left LeavesLeetcode Link My Solution\n263. Ugly NumberLeetcode Link My Solution\n448. Find All Numbers Disappeared in an ArrayLeetcode Link My Solution\n653. Two Sum IV - Input is a BSTLeetcode Link My Solution\n1010. Pairs of Songs With Total Durations Divisible by 60Leetcode Link My Solution\n2848. Points That Intersect With CarsLeetcode Link My Solution\n2849. Determine if a Cell Is Reachable at a Given TimeLeetcode Link My Solution\nWeek31078. Occurrences After BigramLeetcode Link My Solution\n2582. Pass the PillowLeetcode Link My Solution\n2586. Count the Number of Vowel Strings in RangeLeetcode Link My Solution\n2855. Minimum Right Shifts to Sort the ArrayLeetcode Link My Solution\n240. Search a 2D Matrix IILeetcode Link My Solution\n2859. Sum of Values at Indices With K Set BitsLeetcode Link My Solution\n2860. Happy StudentsLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/10","url":"/2023/10/15/LeetCode/LeetCode-2023-10/","content":"Week12413. Smallest Even MultipleLeetcode Link My Solution\n2409. Count Days Spent TogetherLeetcode Link My Solution\n2455. Average Value of Even Numbers That Are Divisible by ThreeLeetcode Link My Solution\n2485. Find the Pivot IntegerLeetcode Link My Solution\n2465. Number of Distinct AveragesLeetcode Link My Solution\n2264. Largest 3-Same-Digit Number in StringLeetcode Link My Solution\n2367. Number of Arithmetic TripletsLeetcode Link My Solution\n2395. Find Subarrays With Equal SumLeetcode Link My Solution\n2605. Form Smallest Number From Two Digit ArraysLeetcode Link My Solution\n2843. Count Symmetric IntegersLeetcode Link My Solution\n50. pow(x, n)Leetcode Link My Solution\n260. Single Number IIILeetcode Link My Solution\n309. Best Time to Buy and Sell Stock with CooldownLeetcode Link My Solution\n2873. Maximum Value of an Ordered Triplet ILeetcode Link My Solution\n2875. Minimum Size Subarray in Infinite ArrayLeetcode Link My Solution\n2894. Divisible and Non-divisible Sums DifferenceLeetcode Link My Solution\n2895. Minimum Processing TimeLeetcode Link My Solution\nWeek22469. Convert the TemperatureLeetcode Link My Solution\n2432. The Employee That Worked on the Longest TaskLeetcode Link My Solution\n2578. Split With Minimum SumLeetcode Link My Solution\n2481. Minimum Cuts to Divide a CircleLeetcode Link My Solution\n2639. Find the Width of Columns of a GridLeetcode Link My Solution\n1093. Statistics from a Large SampleLeetcode Link My Solution\n2903. Find Indices With Index and Value Difference ILeetcode Link My Solution\n2904. Shortest and Lexicographically Smallest Beautiful StringLeetcode Link My Solution\n2905. Find Indices With Index and Value Difference IILeetcode Link My Solution\n2906. Construct Product MatrixLeetcode Link My Solution\nWeek32000. Reverse Prefix of WordLeetcode Link My Solution\n2287. Rearrange Characters to Make Target StringLeetcode Link My Solution\n1848. Minimum Distance to the Target ElementLeetcode Link My Solution\n2562. Find the Array Concatenation ValueLeetcode Link My Solution\n2108. Find First Palindromic String in the ArrayLeetcode Link My Solution\n1315. Sum of Nodes with Even-Valued GrandparentLeetcode Link My Solution\n2908. Minimum Sum of Mountain Triplets ILeetcode Link My Solution\n2909. Minimum Sum of Mountain Triplets IILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/11","url":"/2023/11/05/LeetCode/LeetCode-2023-11/","content":"Week11768. Merge Strings AlternatelyLeetcode Link My Solution\n1071. Greatest Common Divisor of StringsLeetcode Link My Solution\n1431. Kids With the Greatest Number of CandiesLeetcode Link My Solution\n605. Can Place FlowersLeetcode Link My Solution\n345. Reverse Vowels of a StringLeetcode Link My Solution\n151. Reverse Words in a StringLeetcode Link My Solution\n2917. Find the K-or of an ArrayLeetcode Link My Solution\n2918. Minimum Equal Sum of Two Arrays After Replacing ZerosLeetcode Link My Solution\nWeek2283. Move ZeroesLeetcode Link My Solution\n392. Is SubsequenceLeetcode Link My Solution\n643. Maximum Average Subarray ILeetcode Link My Solution\n1732. Find the Highest AltitudeLeetcode Link My Solution\n724. Find Pivot IndexLeetcode Link My Solution\n238. Product of Array Except SelfLeetcode Link My Solution\n2923. Find Champion ILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/03","url":"/2024/03/10/LeetCode/LeetCode-2024-03/","content":"Week11750. Minimum Length of String After Deleting Similar EndsLeetcode Link My Solution\n876. Middle of the Linked ListLeetcode Link My Solution\n141. Linked List CycleLeetcode Link My Solution\n3005. Count Elements With Maximum FrequencyLeetcode Link My Solution\n1768. Merge Strings AlternatelyLeetcode Link My Solution\n2540. Minimum Common ValueLeetcode Link My Solution\n3074. Apple Redistribution into BoxesLeetcode Link My Solution\n3075. Maximize Happiness of Selected ChildrenLeetcode Link My Solution\n3076. Shortest Uncommon Substring in an ArrayLeetcode Link My Solution\n349. Intersection of Two ArraysLeetcode Link My Solution\nWeek2791. Custom Sort StringLeetcode Link My Solution\n238. Product of Array Except SelfLeetcode Link My Solution\nWeek3452. Minimum Number of Arrows to Burst BalloonsLeetcode Link My Solution\n1669. Merge In Between Linked ListsLeetcode Link My Solution\n206. Reverse Linked ListLeetcode Link My Solution\n143. Reorder ListLeetcode Link My Solution\n287. Find the Duplicate NumberLeetcode Link My Solution\n442. Find All Duplicates in an ArrayLeetcode Link My Solution\nWeek441. First Missing PositiveLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/04","url":"/2024/04/07/LeetCode/LeetCode-2024-04/","content":"Week1205. Isomorphic StringsLeetcode Link My Solution\n1544. Make The String GreatLeetcode Link My Solution\n1249. Minimum Remove to Make Valid ParenthesesLeetcode Link My Solution\nWeek2771. Jewels and StonesLeetcode Link My Solution\n42. Trapping Rain WaterLeetcode Link My Solution\n404. Sum of Left LeavesLeetcode Link My Solution\n3114. Latest Time You Can Obtain After Replacing CharactersLeetcode Link My Solution\n3115. Maximum Prime DifferenceLeetcode Link My Solution\nWeek3129. Sum Root to Leaf NumbersLeetcode Link My Solution\n334. Increasing Triplet SubsequenceLeetcode Link My Solution\n623. Add One Row to TreeLeetcode Link My Solution\n1732. Find the Highest AltitudeLeetcode Link My Solution\n1207. Unique Number of OccurrencesLeetcode Link My Solution\n700. Search in a Binary Search TreeLeetcode Link My Solution\n988. Smallest String Starting From LeafLeetcode Link My Solution\n463. Island PerimeterLeetcode Link My Solution\n319. Bulb SwitcherLeetcode Link My Solution\n200. Number of IslandsLeetcode Link My Solution\n456. 132 PatternLeetcode Link My Solution\n1992. Find All Groups of FarmlandLeetcode Link My Solution\n3120. Count the Number of Special Characters ILeetcode Link My Solution\n3121. Count the Number of Special Characters IILeetcode Link My Solution\n139. Word BreakLeetcode Link My Solution\n137. Single Number IILeetcode Link My Solution\n1971. Find if Path Exists in GraphLeetcode Link My Solution\nWeek4310. Minimum Height TreesLeetcode Link My Solution\n1137. N-th Tribonacci NumberLeetcode Link My Solution\n2370. Longest Ideal SubsequenceLeetcode Link My Solution\n3131. Find the Integer Added to Array ILeetcode Link My Solution\n3132. Find the Integer Added to Array IILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/05 W1","url":"/2024/05/02/LeetCode/LeetCode-2024-05-W1/","content":"Week12997. Minimum Number of Operations to Make Array XOR Equal to KLeetcode Link My Solution\n2000. Reverse Prefix of WordLeetcode Link My Solution\n2441. Largest Positive Integer That Exists With Its NegativeLeetcode Link My Solution\n7. Reverse IntegerLeetcode Link My Solution\n8. String to Integer (atoi)Leetcode Link My Solution\n165. Compare Version NumbersLeetcode Link My Solution\n39. Combination SumLeetcode Link My Solution\n881. Boats to Save PeopleLeetcode Link My Solution\n374. Guess Number Higher or LowerLeetcode Link My Solution\n1137. N-th Tribonacci NumberLeetcode Link My Solution\n3136. Valid WordLeetcode Link My Solution\n3137. Minimum Number of Operations to Make Word K-PeriodicLeetcode Link My Solution\n3138. Minimum Length of Anagram ConcatenationLeetcode Link My Solution\n237. Delete Node in a Linked ListLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/05 W2","url":"/2024/05/12/LeetCode/LeetCode-2024-05-W2/","content":"Week22487. Remove Nodes From Linked ListLeetcode Link My Solution\n1004. Max Consecutive Ones IIILeetcode Link My Solution\n933. Number of Recent CallsLeetcode Link My Solution\n104. Maximum Depth of Binary TreeLeetcode Link My Solution\n374. Guess Number Higher or LowerLeetcode Link My Solution\n452. Minimum Number of Arrows to Burst BalloonsLeetcode Link My Solution\n1657. Determine if Two Strings Are CloseLeetcode Link My Solution\n2816. Double a Number Represented as a Linked ListLeetcode Link My Solution\n506. Relative RanksLeetcode Link My Solution\n3075. Maximize Happiness of Selected ChildrenLeetcode Link My Solution\n786. K-th Smallest Prime FractionLeetcode Link My Solution\n857. Minimum Cost to Hire K WorkersLeetcode Link My Solution\n872. Leaf-Similar TreesLeetcode Link My Solution\n790. Domino and Tromino TilingLeetcode Link My Solution\n2373. Largest Local Values in a MatrixLeetcode Link My Solution\n3146. Permutation Difference between Two StringsLeetcode Link My Solution\n3147. Taking Maximum Energy From the Mystic DungeonLeetcode Link My Solution\n3148. Maximum Difference Score in a GridLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode-Writeup 2370. Longest Ideal Subsequence","url":"/2024/04/26/LeetCode-Writeup/LeetCode-Writeup-2370-Longest-Ideal-Subsequence/","content":"2370. Longest Ideal Subsequence這題是個基礎的 DP 題，很值得練習。\nIdea 1 TLE第一種方法，就是當前的字往前檢查可以接的字有哪些，選最高的。\nMain function第 n 個字時，會檢查 n-1 到 1 的字字串的長度\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    for(int j=i-1;j&gt;=0;j--)&#123;        ...    &#125;&#125;\n\n先檢查當前的字和前面的字距離有沒有小於等於 k，如果有才符合題目條件。\n有的話再檢查是否大於目前記錄到的長度。\nif(abs(s[i]-s[j])&lt;=k)&#123;    if(seq[j]&gt;temp)&#123;        temp=seq[j];    &#125;&#125;\n\n找到前面可以接續的最長長度後，加上自己把值存進自己位置的陣列，讓下一個字往前檢查時可以讀到。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\nseq[i]=temp+1;ans=max(ans,seq[i]);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0;        vector&lt;int&gt; seq(n);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(s[i]-s[j])&lt;=k)&#123;                    if(seq[j]&gt;temp)&#123;                        temp=seq[j];                    &#125;                &#125;            &#125;            seq[i]=temp+1;            ans=max(ans,seq[i]);        &#125;        return ans;    &#125;&#125;;\n\nSolution 1第一個方法好理解，但問題是每次往前檢查不知道要檢查到第幾個，因此都檢查到第一個，執行時間是 O(n^2)，雖然有用到 DP 的概念，但不怎麼有效率。\n如何有效的紀錄每個字的狀態？\n第二種方法，不同於紀錄字串每個位置的長度，而是用每個字母紀錄最長的長度。\n因為字元差需要在 k 之間，因此只需檢查當前字母+-k 的字母就可以，\n舉例像是字母 c，k=1，那只需檢查 abcdefgh 就行。\n檢查後將新的值放到 c 的位置，讓下一個字可以繼續更新。\nMain function每個字都還是要跑一遍，用nowWordIdx將當前的字轉換成數字 0 ~ 25\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    nowWordIdx=s[i]-&#x27;a&#x27;;    ...&#125;\n\n透過nowWordIdx，我僅需檢查 +-k 的字，但要注意nowWordIdx-k需大於 0，nowWordIdx+k需小於 25，避免超出範圍。\nfor(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;    if(cnt[j]&gt;temp)&#123;        temp=cnt[j];    &#125;&#125;\n\n當前的字找到最長的值後，加上自己後存在自己字母索引的地方，讓下一個字檢查時可以更新。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\ncnt[nowWordIdx]=temp+1;ans=max(ans,temp+1);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0,nowWordIdx;        vector&lt;int&gt; cnt(26,0);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            nowWordIdx=s[i]-&#x27;a&#x27;;            for(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;                if(cnt[j]&gt;temp)&#123;                    temp=cnt[j];                &#125;            &#125;            cnt[nowWordIdx]=temp+1;            ans=max(ans,temp+1);        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 2441. Largest Positive Integer That Exists With Its Negative","url":"/2024/05/02/LeetCode-Writeup/LeetCode-Writeup-2441-Largest-Positive-Integer-That-Exists-With-Its-Negative/","content":"2441. Largest Positive Integer That Exists With Its NegativeSolution 1檢查數值，如果是正數+1，如果是負數+2，當數值剛好為 3 時代表正數與負數都有出現，正數負數都只會加一次。\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        int table[1001] = &#123;0&#125;;        int ans = -1;        for (auto num : nums) &#123;            if (num &gt; 0) &#123;                if (table[num] == 0 || table[num] == 2) &#123;                    table[num] += 1;                &#125;            &#125; else &#123;                if (table[-num] == 0 || table[-num] == 1) &#123;                    table[-num] += 2;                &#125;            &#125;            cout &lt;&lt; table[abs(num)] &lt;&lt; endl;            if (table[abs(num)] == 3) &#123;                ans = max(ans, abs(num));            &#125;        &#125;        return ans;    &#125;&#125;;\n\nSolution 2將陣列用絕對值大小排序，再來就是從大到小檢查，找出最先出現第 i 數與第 i+1 數互為正負數。\nclass Solution &#123;   public:    static bool cmp(int a, int b) &#123;        if (abs(a) == abs(b)) &#123;            return a &gt; b;        &#125;        return abs(a) &gt; abs(b);    &#125;    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end(), cmp);        int n = nums.size();        for (int i = 0; i &lt; n - 1; i++) &#123;            if (nums[i] == -nums[i + 1]) &#123;                return nums[i];            &#125;        &#125;        return -1;    &#125;&#125;;\n\nSolution 3將陣列大到小排序，雙指標從兩側找出最先符合條件的數字\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;            if (nums[left] * -1 == nums[right]) &#123;                return nums[right];            &#125; else if (nums[left] * -1 &lt; nums[right]) &#123;                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return -1;    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 310. Minimum Height Trees","url":"/2024/04/25/LeetCode-Writeup/LeetCode-Writeup-310-Minimum-Height-Trees/","content":"310. Minimum Height Trees這題問題不難，難在要如何在時間內完成。\nIdea 1 TLE 70&#x2F;71Main function先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    dict[edge[0]].push_back(edge[1]);    dict[edge[1]].push_back(edge[0]);    dictCnt[edge[0]]++;    dictCnt[edge[1]]++;&#125;\n\n再來就是從第 0 個節點開始，迴圈找跟第 0 個節點連結的節點後，用遞迴的方式往下尋找以第 0 個節點為首的最常深度，以下用第 0 個節點開始作為範例。如果當前節點連結數只有 1，代表他只和第 0 個節點有連接，因此不須往下檢查。\nif (dictCnt[i] == 1) &#123;    continue;&#125;\n\n如果有大於 1 的連接數，則可繼續往下，檢查第 0 個節點是否有更深的深度。depth 為當前節點所記錄的深度，ansDepth 為整體最短深度，當前節點深度已經大於記錄到的最短深度時，則代表一定不會是答案，則跳出了不需浪費時間檢查。\nfor (auto now : dict[i]) &#123;    depth = max(depth, maxDepth(i, now, ansDepth));    if (depth &gt; ansDepth) &#123;        break;    &#125;&#125;\n\n因為題目是要找出哪些節點做為根節點有最低深度，因此如果當前節點深度與目前最低深度的節點相同，則同為答案，如果小於最低深度，代表有更小深度的根節點，則最小深度要重新記錄。\nif (depth == ansDepth) &#123;    ans.push_back(i);&#125; else if (depth &lt; ansDepth) &#123;    ansDepth = depth;    ans = &#123;i&#125;;&#125;\n\nRecursion那我的要遞迴什麼?當找到子節點又有除了根節點以外的連結，則須往下檢查深度。參數有三個：根節點值、當前節點值、最低深度\n先用一個 for 迴圈，去尋訪一次當前節點有的所有連接節點。如果當前節點的連接只有 1，代表只和根節點有連接，因此不必浪費時間檢查。\nfor (auto node : dict[now]) &#123;    if (dictCnt[node] == 1) &#123;        continue;    &#125;    .    .    .\n\n如果當前節點的子節點為根節點，則跳過，反之其他都要往下尋找，如果當前深度已經大於目前最低深度了，則可提前跳出。\nif (node != last) &#123;    depth = max(depth, maxDepth(now, node, ansDepth));    if (ansDepth &lt; depth) &#123;        return depth + 1;    &#125;&#125;\n\n最後回傳深度，只當前節點(1)加上當前節點的深度(depth)。\nreturn 1 + depth;\n\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; dict;    vector&lt;int&gt; dictCnt;    int maxDepth(int last, int now, int ansDepth) &#123;        int depth = 0;        for (auto node : dict[now]) &#123;            if (dictCnt[node] == 1) &#123;                continue;            &#125;            if (node != last) &#123;                depth = max(depth, maxDepth(now, node, ansDepth));                if (ansDepth &lt; depth) &#123;                    return depth + 1;                &#125;            &#125;        &#125;        return 1 + depth;    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if(edges.size()==1)&#123;            return edges[0];        &#125;        dict.resize(n);        dictCnt.resize(n);        for (auto edge : edges) &#123;            dict[edge[0]].push_back(edge[1]);            dict[edge[1]].push_back(edge[0]);            dictCnt[edge[0]]++;            dictCnt[edge[1]]++;        &#125;        int minDepth = INT_MAX, ansDepth = INT_MAX, depth;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; i++) &#123;            depth = 1;            if (dictCnt[i] == 1) &#123;                continue;            &#125;            for (auto now : dict[i]) &#123;                depth = max(depth, maxDepth(i, now, ansDepth));                if (depth &gt; ansDepth) &#123;                    break;                &#125;            &#125;            if (depth == ansDepth) &#123;                ans.push_back(i);            &#125; else if (depth &lt; ansDepth) &#123;                ansDepth = depth;                ans = &#123;i&#125;;            &#125;        &#125;        return ans;    &#125;&#125;;\n\nSolution 1Main function上述方法會超時，因為你從根節點出發，你無法得知多久會到子節點，因此另外一個想法為從子節點出發到根節點。\n先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    tree[edge[0]].push_back(edge[1]);    tree[edge[1]].push_back(edge[0]);    treeCnt[edge[0]]++;    treeCnt[edge[1]]++;&#125;\n\n透過紀錄節點連接數量的 vector，找尋連接只有 1 的節點，因為這些節點只有與他們的根節點連接，因此連接數只有 1。\n端節點：只連結數只有 1 個末端節點這裡的 leafs 則是用做記錄所有端節點\nvector&lt;int&gt; leafs;for (int i = 0; i &lt; treeCnt.size(); i++) &#123;    if (treeCnt[i] == 1) &#123;        treeCnt[i]--;        leafs.push_back(i);    &#125;&#125;\n\nRecursion遞迴的概念是要將每次的端節點拔除後，如果他的根節點變為端節點，則在下一輪拔除，拔到最後一層節點沒根節點後，則他們都是根節點。參數有一個：當前的端節點\n首先先尋訪與當前端節點有連接的節點，如果當前節點的連接數不為 0，代表還有連接，則需進一步執行。\nfor (auto leaf : leafs) &#123;    for (auto node : tree[leaf]) &#123;        if (treeCnt[node] != 0) &#123;            ...        &#125;    &#125;&#125;\n\n接下來就是要在當前節點的數量減一，把當前節點與端節點拔除。當此時當前節點變為 1 時，代表他又只與一個根節點連接，因此把它作為新的端節點。\nif (treeCnt[node] != 0) &#123;    treeCnt[node]--;    if (treeCnt[node] == 1) &#123;        newLeafs.push_back(node);    &#125;&#125;\n\n最後，如果沒有新的端節點產生，則代表已經到了最後一層了，因此剩餘的都是最後一層根節點，也就是答案。如果還有新的端節點，則需在往下檢查下一層的節點。\nif (newLeafs.size() == 0) &#123;    return leafs;&#125;return maxDepth(newLeafs);\n\nConclusion第二個方法能通，是因為不是去檢查該節點是不是根節點，而是把不是根節點的拔一拔後，剩餘的就是根節點。一次拔除多個端節點，可以有效地降低相同節點被尋訪的次數，讓整體時間降低。\n方法一的遞迴是每個節點到下一個節點，因此遞迴數量很大。\n方法二的遞迴是每層的端節點到下一層，每次遞迴可以檢查多的節點，而且理論上越接近根節點分支就會變少，可以大幅降低遞迴數量。\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; tree;    vector&lt;int&gt; treeCnt;    vector&lt;int&gt; maxDepth(vector&lt;int&gt; leafs) &#123;        vector&lt;int&gt; newLeafs;        for (auto leaf : leafs) &#123;            for (auto node : tree[leaf]) &#123;                if (treeCnt[node] != 0) &#123;                    treeCnt[node]--;                    if (treeCnt[node] == 1) &#123;                        newLeafs.push_back(node);                    &#125;                &#125;            &#125;        &#125;        if (newLeafs.size() == 0) &#123;            return leafs;        &#125;        return maxDepth(newLeafs);    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if (n == 1) &#123;            return &#123;0&#125;;        &#125;        tree.resize(n);        treeCnt.resize(n);        for (auto edge : edges) &#123;            tree[edge[0]].push_back(edge[1]);            tree[edge[1]].push_back(edge[0]);            treeCnt[edge[0]]++;            treeCnt[edge[1]]++;        &#125;        vector&lt;int&gt; leafs;        for (int i = 0; i &lt; treeCnt.size(); i++) &#123;            if (treeCnt[i] == 1) &#123;                treeCnt[i]--;                leafs.push_back(i);            &#125;        &#125;        return maxDepth(leafs);    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 319. Bulb Switcher","url":"/2024/04/23/LeetCode-Writeup/LeetCode-Writeup-319-Bulb-Switcher/","content":"319. Bulb Switcher這題還蠻有趣的，有三個接續的概念，兩個可過的解法\nIdea 1 TLE換個問題問，是否有辦法知道每個燈泡會在何時開關開關次數是奇數最後會亮，偶數會暗，因此只要知道該燈泡是奇數次就可以知道最後是亮著了。\n那怎麼知道每顆燈在何時會開關？第 6 顆燈泡為例，開關的時間點會在 1, 2, 3, 6 次觸發，偶數次是暗第 10 顆燈泡為例，開關的時間點會在 1, 2, 5, 10 次觸發，偶數次是暗第 36 顆燈泡為例，開關的時間點會在 1, 2, 3, 4, 6, 9, 12, 18, 36 次觸發，奇數次是亮\n數感好的話，應該會發現第 n 顆燈泡會開關的時間點會是在 n 的”因數”時進行開關。換句話說只要知道每個數字是奇數還是偶數就可以知道最後是亮還是暗了。\nFull codebool factorIsOdd(int n)&#123;    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        cnt+=(n%i==0);    &#125;    return cnt%2==1;&#125;int bulbSwitch(int n) &#123;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=factorIsOdd(i);    &#125;    return ans;&#125;\n\nSolution 1方法一概念是正確的，但寫完會發現，TLE…，題目給的 n 太大了。回到剛剛的因數分解。6 的因數有 1, 2, 3, 6，4 個8 的因數有 1, 2, 4, 8，4 個36 的因數有 1, 2, 3, 4, 6, 9, 12, 18, 36，9 個\n有沒有辦法取得”奇數個因數”的數，所有的因數分解中，數字一定是成雙成對的，以 48 為例1x48、2x24、3x16、4x12 …etc\n那有沒有數字的因數中有成雙成對，但數量又是奇數的？數感好的話，應該會發現”平方數”的因數數量是奇數，以 16 為例。1x16、2x8、”4x4”因為平方數開根號的數就是自己 x 自己，平方數因數量就會是奇數了（偶數組合與根號數）\nFull codeint bulbSwitch(int n) &#123;    int ans=0,root;    for(int i=1;i&lt;=n;i++)&#123;        root=sqrt(i);        ans+=(i==root*root);    &#125;    return ans;&#125;\n\nSolution 2方法二概念正確，但會發現你的執行速度不是 Beat100%\n想要追求極致的話，是否有方法比 O(n)還快？是否能透過計算取得 n 內的所有平方數數量？\nn&#x3D;16 時，有 1, 4, 9, 16，四個n&#x3D;17 時，有 1, 4, 9, 16，四個…n&#x3D;24 時，有 1, 4, 9, 16，四個n&#x3D;25 時，有 1, 4, 9, 16, 25，五個\n數感好的話，應該會發現，n&#x3D;16~24 都是四個，n&#x3D;25 才是五個，如果用開根號來計算的話：n&#x3D;16 時，sqrt(n) &#x3D; 4n&#x3D;17 時，sqrt(n) &#x3D; 4.12…n&#x3D;24 時，sqrt(n) &#x3D; 4.89n&#x3D;25 時，sqrt(n) &#x3D; 5\n因此只要對 n 直接開根號的話，就可以取得該數內的平方數了，又因為 funtion 的回傳型態是整數，更不用擔心被小數影響結果。\nFull codeint bulbSwitch(int n) &#123;    return sqrt(n);&#125;\n","categories":["LeetCode","LeetCode-Writeup"]}]