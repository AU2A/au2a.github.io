[{"title":"Docker Tutorial","url":"/2024/05/02/Docker-Tutorial/","content":"ContainerContainer statusdocker psdocker ps -q # Only get running Container ID\n\nRun containerdocker run --name=&#123;NAME&#125; \\  # Container name            -d \\            # Running in the background            -e &#123;PARAM-NAME&#125;=&#123;PARAM-VALUE&#125; \\    # Parameters            -v &#123;OUTSIDE-PATH&#125;:&#123;INSIDE-PATH&#125; \\  # Volume PATH            -p &#123;OUTSIDE-PORT&#125;:&#123;INSIDE-PORT&#125; \\  # Port forwarding            &#123;REPOSITORY/IMAGE-Name&#125;\n\nStart containerdocker start &#123;CONTAINER-ID/NAMES&#125;\n\nStop containerdocker stop &#123;CONTAINER-ID/NAMES&#125;\n\nControl containerdocker exec -it &#123;CONTAINER-ID/NAMES&#125; bash\n\nRemove containerdocker rm &#123;CONTAINER-ID/NAMES&#125;\n\nContainer logsdocker logs &#123;CONTAINER-ID/NAMES&#125;\n\nimagesImages listdocker image ls\n\nRemove imagedocker image rm &#123;REPOSITORY&#125;\n\nBuild imagedocker build -t &#123;IMAGE-Name&#125; &#123;PATH&#125;\n\nPush imagedocker push &#123;IMAGE-Name&#125;\n\nWith GithubLogin ghcr.io with docker on terminal\nGet a “personal access token (classic)” from Developer Page\n\nlogin by terminal\n\n\nexport CR_PAT=ghp_xxxxxecho $CR_PAT | docker login ghcr.io -u &#123;Github ID&#125; --password-stdin\n","categories":["Docker"]},{"title":"Github Tutorial","url":"/2023/12/02/Github-Tutorial/","content":"BasicClone a repogit clone &#123;url.git&#125;\n\nAdd some filesgit add &#123;filename&#125;\n\nGet commit historygit log\n\nCommitgit commit -m &quot;text&quot;\n\nPullgit pull\n\nPushgit push &#123;branch-name&#125;\n\nBranchGet now branch and all branch listgit branch\n\nCreate branchgit branch &#123;branch-name&#125;\n\nBranch Naming Examplegit branch feat/&#123;id&#125;-xxx   # add new featuregit branch fix/&#123;id&#125;-xxx    # fix some bugsgit branch refactor/&#123;id&#125;-xxx # Refactor the codegit branch docs/&#123;id&#125;-xxx   # Update Filesgit branch style/&#123;id&#125;-xxx  # Coding style, formattergit branch chore/&#123;id&#125;-xxx  # Change working process, tools ...etc\n\nSwitch branchgit switch &#123;branch-name&#125;git switch -c &#123;branch-name&#125; # if branch not exist, auto create\n\nMerge branchgit switch &#123;Target-branch-name&#125;git merge &#123;branch-name&#125;git push origin &#123;Target-branch-name&#125;\n\ncheckoutcheck commit and filesgit checkout &#123;commit-id&#125;git checkout &#123;commit-id&#125; -- &#123;file-path&#125;git checkout main\n\nWith DockerLogin ghcr.io with docker on terminal\nGet a “personal access token (classic)” from Developer Page\n\nlogin by terminal\n\n\nexport CR_PAT=ghp_xxxxxecho $CR_PAT | docker login ghcr.io -u &#123;Github ID&#125; --password-stdin\n","categories":["GitHub"]},{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用 Docker 時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -e port1=5001 -e port2=5002 \\        -p 5001:443 -p 5002:5002 au2a/hakka-website\n\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址port1為外部的網頁 portport2為外部的解碼用 port\n-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\n\nwhisper 解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每 90 天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n\n安裝 cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n\n如果要獨立裝 driver，就把 driver 取消\ndriversudo apt-get install nvidia-driver-470\n\nHuggingface 金鑰申請請到huggingface 官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n\n登入 hugging face將訓練完成的模型上傳到存放在 huggingface，可以減少本地端空間占用。Token請自行去 huggingface 申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n\n載入 Openai 建立好的模型使用 openai 提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n\n語料轉換取樣率音檔取樣率轉換成 16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\n\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\n\ncompute_metrics計算 CER(或 WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\n\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\n\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\n\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n\n開始訓練trainer.train()\n\n從本地上傳模型到 HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,    &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n\n從 HuggingFace 下載模型你需要更改要下載 model 的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning Script by FSR2023","url":"/2023/08/28/Openai-Whisper-Fine-Tuning-Script-by-FSR2023/","content":"連結Github\n重點專案結構whisper-hakka ┗┳━ custom_data  ┃   ┗━ data_prep.py 資料檢查、產生binary檔案  ┣━ data-char 放字單位的文本  ┃   ┣━ dev  ┃   ┃   ┣━ audio_paths symbolic link to wav.scp  ┃   ┃   ┣━ spk2utt 語者ID與其語料ID  ┃   ┃   ┣━ text    語料ID與語料文本  ┃   ┃   ┣━ utt2spk 語料ID與其語者ID  ┃   ┃   ┗━ wav.scp 語料ID與語料路徑  ┃   ┣━ test  ┃   ┃   ┗━ 同(dev)  ┃   ┗━ train  ┃       ┗━ 同(dev)  ┣━ data-pinyin 放詞單位的文本  ┃   ┗━ 同(data-char)  ┣━ evaluate  ┃   ┗━ evaluate_on_custom_dataset.py 驗證腳本  ┣━ train  ┃   ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本  ┃   ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本  ┣━ requirements.txt library套件  ┗━ run.sh 所有會執行的指令\n\n安裝虛擬環境建議用虛擬環境 virtual environment 建置 python 環境，可以避免原始套件衝突。\n# 建立虛擬環境# python3 -m venv name-of-venvpython3 -m venv env# 啟動虛擬環境source env/bin/activate\n\n當成功使用虛擬環境時，命令列左側會顯示在虛擬環境中。\n# beforeuser@SERVER:/path-to-project$# after(env) user@SERVER:/path-to-project$\n\n安裝 Python 套件python3 -m pip install --upgrade pippip install -r requirements.txt\n\n資料準備接著進行資料準備，所有集合都放在data-char底下，一個資料夾為一個集合。需準備的資料有：text\nID_1 text-in-ID_1ID_2 text-in-ID_2ID_3 text-in-ID_3\n\nwav.scp\nID_1 path-to-ID_1ID_2 path-to-ID_2ID_3 path-to-ID_3\n\n建議data-char放中文字的 text(字為單位)，data-pinyin放英文字的 text(詞為單位)。\n接下來可以使用run.sh內的指令進行驗證，執行後會在output_data_dir的地方放生成後的 binary 檔案。\npython3 custom_data/data_prep.py \\--source_data_dir path-to-your-location \\--output_data_dir path-to-your-data-locationEx:python3 custom_data/data_prep.py \\--source_data_dir data-pinyin/train \\--output_data_dir output_data-pinyin/train\n\n如果輸出Data preparation done代表沒問題，可以進行下一步。\n開始訓練資料準備完成後，即可進行訓練，可以執行以下指令(以字元為例)nproc_per_node為 GPU 數量\ntorchrun --nproc_per_node=1 train/fine-tune_on_custom_dataset.py \\--model_name openai/whisper-base \\  # 基礎模型--language zh \\ # 調適的語言--sampling_rate 16000 \\    # 取樣率--num_proc 4 \\             # 同時只用多少CPU核心執行取樣轉換，越快越好--train_strategy epoch \\   # 訓練週期單位(epoch/steps)--learning_rate 6.25e-6 \\  # 學習率--warmup 1000 \\--train_batchsize 12 \\  # 訓練batch--eval_batchsize 6 \\    # 驗證batch--num_epochs 20 \\       # 訓練週期數--resume_from_ckpt None \\--output_dir op_dir_epoch-char \\           # 輸出路徑資料夾名，記得修改，不然容易忘記--train_datasets output_data-char/train  \\ # 訓練集路徑--eval_datasets output_data-char/dev       # 驗證集路徑\n\n完成訓練後，可以透過終端上每個checkpoint的 WER 去評估哪個模型比較好。\n訓練好的模型資料結構(僅說明重點)以預設名op_dir_epoch-char舉例\nwhisper-hakka ┗━━ op_dir_epoch-char      ┣━ checkpoint-(num)      ┃   ┣━ config.json 參數檔      ┃   ┗━ pytorch_model.bin 模型      ┣━ 每個checkpoint資料夾內的檔案      ┗━ README.md 訓練狀態\n\n測試選擇好最好的 checkpoint 後，就可以進行測試看看該模型效果如何，通常 checkpoint 前 3 名都有機會有好的結果，不一定會是 checkpoint 最好的為最好模型。\npython3 evaluate/evaluate_on_custom_dataset.py \\--is_public_repo False \\--ckpt_dir &quot;op_dir_epoch-char/checkpoint&quot; \\  # checkpoint路徑--temp_ckpt_folder &quot;temp-char&quot; \\         # 暫存位置--language zh \\                          # 語言--eval_datasets output_data-char/test \\  # 測試集路徑--device 0 \\--batch_size 8 \\                   # 測試batch--output_dir predictions_dir-char  # 測試後輸出檔案\n\n測試後即可跟去輸出的 WER(詞錯誤率)與 CER(字錯誤率)去選擇最好的模型。\n輸出模型此腳本並無提供模型輸出的指令，可以使用以下我寫的程式碼：\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;path-to-checkpoint&#x27;whisper_checkpoint_path = &#x27;model-name.pt&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\n此方法生成的模型可以使用在 python 的 whisper 套件。\n","categories":["HakkaASR"]},{"title":"LeetCode 2023/07","url":"/2023/07/03/LeetCode/LeetCode-2023-07/","content":"Week11232. Check If It Is a Straight LineLeetcode Link My Solution\n1071. Greatest Common Divisor of StringsLeetcode Link My Solution\n1160. Find Words That Can Be Formed by CharactersLeetcode Link My Solution\n1323. Maximum 69 NumberLeetcode Link My Solution\n858. Mirror ReflectionLeetcode Link My Solution\n946. Validate Stack SequencesLeetcode Link My Solution\n2748. Number of Beautiful PairsLeetcode Link My Solution\n2750. Ways to Split Array Into Good SubarraysLeetcode Link My Solution\nWeek22418. Sort the PeopleLeetcode Link My Solution\n2437. Number of Valid Clock TimesLeetcode Link My Solution\n2383. Minimum Hours of Training to Win a CompetitionLeetcode Link My Solution\n2363. Merge Similar ItemsLeetcode Link My Solution\n2461. Maximum Sum of Distinct Subarrays With Length KLeetcode Link My Solution\n2419. Longest Subarray With Maximum Bitwise ANDLeetcode Link My Solution\n2760. Longest Even Odd Subarray With ThresholdLeetcode Link My Solution\n2761. Prime Pairs With Target SumLeetcode Link My Solution\nWeek3557. Reverse Words in a String IIILeetcode Link My Solution\n345. Reverse Vowels of a StringLeetcode Link My Solution\n463. Island PerimeterLeetcode Link My Solution\n160. Intersection of Two Linked ListsLeetcode Link My Solution\n6. Zigzag ConversionLeetcode Link My Solution\n1366. Rank Teams by VotesLeetcode Link My Solution\n2769. Find the Maximum Achievable NumberLeetcode Link My Solution\n6899. Maximum Number of Jumps to Reach the Last IndexLeetcode Link My Solution\n6912. Longest Non-decreasing Subarray From Two ArraysLeetcode Link My Solution\nWeek42656. Maximum Sum With Exactly K ElementsLeetcode Link My Solution\n2475. Number of Unequal Triplets in ArrayLeetcode Link My Solution\n2558. Take Gifts From the Richest PileLeetcode Link My Solution\n2278. Percentage of Letter in StringLeetcode Link My Solution\n275. H-Index IILeetcode Link My Solution\n227. Basic Calculator IILeetcode Link My Solution\n2778. Sum of Squares of Special ElementsLeetcode Link My Solution\n2779. Maximum Beauty of an Array After Applying OperationLeetcode Link My Solution\n2780. Minimum Index of a Valid SplitLeetcode Link My Solution\nWeek41394. Find Lucky Integer in an ArrayLeetcode Link My Solution\n1332. Remove Palindromic SubsequencesLeetcode Link My Solution\n1281. Subtract the Product and Sum of Digits of an IntegerLeetcode Link My Solution\n1013. Partition Array Into Three Parts With Equal SumLeetcode Link My Solution\n2249. Count Lattice Points Inside a CircleLeetcode Link My Solution\n2256. Minimum Average DifferenceLeetcode Link My Solution\n2788. Split Strings by SeparatorLeetcode Link My Solution\n2789. Largest Element in an Array after Merge OperationsLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/08","url":"/2023/08/14/LeetCode/LeetCode-2023-08/","content":"Week1108. Convert Sorted Array to Binary Search TreeLeetcode Link My Solution\n303. Range Sum Query - ImmutableLeetcode Link My Solution\n202. Happy NumberLeetcode Link My Solution\n232. Implement Queue using StacksLeetcode Link My Solution\n2162. Minimum Cost to Set Cooking TimeLeetcode Link My Solution\n2810. Faulty KeyboardLeetcode Link My Solution\n2811. Check if it is Possible to Split ArrayLeetcode Link My Solution\n2812. Find the Safest Path in a GridLeetcode Link My Solution\n2813. Maximum Elegance of a K-Length SubsequenceLeetcode Link My Solution\nWeek22441. Largest Positive Integer That Exists With Its NegativeLeetcode Link My Solution\n2520. Count the Digits That Divide a NumberLeetcode Link My Solution\n2299. Strong Password Checker IILeetcode Link My Solution\n2423. Remove Letter To Equalize FrequencyLeetcode Link My Solution\n957. Prison Cells After N DaysLeetcode Link My Solution\n900. RLE IteratorLeetcode Link My Solution\n2815. Max Pair Sum in an ArrayLeetcode Link My Solution\n2816. Double a Number Represented as a Linked ListLeetcode Link My Solution\nWeek31929. Concatenation of ArrayLeetcode Link My Solution\n1886. Determine Whether Matrix Can Be Obtained By RotationLeetcode Link My Solution\n1752. Check if Array Is Sorted and RotatedLeetcode Link My Solution\n1518. Water BottlesLeetcode Link My Solution\n57. Insert IntervalLeetcode Link My Solution\n229. Majority Element IILeetcode Link My Solution\n2828. Check if a String Is an Acronym of WordsLeetcode Link My Solution\n2829. Determine the Minimum Sum of a k-avoiding ArrayLeetcode Link My Solution\n2831. Find the Longest Equal SubarrayLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/11","url":"/2023/11/05/LeetCode/LeetCode-2023-11/","content":"Week11768. Merge Strings AlternatelyLeetcode Link My Solution\n1071. Greatest Common Divisor of StringsLeetcode Link My Solution\n1431. Kids With the Greatest Number of CandiesLeetcode Link My Solution\n605. Can Place FlowersLeetcode Link My Solution\n345. Reverse Vowels of a StringLeetcode Link My Solution\n151. Reverse Words in a StringLeetcode Link My Solution\n2917. Find the K-or of an ArrayLeetcode Link My Solution\n2918. Minimum Equal Sum of Two Arrays After Replacing ZerosLeetcode Link My Solution\nWeek2283. Move ZeroesLeetcode Link My Solution\n392. Is SubsequenceLeetcode Link My Solution\n643. Maximum Average Subarray ILeetcode Link My Solution\n1732. Find the Highest AltitudeLeetcode Link My Solution\n724. Find Pivot IndexLeetcode Link My Solution\n238. Product of Array Except SelfLeetcode Link My Solution\n2923. Find Champion ILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/03","url":"/2024/03/10/LeetCode/LeetCode-2024-03/","content":"Week11750. Minimum Length of String After Deleting Similar EndsLeetcode Link My Solution\n876. Middle of the Linked ListLeetcode Link My Solution\n141. Linked List CycleLeetcode Link My Solution\n3005. Count Elements With Maximum FrequencyLeetcode Link My Solution\n1768. Merge Strings AlternatelyLeetcode Link My Solution\n2540. Minimum Common ValueLeetcode Link My Solution\n3074. Apple Redistribution into BoxesLeetcode Link My Solution\n3075. Maximize Happiness of Selected ChildrenLeetcode Link My Solution\n3076. Shortest Uncommon Substring in an ArrayLeetcode Link My Solution\n349. Intersection of Two ArraysLeetcode Link My Solution\nWeek2791. Custom Sort StringLeetcode Link My Solution\n238. Product of Array Except SelfLeetcode Link My Solution\nWeek3452. Minimum Number of Arrows to Burst BalloonsLeetcode Link My Solution\n1669. Merge In Between Linked ListsLeetcode Link My Solution\n206. Reverse Linked ListLeetcode Link My Solution\n143. Reorder ListLeetcode Link My Solution\n287. Find the Duplicate NumberLeetcode Link My Solution\n442. Find All Duplicates in an ArrayLeetcode Link My Solution\nWeek441. First Missing PositiveLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/09","url":"/2023/09/12/LeetCode/LeetCode-2023-09/","content":"Week12341. Maximum Number of Pairs in ArrayLeetcode Link My Solution\n2331. Evaluate Boolean Binary TreeLeetcode Link My Solution\n2500. Delete Greatest Value in Each RowLeetcode Link My Solution\n2744. Find Maximum Number of String PairsLeetcode Link My Solution\n2833. Furthest Point From OriginLeetcode Link My Solution\n2834. Find the Minimum Possible Sum of a Beautiful ArrayLeetcode Link My Solution\nWeek2404. Sum of Left LeavesLeetcode Link My Solution\n263. Ugly NumberLeetcode Link My Solution\n448. Find All Numbers Disappeared in an ArrayLeetcode Link My Solution\n653. Two Sum IV - Input is a BSTLeetcode Link My Solution\n1010. Pairs of Songs With Total Durations Divisible by 60Leetcode Link My Solution\n2848. Points That Intersect With CarsLeetcode Link My Solution\n2849. Determine if a Cell Is Reachable at a Given TimeLeetcode Link My Solution\nWeek31078. Occurrences After BigramLeetcode Link My Solution\n2582. Pass the PillowLeetcode Link My Solution\n2586. Count the Number of Vowel Strings in RangeLeetcode Link My Solution\n2855. Minimum Right Shifts to Sort the ArrayLeetcode Link My Solution\n240. Search a 2D Matrix IILeetcode Link My Solution\n2859. Sum of Values at Indices With K Set BitsLeetcode Link My Solution\n2860. Happy StudentsLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2023/10","url":"/2023/10/15/LeetCode/LeetCode-2023-10/","content":"Week12413. Smallest Even MultipleLeetcode Link My Solution\n2409. Count Days Spent TogetherLeetcode Link My Solution\n2455. Average Value of Even Numbers That Are Divisible by ThreeLeetcode Link My Solution\n2485. Find the Pivot IntegerLeetcode Link My Solution\n2465. Number of Distinct AveragesLeetcode Link My Solution\n2264. Largest 3-Same-Digit Number in StringLeetcode Link My Solution\n2367. Number of Arithmetic TripletsLeetcode Link My Solution\n2395. Find Subarrays With Equal SumLeetcode Link My Solution\n2605. Form Smallest Number From Two Digit ArraysLeetcode Link My Solution\n2843. Count Symmetric IntegersLeetcode Link My Solution\n50. pow(x, n)Leetcode Link My Solution\n260. Single Number IIILeetcode Link My Solution\n309. Best Time to Buy and Sell Stock with CooldownLeetcode Link My Solution\n2873. Maximum Value of an Ordered Triplet ILeetcode Link My Solution\n2875. Minimum Size Subarray in Infinite ArrayLeetcode Link My Solution\n2894. Divisible and Non-divisible Sums DifferenceLeetcode Link My Solution\n2895. Minimum Processing TimeLeetcode Link My Solution\nWeek22469. Convert the TemperatureLeetcode Link My Solution\n2432. The Employee That Worked on the Longest TaskLeetcode Link My Solution\n2578. Split With Minimum SumLeetcode Link My Solution\n2481. Minimum Cuts to Divide a CircleLeetcode Link My Solution\n2639. Find the Width of Columns of a GridLeetcode Link My Solution\n1093. Statistics from a Large SampleLeetcode Link My Solution\n2903. Find Indices With Index and Value Difference ILeetcode Link My Solution\n2904. Shortest and Lexicographically Smallest Beautiful StringLeetcode Link My Solution\n2905. Find Indices With Index and Value Difference IILeetcode Link My Solution\n2906. Construct Product MatrixLeetcode Link My Solution\nWeek32000. Reverse Prefix of WordLeetcode Link My Solution\n2287. Rearrange Characters to Make Target StringLeetcode Link My Solution\n1848. Minimum Distance to the Target ElementLeetcode Link My Solution\n2562. Find the Array Concatenation ValueLeetcode Link My Solution\n2108. Find First Palindromic String in the ArrayLeetcode Link My Solution\n1315. Sum of Nodes with Even-Valued GrandparentLeetcode Link My Solution\n2908. Minimum Sum of Mountain Triplets ILeetcode Link My Solution\n2909. Minimum Sum of Mountain Triplets IILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/05 W1","url":"/2024/05/02/LeetCode/LeetCode-2024-05-W1/","content":"Week12997. Minimum Number of Operations to Make Array XOR Equal to KLeetcode Link My Solution\n2000. Reverse Prefix of WordLeetcode Link My Solution\n2441. Largest Positive Integer That Exists With Its NegativeLeetcode Link My Solution\n7. Reverse IntegerLeetcode Link My Solution\n8. String to Integer (atoi)Leetcode Link My Solution\n165. Compare Version NumbersLeetcode Link My Solution\n39. Combination SumLeetcode Link My Solution\n881. Boats to Save PeopleLeetcode Link My Solution\n374. Guess Number Higher or LowerLeetcode Link My Solution\n1137. N-th Tribonacci NumberLeetcode Link My Solution\n3136. Valid WordLeetcode Link My Solution\n3137. Minimum Number of Operations to Make Word K-PeriodicLeetcode Link My Solution\n3138. Minimum Length of Anagram ConcatenationLeetcode Link My Solution\n237. Delete Node in a Linked ListLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode 2024/04","url":"/2024/04/07/LeetCode/LeetCode-2024-04/","content":"Week1205. Isomorphic StringsLeetcode Link My Solution\n1544. Make The String GreatLeetcode Link My Solution\n1249. Minimum Remove to Make Valid ParenthesesLeetcode Link My Solution\nWeek2771. Jewels and StonesLeetcode Link My Solution\n42. Trapping Rain WaterLeetcode Link My Solution\n404. Sum of Left LeavesLeetcode Link My Solution\n3114. Latest Time You Can Obtain After Replacing CharactersLeetcode Link My Solution\n3115. Maximum Prime DifferenceLeetcode Link My Solution\nWeek3129. Sum Root to Leaf NumbersLeetcode Link My Solution\n334. Increasing Triplet SubsequenceLeetcode Link My Solution\n623. Add One Row to TreeLeetcode Link My Solution\n1732. Find the Highest AltitudeLeetcode Link My Solution\n1207. Unique Number of OccurrencesLeetcode Link My Solution\n700. Search in a Binary Search TreeLeetcode Link My Solution\n988. Smallest String Starting From LeafLeetcode Link My Solution\n463. Island PerimeterLeetcode Link My Solution\n319. Bulb SwitcherLeetcode Link My Solution\n200. Number of IslandsLeetcode Link My Solution\n456. 132 PatternLeetcode Link My Solution\n1992. Find All Groups of FarmlandLeetcode Link My Solution\n3120. Count the Number of Special Characters ILeetcode Link My Solution\n3121. Count the Number of Special Characters IILeetcode Link My Solution\n139. Word BreakLeetcode Link My Solution\n137. Single Number IILeetcode Link My Solution\n1971. Find if Path Exists in GraphLeetcode Link My Solution\nWeek4310. Minimum Height TreesLeetcode Link My Solution\n1137. N-th Tribonacci NumberLeetcode Link My Solution\n2370. Longest Ideal SubsequenceLeetcode Link My Solution\n3131. Find the Integer Added to Array ILeetcode Link My Solution\n3132. Find the Integer Added to Array IILeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode-Writeup 2370. Longest Ideal Subsequence","url":"/2024/04/26/LeetCode-Writeup/LeetCode-Writeup-2370-Longest-Ideal-Subsequence/","content":"2370. Longest Ideal Subsequence這題是個基礎的 DP 題，很值得練習。\nIdea 1 TLE第一種方法，就是當前的字往前檢查可以接的字有哪些，選最高的。\nMain function第 n 個字時，會檢查 n-1 到 1 的字字串的長度\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    for(int j=i-1;j&gt;=0;j--)&#123;        ...    &#125;&#125;\n\n先檢查當前的字和前面的字距離有沒有小於等於 k，如果有才符合題目條件。\n有的話再檢查是否大於目前記錄到的長度。\nif(abs(s[i]-s[j])&lt;=k)&#123;    if(seq[j]&gt;temp)&#123;        temp=seq[j];    &#125;&#125;\n\n找到前面可以接續的最長長度後，加上自己把值存進自己位置的陣列，讓下一個字往前檢查時可以讀到。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\nseq[i]=temp+1;ans=max(ans,seq[i]);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0;        vector&lt;int&gt; seq(n);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(s[i]-s[j])&lt;=k)&#123;                    if(seq[j]&gt;temp)&#123;                        temp=seq[j];                    &#125;                &#125;            &#125;            seq[i]=temp+1;            ans=max(ans,seq[i]);        &#125;        return ans;    &#125;&#125;;\n\nSolution 1第一個方法好理解，但問題是每次往前檢查不知道要檢查到第幾個，因此都檢查到第一個，執行時間是 O(n^2)，雖然有用到 DP 的概念，但不怎麼有效率。\n如何有效的紀錄每個字的狀態？\n第二種方法，不同於紀錄字串每個位置的長度，而是用每個字母紀錄最長的長度。\n因為字元差需要在 k 之間，因此只需檢查當前字母+-k 的字母就可以，\n舉例像是字母 c，k=1，那只需檢查 abcdefgh 就行。\n檢查後將新的值放到 c 的位置，讓下一個字可以繼續更新。\nMain function每個字都還是要跑一遍，用nowWordIdx將當前的字轉換成數字 0 ~ 25\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    nowWordIdx=s[i]-&#x27;a&#x27;;    ...&#125;\n\n透過nowWordIdx，我僅需檢查 +-k 的字，但要注意nowWordIdx-k需大於 0，nowWordIdx+k需小於 25，避免超出範圍。\nfor(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;    if(cnt[j]&gt;temp)&#123;        temp=cnt[j];    &#125;&#125;\n\n當前的字找到最長的值後，加上自己後存在自己字母索引的地方，讓下一個字檢查時可以更新。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\ncnt[nowWordIdx]=temp+1;ans=max(ans,temp+1);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0,nowWordIdx;        vector&lt;int&gt; cnt(26,0);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            nowWordIdx=s[i]-&#x27;a&#x27;;            for(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;                if(cnt[j]&gt;temp)&#123;                    temp=cnt[j];                &#125;            &#125;            cnt[nowWordIdx]=temp+1;            ans=max(ans,temp+1);        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 2441. Largest Positive Integer That Exists With Its Negative","url":"/2024/05/02/LeetCode-Writeup/LeetCode-Writeup-2441-Largest-Positive-Integer-That-Exists-With-Its-Negative/","content":"2441. Largest Positive Integer That Exists With Its NegativeSolution 1檢查數值，如果是正數+1，如果是負數+2，當數值剛好為 3 時代表正數與負數都有出現，正數負數都只會加一次。\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        int table[1001] = &#123;0&#125;;        int ans = -1;        for (auto num : nums) &#123;            if (num &gt; 0) &#123;                if (table[num] == 0 || table[num] == 2) &#123;                    table[num] += 1;                &#125;            &#125; else &#123;                if (table[-num] == 0 || table[-num] == 1) &#123;                    table[-num] += 2;                &#125;            &#125;            cout &lt;&lt; table[abs(num)] &lt;&lt; endl;            if (table[abs(num)] == 3) &#123;                ans = max(ans, abs(num));            &#125;        &#125;        return ans;    &#125;&#125;;\n\nSolution 2將陣列用絕對值大小排序，再來就是從大到小檢查，找出最先出現第 i 數與第 i+1 數互為正負數。\nclass Solution &#123;   public:    static bool cmp(int a, int b) &#123;        if (abs(a) == abs(b)) &#123;            return a &gt; b;        &#125;        return abs(a) &gt; abs(b);    &#125;    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end(), cmp);        int n = nums.size();        for (int i = 0; i &lt; n - 1; i++) &#123;            if (nums[i] == -nums[i + 1]) &#123;                return nums[i];            &#125;        &#125;        return -1;    &#125;&#125;;\n\nSolution 3將陣列大到小排序，雙指標從兩側找出最先符合條件的數字\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;            if (nums[left] * -1 == nums[right]) &#123;                return nums[right];            &#125; else if (nums[left] * -1 &lt; nums[right]) &#123;                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return -1;    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 319. Bulb Switcher","url":"/2024/04/23/LeetCode-Writeup/LeetCode-Writeup-319-Bulb-Switcher/","content":"319. Bulb Switcher這題還蠻有趣的，有三個接續的概念，兩個可過的解法\nIdea 1 TLE換個問題問，是否有辦法知道每個燈泡會在何時開關開關次數是奇數最後會亮，偶數會暗，因此只要知道該燈泡是奇數次就可以知道最後是亮著了。\n那怎麼知道每顆燈在何時會開關？第 6 顆燈泡為例，開關的時間點會在 1, 2, 3, 6 次觸發，偶數次是暗第 10 顆燈泡為例，開關的時間點會在 1, 2, 5, 10 次觸發，偶數次是暗第 36 顆燈泡為例，開關的時間點會在 1, 2, 3, 4, 6, 9, 12, 18, 36 次觸發，奇數次是亮\n數感好的話，應該會發現第 n 顆燈泡會開關的時間點會是在 n 的”因數”時進行開關。換句話說只要知道每個數字是奇數還是偶數就可以知道最後是亮還是暗了。\nFull codebool factorIsOdd(int n)&#123;    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        cnt+=(n%i==0);    &#125;    return cnt%2==1;&#125;int bulbSwitch(int n) &#123;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=factorIsOdd(i);    &#125;    return ans;&#125;\n\nSolution 1方法一概念是正確的，但寫完會發現，TLE…，題目給的 n 太大了。回到剛剛的因數分解。6 的因數有 1, 2, 3, 6，4 個8 的因數有 1, 2, 4, 8，4 個36 的因數有 1, 2, 3, 4, 6, 9, 12, 18, 36，9 個\n有沒有辦法取得”奇數個因數”的數，所有的因數分解中，數字一定是成雙成對的，以 48 為例1x48、2x24、3x16、4x12 …etc\n那有沒有數字的因數中有成雙成對，但數量又是奇數的？數感好的話，應該會發現”平方數”的因數數量是奇數，以 16 為例。1x16、2x8、”4x4”因為平方數開根號的數就是自己 x 自己，平方數因數量就會是奇數了（偶數組合與根號數）\nFull codeint bulbSwitch(int n) &#123;    int ans=0,root;    for(int i=1;i&lt;=n;i++)&#123;        root=sqrt(i);        ans+=(i==root*root);    &#125;    return ans;&#125;\n\nSolution 2方法二概念正確，但會發現你的執行速度不是 Beat100%\n想要追求極致的話，是否有方法比 O(n)還快？是否能透過計算取得 n 內的所有平方數數量？\nn&#x3D;16 時，有 1, 4, 9, 16，四個n&#x3D;17 時，有 1, 4, 9, 16，四個…n&#x3D;24 時，有 1, 4, 9, 16，四個n&#x3D;25 時，有 1, 4, 9, 16, 25，五個\n數感好的話，應該會發現，n&#x3D;16~24 都是四個，n&#x3D;25 才是五個，如果用開根號來計算的話：n&#x3D;16 時，sqrt(n) &#x3D; 4n&#x3D;17 時，sqrt(n) &#x3D; 4.12…n&#x3D;24 時，sqrt(n) &#x3D; 4.89n&#x3D;25 時，sqrt(n) &#x3D; 5\n因此只要對 n 直接開根號的話，就可以取得該數內的平方數了，又因為 funtion 的回傳型態是整數，更不用擔心被小數影響結果。\nFull codeint bulbSwitch(int n) &#123;    return sqrt(n);&#125;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode 2024/05 W2","url":"/2024/05/12/LeetCode/LeetCode-2024-05-W2/","content":"Week22487. Remove Nodes From Linked ListLeetcode Link My Solution\n1004. Max Consecutive Ones IIILeetcode Link My Solution\n933. Number of Recent CallsLeetcode Link My Solution\n104. Maximum Depth of Binary TreeLeetcode Link My Solution\n374. Guess Number Higher or LowerLeetcode Link My Solution\n452. Minimum Number of Arrows to Burst BalloonsLeetcode Link My Solution\n1657. Determine if Two Strings Are CloseLeetcode Link My Solution\n2816. Double a Number Represented as a Linked ListLeetcode Link My Solution\n506. Relative RanksLeetcode Link My Solution\n3075. Maximize Happiness of Selected ChildrenLeetcode Link My Solution\n786. K-th Smallest Prime FractionLeetcode Link My Solution\n857. Minimum Cost to Hire K WorkersLeetcode Link My Solution\n872. Leaf-Similar TreesLeetcode Link My Solution\n790. Domino and Tromino TilingLeetcode Link My Solution\n2373. Largest Local Values in a MatrixLeetcode Link My Solution\n3146. Permutation Difference between Two StringsLeetcode Link My Solution\n3147. Taking Maximum Energy From the Mystic DungeonLeetcode Link My Solution\n3148. Maximum Difference Score in a GridLeetcode Link My Solution\n","categories":["LeetCode"]},{"title":"LeetCode-Writeup 310. Minimum Height Trees","url":"/2024/04/25/LeetCode-Writeup/LeetCode-Writeup-310-Minimum-Height-Trees/","content":"310. Minimum Height Trees這題問題不難，難在要如何在時間內完成。\nIdea 1 TLE 70&#x2F;71Main function先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    dict[edge[0]].push_back(edge[1]);    dict[edge[1]].push_back(edge[0]);    dictCnt[edge[0]]++;    dictCnt[edge[1]]++;&#125;\n\n再來就是從第 0 個節點開始，迴圈找跟第 0 個節點連結的節點後，用遞迴的方式往下尋找以第 0 個節點為首的最常深度，以下用第 0 個節點開始作為範例。如果當前節點連結數只有 1，代表他只和第 0 個節點有連接，因此不須往下檢查。\nif (dictCnt[i] == 1) &#123;    continue;&#125;\n\n如果有大於 1 的連接數，則可繼續往下，檢查第 0 個節點是否有更深的深度。depth 為當前節點所記錄的深度，ansDepth 為整體最短深度，當前節點深度已經大於記錄到的最短深度時，則代表一定不會是答案，則跳出了不需浪費時間檢查。\nfor (auto now : dict[i]) &#123;    depth = max(depth, maxDepth(i, now, ansDepth));    if (depth &gt; ansDepth) &#123;        break;    &#125;&#125;\n\n因為題目是要找出哪些節點做為根節點有最低深度，因此如果當前節點深度與目前最低深度的節點相同，則同為答案，如果小於最低深度，代表有更小深度的根節點，則最小深度要重新記錄。\nif (depth == ansDepth) &#123;    ans.push_back(i);&#125; else if (depth &lt; ansDepth) &#123;    ansDepth = depth;    ans = &#123;i&#125;;&#125;\n\nRecursion那我的要遞迴什麼?當找到子節點又有除了根節點以外的連結，則須往下檢查深度。參數有三個：根節點值、當前節點值、最低深度\n先用一個 for 迴圈，去尋訪一次當前節點有的所有連接節點。如果當前節點的連接只有 1，代表只和根節點有連接，因此不必浪費時間檢查。\nfor (auto node : dict[now]) &#123;    if (dictCnt[node] == 1) &#123;        continue;    &#125;    .    .    .\n\n如果當前節點的子節點為根節點，則跳過，反之其他都要往下尋找，如果當前深度已經大於目前最低深度了，則可提前跳出。\nif (node != last) &#123;    depth = max(depth, maxDepth(now, node, ansDepth));    if (ansDepth &lt; depth) &#123;        return depth + 1;    &#125;&#125;\n\n最後回傳深度，只當前節點(1)加上當前節點的深度(depth)。\nreturn 1 + depth;\n\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; dict;    vector&lt;int&gt; dictCnt;    int maxDepth(int last, int now, int ansDepth) &#123;        int depth = 0;        for (auto node : dict[now]) &#123;            if (dictCnt[node] == 1) &#123;                continue;            &#125;            if (node != last) &#123;                depth = max(depth, maxDepth(now, node, ansDepth));                if (ansDepth &lt; depth) &#123;                    return depth + 1;                &#125;            &#125;        &#125;        return 1 + depth;    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if(edges.size()==1)&#123;            return edges[0];        &#125;        dict.resize(n);        dictCnt.resize(n);        for (auto edge : edges) &#123;            dict[edge[0]].push_back(edge[1]);            dict[edge[1]].push_back(edge[0]);            dictCnt[edge[0]]++;            dictCnt[edge[1]]++;        &#125;        int minDepth = INT_MAX, ansDepth = INT_MAX, depth;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; i++) &#123;            depth = 1;            if (dictCnt[i] == 1) &#123;                continue;            &#125;            for (auto now : dict[i]) &#123;                depth = max(depth, maxDepth(i, now, ansDepth));                if (depth &gt; ansDepth) &#123;                    break;                &#125;            &#125;            if (depth == ansDepth) &#123;                ans.push_back(i);            &#125; else if (depth &lt; ansDepth) &#123;                ansDepth = depth;                ans = &#123;i&#125;;            &#125;        &#125;        return ans;    &#125;&#125;;\n\nSolution 1Main function上述方法會超時，因為你從根節點出發，你無法得知多久會到子節點，因此另外一個想法為從子節點出發到根節點。\n先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    tree[edge[0]].push_back(edge[1]);    tree[edge[1]].push_back(edge[0]);    treeCnt[edge[0]]++;    treeCnt[edge[1]]++;&#125;\n\n透過紀錄節點連接數量的 vector，找尋連接只有 1 的節點，因為這些節點只有與他們的根節點連接，因此連接數只有 1。\n端節點：只連結數只有 1 個末端節點這裡的 leafs 則是用做記錄所有端節點\nvector&lt;int&gt; leafs;for (int i = 0; i &lt; treeCnt.size(); i++) &#123;    if (treeCnt[i] == 1) &#123;        treeCnt[i]--;        leafs.push_back(i);    &#125;&#125;\n\nRecursion遞迴的概念是要將每次的端節點拔除後，如果他的根節點變為端節點，則在下一輪拔除，拔到最後一層節點沒根節點後，則他們都是根節點。參數有一個：當前的端節點\n首先先尋訪與當前端節點有連接的節點，如果當前節點的連接數不為 0，代表還有連接，則需進一步執行。\nfor (auto leaf : leafs) &#123;    for (auto node : tree[leaf]) &#123;        if (treeCnt[node] != 0) &#123;            ...        &#125;    &#125;&#125;\n\n接下來就是要在當前節點的數量減一，把當前節點與端節點拔除。當此時當前節點變為 1 時，代表他又只與一個根節點連接，因此把它作為新的端節點。\nif (treeCnt[node] != 0) &#123;    treeCnt[node]--;    if (treeCnt[node] == 1) &#123;        newLeafs.push_back(node);    &#125;&#125;\n\n最後，如果沒有新的端節點產生，則代表已經到了最後一層了，因此剩餘的都是最後一層根節點，也就是答案。如果還有新的端節點，則需在往下檢查下一層的節點。\nif (newLeafs.size() == 0) &#123;    return leafs;&#125;return maxDepth(newLeafs);\n\nConclusion第二個方法能通，是因為不是去檢查該節點是不是根節點，而是把不是根節點的拔一拔後，剩餘的就是根節點。一次拔除多個端節點，可以有效地降低相同節點被尋訪的次數，讓整體時間降低。\n方法一的遞迴是每個節點到下一個節點，因此遞迴數量很大。\n方法二的遞迴是每層的端節點到下一層，每次遞迴可以檢查多的節點，而且理論上越接近根節點分支就會變少，可以大幅降低遞迴數量。\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; tree;    vector&lt;int&gt; treeCnt;    vector&lt;int&gt; maxDepth(vector&lt;int&gt; leafs) &#123;        vector&lt;int&gt; newLeafs;        for (auto leaf : leafs) &#123;            for (auto node : tree[leaf]) &#123;                if (treeCnt[node] != 0) &#123;                    treeCnt[node]--;                    if (treeCnt[node] == 1) &#123;                        newLeafs.push_back(node);                    &#125;                &#125;            &#125;        &#125;        if (newLeafs.size() == 0) &#123;            return leafs;        &#125;        return maxDepth(newLeafs);    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if (n == 1) &#123;            return &#123;0&#125;;        &#125;        tree.resize(n);        treeCnt.resize(n);        for (auto edge : edges) &#123;            tree[edge[0]].push_back(edge[1]);            tree[edge[1]].push_back(edge[0]);            treeCnt[edge[0]]++;            treeCnt[edge[1]]++;        &#125;        vector&lt;int&gt; leafs;        for (int i = 0; i &lt; treeCnt.size(); i++) &#123;            if (treeCnt[i] == 1) &#123;                treeCnt[i]--;                leafs.push_back(i);            &#125;        &#125;        return maxDepth(leafs);    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]}]