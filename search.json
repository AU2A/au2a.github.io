[{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用Docker時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -e port1=5001 -e port2=5002 \\        -p 5001:443 -p 5002:5002 au2a/hakka-website\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址port1為外部的網頁portport2為外部的解碼用port\n-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\nwhisper解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每90天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n"},{"title":"LeetCode 2023/07/02","url":"/2023/07/03/LeetCode-2023-07-02/","content":"1232. Check If It Is a Straight Lineclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        int x1=coordinates[0][0],y1=coordinates[0][1];        int diffx=coordinates[1][0]-coordinates[0][0];        int diffy=coordinates[1][1]-coordinates[0][1];        for(auto c:coordinates)&#123;            if(diffx*(c[1]-y1)!=diffy*(c[0]-x1))&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n1071. Greatest Common Divisor of Stringsclass Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        string now,ans=&quot;&quot;,longString,shortString;        if(str1.size()&lt;str2.size())&#123;            longString=str2;            shortString=str1;        &#125;        else&#123;            longString=str1;            shortString=str2;        &#125;        bool chk;        for(auto c:shortString)&#123;            now+=c;            chk=true;            for(int i=0;i&lt;shortString.size();i+=now.size())&#123;                if(shortString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(shortString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            for(int i=0;i&lt;longString.size();i+=now.size())&#123;                if(longString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(longString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            if(chk&amp;&amp;longString.size()%now.size()==0&amp;&amp;shortString.size()%now.size()==0)&#123;                // cout&lt;&lt;now&lt;&lt;endl;                 ans=now;            &#125;            // cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n1160. Find Words That Can Be Formed by Charactersclass Solution &#123;public:    bool checkCount(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a[i]&lt;b[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;        int ans=0;        vector&lt;int&gt; target(26);        for(auto c:chars)&#123;            target[c-&#x27;a&#x27;]++;        &#125;        for(auto word:words)&#123;            vector&lt;int&gt; temp(26);            for(auto c:word)&#123;                temp[c-&#x27;a&#x27;]++;            &#125;            if(checkCount(target,temp))&#123;                ans+=word.size();            &#125;        &#125;        return ans;    &#125;&#125;;\n1323. Maximum 69 Numberclass Solution &#123;public:    int maximum69Number (int num) &#123;        int ans=num;        int temp=num;        for(int i=1;temp&gt;0;i++)&#123;            if(temp%10==6)&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+9*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;else&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+6*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n_858. Mirror Reflectionclass Solution &#123;public:    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int mirrorReflection(int p, int q) &#123;        int ap=p/gcd(p,q);        int aq=q/gcd(p,q);        if(ap==aq)&#123;            return 1;        &#125;        int sum=0,cnt=1;        while(aq*cnt%ap!=0)&#123;            cnt++;        &#125;        if(cnt%2==0)&#123;            return 2;        &#125;else if(aq%2==0)&#123;            return 0;        &#125;else&#123;            return 1;        &#125;        return 0;    &#125;&#125;;\n_946. Validate Stack Sequencesclass Solution &#123;public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;        stack&lt;int&gt; s;        int idxPush=0,idxPop=0,n=popped.size();        for(auto push_val:pushed)&#123;            s.push(push_val);            while(!s.empty()&amp;&amp;idxPop&lt;n)&#123;               if(s.top()==popped[idxPop])&#123;                   s.pop();                   idxPop++;               &#125;else&#123;                   break;               &#125;            &#125;        &#125;        return idxPop==n;    &#125;&#125;;\n2748. Number of Beautiful Pairsclass Solution &#123;public:    int first_digit(int a)&#123;        while(a&gt;=10)&#123;            a/=10;        &#125;        return a;    &#125;    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int countBeautifulPairs(vector&lt;int&gt;&amp; nums) &#123;        int ans=0;        int n=nums.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(gcd(first_digit(nums[i]),nums[j]%10)==1)&#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2750. Ways to Split Array Into Good Subarraysclass Solution &#123;public:    int numberOfGoodSubarraySplits(vector&lt;int&gt;&amp; nums) &#123;        int MOD=1e9+7;        int n=nums.size();        int temp=1;        long long int ans=1;        int i;        bool allz=true;        for(i=0;i&lt;n;i++)&#123;            if(nums[i]==1)&#123;                allz=false;                break;            &#125;        &#125;        if(allz)&#123;            return 0;        &#125;        for(i=i+1;i&lt;n;i++)&#123;            if(nums[i])&#123;                ans=(ans*temp)%MOD;                temp=1;            &#125;else&#123;                temp++;            &#125;        &#125;        return ans;    &#125;&#125;;"},{"title":"LeetCode 2023/07/09","url":"/2023/07/11/LeetCode-2023-07-09/","content":"2418. Sort the Peopleclass Solution &#123;public:    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123;        int n=names.size();        vector&lt;pair&lt;int,string&gt;&gt; temp(n);        for(int i=0;i&lt;n;i++)&#123;            temp[i]=&#123;heights[i],names[i]&#125;;        &#125;        sort(temp.begin(),temp.end());        vector&lt;string&gt; ans(n);        for(int i=0;i&lt;n;i++)&#123;            ans[n-i-1]=temp[i].second;        &#125;        return ans;    &#125;&#125;;\n2437. Number of Valid Clock Timesclass Solution &#123;public:    int countTime(string time) &#123;        int ans=1;        if(time[0]==&#x27;?&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=24;            &#125;else if(time[1]&gt;=&#x27;4&#x27;)&#123;                ans*=2;            &#125;else&#123;                ans*=3;            &#125;        &#125;else if(time[0]==&#x27;2&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=4;            &#125;        &#125;else&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=10;            &#125;        &#125;        if(time[3]==&#x27;?&#x27;)&#123;            ans*=6;        &#125;        if(time[4]==&#x27;?&#x27;)&#123;            ans*=10;        &#125;        return ans;    &#125;&#125;;\n2383. Minimum Hours of Training to Win a Competitionclass Solution &#123;public:    int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123;        int n=energy.size();        int time=0;        for(int i=0;i&lt;n;i++)&#123;            if(initialEnergy&gt;energy[i])&#123;                initialEnergy-=energy[i];            &#125;else&#123;                time+=energy[i]-initialEnergy+1;                initialEnergy=1;            &#125;            if(initialExperience&gt;experience[i])&#123;                initialExperience+=experience[i];            &#125;else&#123;                time+=experience[i]-initialExperience+1;                initialExperience=2*experience[i]+1;            &#125;        &#125;        return time;    &#125;&#125;;\n2363. Merge Similar Itemsclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123;        vector&lt;int&gt; temp(1001);        for(auto item:items1)&#123;            temp[item[0]]+=item[1];        &#125;        for(auto item:items2)&#123;            temp[item[0]]+=item[1];        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;1001;i++)&#123;            if(temp[i]!=0)&#123;                ans.push_back(&#123;i,temp[i]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;\n2461. Maximum Sum of Distinct Subarrays With Length Kclass Solution &#123;public:    long long maximumSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; cnt(1e5+1);        int chk=0,n=nums.size();        long long sum=0,ans=0;        for(int i=0;i&lt;k-1;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;            &#125;        &#125;        for(int i=k-1;i&lt;n;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;                if(chk==k)&#123;                    ans=max(ans,sum);                &#125;            &#125;            cnt[nums[i-k+1]]--;            sum-=nums[i-k+1];            if(cnt[nums[i-k+1]]==0)&#123;                chk--;            &#125;        &#125;        return ans;    &#125;&#125;;\n2419. Longest Subarray With Maximum Bitwise ANDclass Solution &#123;public:    int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;        int x=*max_element(nums.begin(),nums.end());        int n=nums.size();        int temp=1,ans=1;        for(int i=0;i&lt;n-1;i++)&#123;            if(nums[i]==nums[i+1]&amp;&amp;nums[i]==x)&#123;                temp++;                ans=max(ans,temp);            &#125;else&#123;                temp=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2760. Longest Even Odd Subarray With Thresholdclass Solution &#123;public:    int longestAlternatingSubarray(vector&lt;int&gt;&amp; nums, int threshold) &#123;        int ans=0,cnt=1,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]%2==0&amp;&amp;nums[i]&lt;=threshold)&#123;                ans=max(ans,cnt);                for(int j=i+1;j&lt;n;j++)&#123;                    if(nums[j]&lt;=threshold&amp;&amp;nums[j]%2!=nums[j-1]%2)&#123;                        cnt++;                    &#125;else&#123;                        cnt=1;                        break;                    &#125;                    ans=max(ans,cnt);                &#125;                cnt=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2761. Prime Pairs With Target Sumclass Solution &#123;public:    bool isPrime(int v)&#123;        int s=sqrt(v);        for(int i=2;i&lt;=s;i++)&#123;            if(v%i==0)&#123;                return false;            &#125;        &#125;        return true;    &#125;    vector&lt;vector&lt;int&gt;&gt; findPrimePairs(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        if(n&lt;=2)&#123;            return ans;        &#125;                int x=3;        while(x&lt;=n/2)&#123;            if(isPrime(x))&#123;                if(isPrime(n-x))&#123;                    ans.push_back(&#123;x,n-x&#125;);                &#125;            &#125;            x+=2;        &#125;        return ans;    &#125;&#125;;"},{"title":"LeetCode 2023/07/23","url":"/2023/07/23/LeetCode-2023-07-23/","content":"2656. Maximum Sum With Exactly K Elementsclass Solution &#123;public:    int maximizeSum(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());        int ans=0;        for(int i=0;i&lt;k;i++)&#123;            ans+=nums[0]+i;        &#125;        return ans;    &#125;&#125;;\n2475. Number of Unequal Triplets in Arrayclass Solution &#123;public:    int unequalTriplets(vector&lt;int&gt;&amp; nums) &#123;        int cnt=0;        int n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[i]!=nums[j])&#123;                    for(int k=j+1;k&lt;n;k++)&#123;                        if(nums[j]!=nums[k]&amp;&amp;nums[i]!=nums[k])&#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;;\n2558. Take Gifts From the Richest Pileclass Solution &#123;public:    long long pickGifts(vector&lt;int&gt;&amp; gifts, int k) &#123;        for(int i=0;i&lt;k;i++)&#123;            sort(gifts.begin(),gifts.end(),greater&lt;int&gt;());            gifts[0]=sqrt(gifts[0]);        &#125;        long long ans=0;        for(auto gift:gifts)&#123;            ans+=gift;        &#125;        return ans;    &#125;&#125;;\n2278. Percentage of Letter in Stringclass Solution &#123;public:    int percentageLetter(string s, char letter) &#123;        double cnt=0;        for(auto c:s)&#123;            cnt+=(c==letter);        &#125;        return cnt/s.size()*100;    &#125;&#125;;\n_275. H-Index IIclass Solution &#123;public:    int hIndex(vector&lt;int&gt;&amp; citations) &#123;        int n=citations.size();        int l=0,r=n-1,m;        while(l&lt;=r)&#123;            m=(r+l+1)/2;            if(citations[m]==n-m)&#123;                return n-m;            &#125;            else if(citations[m]&lt;n-m)&#123;                l=m+1;            &#125;            else&#123;                r=m-1;            &#125;        &#125;        return n-l;    &#125;&#125;;\n_227. Basic Calculator IIclass Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;        int now=0;        char sign=&#x27;+&#x27;;        for(int i=0;i&lt;s.size();i++)&#123;            if(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;)&#123;                now = 10*now + (s[i]-&#x27;0&#x27;);            &#125;            if(!(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;) &amp;&amp; s[i]!=&#x27; &#x27; || i==s.size()-1)&#123;                if(sign==&#x27;+&#x27;)&#123;                    st.push(now);                &#125;                else if(sign==&#x27;-&#x27;)&#123;                    st.push(-1*now);                &#125;                else&#123;                    int num;                    if(sign==&#x27;*&#x27;)&#123;                        num=st.top()*now;                    &#125;                    else&#123;                        num=st.top()/now;                    &#125;                    st.pop();                    st.push(num);                &#125;                sign=s[i];                now=0;             &#125;         &#125;        int sum = 0;        while(!st.empty())&#123;            sum+=st.top();            st.pop();        &#125;        return sum;    &#125;&#125;;\n2778. Sum of Squares of Special Elementsclass Solution &#123;public:    int sumOfSquares(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        int ans=0;        for(int i=0;i&lt;n;i++)&#123;            if(n%(i+1)==0)&#123;                ans+=nums[i]*nums[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n2779. Maximum Beauty of an Array After Applying Operationclass Solution &#123;public:    int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; temp(100001,0);        for(auto num:nums)&#123;            temp[num]++;        &#125;        int now=0;        for(int i=0;i&lt;min(2*k,100001);i++)&#123;            now+=temp[i];        &#125;        int ans=now;        for(int i=2*k;i&lt;100001;i++)&#123;            now+=temp[i];            ans=max(ans,now);            now-=temp[i-2*k];        &#125;        return ans;    &#125;&#125;;\n2780. Minimum Index of a Valid Splitclass Solution &#123;public:    int minimumIndex(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        vector&lt;pair&lt;int,int&gt;&gt; left(n);        vector&lt;pair&lt;int,int&gt;&gt; right(n);                unordered_map&lt;int, int&gt; rFreq;        int rNum=0,rCnt=0;        for(int i=n-1;i&gt;0;i--)&#123;            rFreq[nums[i]]++;            if(rFreq[nums[i]]&gt;rCnt)&#123;                rNum = nums[i];                rCnt=rFreq[nums[i]];            &#125;            right[i-1]=&#123;rNum,rCnt&#125;;        &#125;                unordered_map&lt;int, int&gt; freq;        int leftNum=0,leftCnt=0;        for (int i=0;i&lt;n-1;i++) &#123;            freq[nums[i]]++;            if(freq[nums[i]]&gt;leftCnt)&#123;                leftNum = nums[i];                leftCnt = freq[nums[i]];            &#125;                        if (leftNum==right[i].first) &#123;                if(leftCnt * 2 &gt; i+1 &amp;&amp; right[i].second * 2 &gt; (n-i-1))&#123;                    return i;                &#125;             &#125;        &#125;        return -1;    &#125;&#125;;"},{"title":"LeetCode 2023/07/30","url":"/2023/08/06/LeetCode-2023-07-30/","content":"\n1394. Find Lucky Integer in an Arrayclass Solution &#123;public:    int findLucky(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(),arr.end(),greater&lt;int&gt;());        int now=arr[0],cnt=0;        for(auto a:arr)&#123;            if(a==now)&#123;                cnt++;            &#125;else&#123;                if(cnt==now)&#123;                    return cnt;                &#125;                now=a;                cnt=1;            &#125;        &#125;        if(cnt==arr.back())&#123;            return cnt;        &#125;        return -1;    &#125;&#125;;\n1332. Remove Palindromic Subsequencesclass Solution &#123;public:    int removePalindromeSub(string s) &#123;            string temp=s;            reverse(temp.begin(),temp.end());            if(s==&quot;&quot;)&#123;                return 0;            &#125;            else if(s==temp)&#123;                return 1;            &#125;            return 2;        &#125;&#125;;\n1281. Subtract the Product and Sum of Digits of an Integerclass Solution &#123;public:    int subtractProductAndSum(int n) &#123;        int pro=1,sum=0;        while(n&gt;0)&#123;            pro*=n%10;            sum+=n%10;            n/=10;        &#125;        return pro-sum;    &#125;&#125;;\n1013. Partition Array Into Three Parts With Equal Sumclass Solution &#123;public:    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; arr) &#123;        int n=arr.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)        &#125;    &#125;&#125;;\n2249. Count Lattice Points Inside a Circleclass Solution &#123;public:    int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123;        set&lt;pair&lt;int,int&gt;&gt; temp;        for(auto c:circles)&#123;            int midx=c[0],midy=c[1],r=c[2],r_sqr=c[2]*c[2];            for(int x=-r;x&lt;=r;x++)&#123;                for(int y=-r;y&lt;=r;y++)&#123;                    if(x*x+y*y&lt;=r_sqr)&#123;                        temp.insert(&#123;midx+x,midy+y&#125;);                    &#125;                &#125;            &#125;        &#125;        return temp.size();    &#125;&#125;;\n2256. Minimum Average Differenceclass Solution &#123;public:    int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123;        long long sum=0;        for(auto num:nums)&#123;            sum+=num;        &#125;        int n=nums.size();        long long now=0,minVal=1e5,minIdx=0,temp;        for(int i=0;i&lt;n-1;i++)&#123;            now+=nums[i];            sum-=nums[i];            temp=abs(now/(i+1)-sum/(n-i-1));            if(temp&lt;minVal)&#123;                minVal=temp;                minIdx=i;            &#125;        &#125;        if((now+nums[n-1])/n&lt;minVal)&#123;            minIdx=n-1;        &#125;        return minIdx;    &#125;&#125;;\n2788. Split Strings by Separatorclass Solution &#123;public:    vector&lt;string&gt; splitWordsBySeparator(vector&lt;string&gt;&amp; words, char separator) &#123;        vector&lt;string&gt; ans;        string temp;        for(auto word:words)&#123;            temp=&quot;&quot;;            for(auto c:word)&#123;                if(c==separator)&#123;                    if(temp!=&quot;&quot;)&#123;                        ans.push_back(temp);                        temp=&quot;&quot;;                    &#125;                &#125;else&#123;                    temp+=c;                &#125;            &#125;            if(temp!=&quot;&quot;)&#123;                ans.push_back(temp);            &#125;        &#125;        return ans;    &#125;&#125;;\n2789. Largest Element in an Array after Merge Operationsclass Solution &#123;public:    long long maxArrayValue(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;long long&gt; temp(n,0);        long long ans=nums[n-1];        temp[n-1]=nums[n-1];        for(int i=n-1;i&gt;0;i--)&#123;            temp[i-1]=nums[i-1];            if(nums[i-1]&lt;=temp[i])&#123;                temp[i-1]+=temp[i];            &#125;            ans=max(ans,temp[i-1]);        &#125;        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;temp[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        return ans;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/08/13","url":"/2023/08/14/LeetCode-2023-08-13/","content":"\n_108. Convert Sorted Array to Binary Search Treeclass Solution &#123;public:    TreeNode* pushNode(vector&lt;int&gt;&amp; nums,int left,int right)&#123;        if(left&lt;=right)&#123;            int mid=(left+right)/2;            TreeNode* root = new TreeNode(nums[mid]);            root-&gt;left = pushNode(nums,left,mid-1);            root-&gt;right = pushNode(nums,mid+1,right);            return root;        &#125;        return nullptr;    &#125;    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return pushNode(nums,0,nums.size()-1);    &#125;&#125;;\n_303. Range Sum Query - Immutableclass NumArray &#123;public:    vector&lt;int&gt; temp;    NumArray(vector&lt;int&gt;&amp; nums) &#123;        temp.clear();        for(auto num:nums)&#123;            temp.push_back(num);        &#125;    &#125;        int sumRange(int left, int right) &#123;        int sum=0;        for(int i=left;i&lt;=right;i++)&#123;            sum+=temp[i];        &#125;        return sum;    &#125;&#125;;\n_202. Happy Numberclass Solution &#123;public:    bool isHappy(int n) &#123;        int temp=0;        for(int i=0;i&lt;20;i++)&#123;            temp=0;            while(n&gt;0)&#123;                temp+=(n%10)*(n%10);                n/=10;            &#125;            n=temp;            // cout&lt;&lt;n&lt;&lt;endl;        &#125;        return n==1;    &#125;&#125;;\n_232. Implement Queue using Stacksclass MyQueue &#123;public:    vector&lt;int&gt; temp;    MyQueue() &#123;        temp.clear();    &#125;        void push(int x) &#123;        temp.push_back(x);    &#125;        int pop() &#123;        int val=temp[0];        temp.erase(temp.begin());        return val;    &#125;        int peek() &#123;        return temp[0];    &#125;        bool empty() &#123;        return temp.size()==0;    &#125;&#125;;\n2162. Minimum Cost to Set Cooking Timeclass Solution &#123;public:    int pushNum(int startAt, int moveCost, int pushCost, int s)&#123;        int val=0;        stack&lt;int&gt; st;        while(s&gt;0)&#123;            st.push(s%10);            s/=10;        &#125;        while(!st.empty())&#123;            if(startAt!=st.top())&#123;                val+=moveCost;                startAt=st.top();            &#125;            val+=pushCost;            st.pop();        &#125;        return val;    &#125;    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) &#123;        int m=0,s=targetSeconds;        int ans=1e9;        while(s&gt;=100)&#123;            m+=1;            s-=60;        &#125;        while(s&gt;=0&amp;&amp;m&lt;100)&#123;            ans=min(ans,pushNum(startAt,moveCost,pushCost,m*100+s));            m+=1;            s-=60;        &#125;        return ans;    &#125;&#125;;\n2810. Faulty Keyboardclass Solution &#123;public:    string finalString(string s) &#123;        string temp=&quot;&quot;;        for(auto c:s)&#123;            if(c==&#x27;i&#x27;)&#123;                reverse(temp.begin(),temp.end());            &#125;else&#123;                temp+=c;            &#125;        &#125;        return temp;    &#125;&#125;;\n2811. Check if it is Possible to Split Arrayclass Solution &#123;public:    bool canSplitArray(vector&lt;int&gt;&amp; nums, int m) &#123;        for(int i=0;i&lt;nums.size()-1;i++)            if(nums[i]+nums[i+1]&gt;=m)&#123;                return true;            &#125;        return nums.size()&lt;3;    &#125;&#125;;\n2812. Find the Safest Path in a Grid```* 2813\\. [Maximum Elegance of a K-Length Subsequence](https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence/)```Cpp\n\n"},{"title":"LeetCode 2023/08/20","url":"/2023/08/21/LeetCode-2023-08-20/","content":"\n2441. Largest Positive Integer That Exists With Its Negativeclass Solution &#123;public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int left=0,right=nums.size()-1;        while(left&lt;right)&#123;            cout&lt;&lt;nums[left]&lt;&lt;&#x27; &#x27;&lt;&lt;nums[right]&lt;&lt;endl;            if(nums[left]*-1==nums[right])&#123;                return nums[right];            &#125;else if(nums[left]*-1&lt;nums[right])&#123;                right--;            &#125;else&#123;                left++;            &#125;        &#125;        return -1;    &#125;&#125;;\n2520. Count the Digits That Divide a Numberclass Solution &#123;public:    int countDigits(int num) &#123;        int ans=0;        int temp=num;        while(temp&gt;0)&#123;            ans+=(num%(temp%10))==0;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n2299. Strong Password Checker IIclass Solution &#123;public:    bool check_special_char(char c)&#123;        string special=&quot;!@#$%^&amp;*()-+&quot;;        for(auto s:special)&#123;            if(c==s)&#123;                return true;            &#125;        &#125;        return false;    &#125;    bool strongPasswordCheckerII(string password) &#123;        int n=password.size();        bool upper=false,lower=false,digit=false,special=false;        char lastword=&#x27;&gt;&#x27;;        for(auto c:password)&#123;            if(c==lastword)                return false;            else if(&#x27;A&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;Z&#x27;)                upper=true;            else if(&#x27;a&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;z&#x27;)                lower=true;            else if(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)                digit=true;            else if(check_special_char(c))                special=true;            lastword=c;        &#125;        return n&gt;7&amp;&amp;upper&amp;&amp;lower&amp;&amp;digit&amp;&amp;special;    &#125;&#125;;\n2423. Remove Letter To Equalize Frequencyclass Solution &#123;public:    bool chk_one(vector&lt;int&gt;&amp; now)&#123;        bool chk=true;        int idx;        for(idx=1;now[idx]&gt;1;idx++)&#123;            if(now[0]!=now[idx])&#123;                return false;            &#125;        &#125;        if(now[idx]==0)&#123;            return false;        &#125;        if(idx==now.size()-1)&#123;            return true;        &#125;        if(now[idx+1]==1)&#123;            return false;        &#125;        return true;    &#125;    bool equalFrequency(string word) &#123;        vector&lt;int&gt; abc(26,0);        for(auto c:word)&#123;            abc[c-&#x27;a&#x27;]++;        &#125;        sort(abc.begin(),abc.end(),greater&lt;int&gt;());        if(abc[0]==1)&#123;            return true;        &#125;        if(chk_one(abc))&#123;            return true;        &#125;         bool chk=true;        for(int i=0;i&lt;26;i++)&#123;            if(abc[i]==0)&#123;                break;            &#125;            chk=true;            for(int j=0;j&lt;26;j++)&#123;                if(abc[j]==0)&#123;                    break;                &#125;                if(i!=j&amp;&amp;abc[i]-1!=abc[j])&#123;                    chk=false;                    break;                &#125;            &#125;            if(chk)&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n_957. Prison Cells After N Daysclass Solution &#123;public:    int calc(int a,int b,int c)&#123;        if(a==c)&#123;            return 1;        &#125;        return 0;    &#125;    vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int n) &#123;        vector&lt;int&gt; now(8),temp(8);        int loop=(n-1)%14;        for(int i=0;i&lt;8;i++)&#123;            now[i]=cells[i];        &#125;        for(int cnt=0;cnt&lt;=loop;cnt++)&#123;            temp[0]=0;            for(int i=1;i&lt;7;i++)&#123;                temp[i]=calc(now[i-1],now[i],now[i+1]);            &#125;            temp[7]=0;            for(int i=0;i&lt;8;i++)&#123;                now[i]=temp[i];            &#125;        &#125;            return now;    &#125;&#125;;//chk loop// vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int n) &#123;//     vector&lt;int&gt; now(8),temp(8);//     now[0]=cells[0]&amp;&amp;cells[1];//     for(int i=1;i&lt;7;i++)&#123;//         now[i]=calc(cells[i-1],cells[i],cells[i+1]);//     &#125;//     now[7]=cells[6]&amp;&amp;cells[7];//     for(int i=0;i&lt;8;i++)&#123;//         cells[i]=now[i];//     &#125;//     while(true)&#123;//         temp[0]=now[0]&amp;&amp;now[1];//         for(int i=1;i&lt;7;i++)&#123;//             temp[i]=calc(now[i-1],now[i],now[i+1]);//         &#125;//         temp[7]=now[6]&amp;&amp;now[7];//         bool chk=true;//         for(int i=0;i&lt;8;i++)&#123;//             now[i]=temp[i];//             cout&lt;&lt;now[i]&lt;&lt;&#x27; &#x27;;//             if(now[i]!=cells[i])&#123;//                 chk=false;//             &#125;//         &#125;//         cout&lt;&lt;endl;//         if(chk)&#123;//             break;//         &#125;//     &#125;//     return &#123;&#125;;// &#125;\n_900. RLE Iteratorclass RLEIterator &#123;public:    vector&lt;int&gt; num;    vector&lt;int&gt; cnt;    int idx=0,num_siz;    RLEIterator(vector&lt;int&gt;&amp; encoding) &#123;        int n=encoding.size();        idx=0;        for(int i=0;i&lt;n;i+=2)&#123;            cnt.push_back(encoding[i]);            num.push_back(encoding[i+1]);        &#125;        num_siz=num.size();    &#125;        int next(int n) &#123;        for(;idx&lt;num_siz;idx++)&#123;            if(cnt[idx]&gt;=n)&#123;                cnt[idx]-=n;                return num[idx];            &#125;else&#123;                n-=cnt[idx];                cnt[idx]=0;            &#125;        &#125;        return -1;    &#125;&#125;;\n2815. Max Pair Sum in an Arrayclass Solution &#123;public:    int maxdigit(int n)&#123;        int output=0;        while(n&gt;0)&#123;            output=max(output,n%10);            n/=10;        &#125;        return output;    &#125;    int maxSum(vector&lt;int&gt;&amp; nums) &#123;        int ans=-1;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(maxdigit(nums[i])==maxdigit(nums[j]))&#123;                    ans=max(ans,nums[i]+nums[j]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2816. Double a Number Represented as a Linked Listclass Solution &#123;public:    ListNode* doubleIt(ListNode* head) &#123;        ListNode* ans=new ListNode();        if(head-&gt;val&gt;4)&#123;            ans-&gt;next=head;        &#125;else&#123;            ans=head;        &#125;        ListNode* temp=ans;        while(temp)&#123;            temp-&gt;val=(2*temp-&gt;val)%10;            if(temp-&gt;next)                if(temp-&gt;next-&gt;val&gt;4)                    temp-&gt;val++;            temp=temp-&gt;next;        &#125;        return ans;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/07/16","url":"/2023/07/17/LeetCode-2023-07-16/","content":"_557. Reverse Words in a String IIIclass Solution &#123;public:    string reverseWords(string s) &#123;        string ans=&quot;&quot;,temp=&quot;&quot;;        for(auto c:s)&#123;            if(c!=&#x27; &#x27;)&#123;                temp=c+temp;            &#125;else&#123;                if(ans==&quot;&quot;)&#123;                    ans=temp;                &#125;else&#123;                    ans+=&quot; &quot;+temp;                &#125;                temp=&quot;&quot;;            &#125;        &#125;        if(ans==&quot;&quot;)&#123;            ans=temp;        &#125;else&#123;            ans+=&quot; &quot;+temp;        &#125;        return ans;    &#125;&#125;;\n_345. Reverse Vowels of a Stringclass Solution &#123;public:    string reverseVowels(string s) &#123;        string ans;        int n=s.size();        int left=n-1;        for(int i=0;i&lt;n;i++)&#123;            if(s[i]==&#x27;a&#x27;||s[i]==&#x27;e&#x27;||s[i]==&#x27;i&#x27;||s[i]==&#x27;o&#x27;||s[i]==&#x27;u&#x27;||s[i]==&#x27;A&#x27;||s[i]==&#x27;E&#x27;||s[i]==&#x27;I&#x27;||s[i]==&#x27;O&#x27;||s[i]==&#x27;U&#x27;)&#123;                while(s[left]!=&#x27;a&#x27;&amp;&amp;s[left]!=&#x27;e&#x27;&amp;&amp;s[left]!=&#x27;i&#x27;&amp;&amp;s[left]!=&#x27;o&#x27;&amp;&amp;s[left]!=&#x27;u&#x27;&amp;&amp;s[left]!=&#x27;A&#x27;&amp;&amp;s[left]!=&#x27;E&#x27;&amp;&amp;s[left]!=&#x27;I&#x27;&amp;&amp;s[left]!=&#x27;O&#x27;&amp;&amp;s[left]!=&#x27;U&#x27;)&#123;                    left--;                &#125;                ans+=s[left];                left--;            &#125;else&#123;                ans+=s[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n_463. Island Perimeterclass Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int x=grid.size(),y=grid[0].size();        int ans=0;        bool chk=false;        for(int i=0;i&lt;x;i++)&#123;            chk=false;            for(int j=0;j&lt;y;j++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[i][y-1]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        for(int j=0;j&lt;y;j++)&#123;            chk=false;            for(int i=0;i&lt;x;i++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[x-1][j]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        return ans;    &#125;&#125;;\n_160. Intersection of Two Linked Listsclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *temp=headA;        vector&lt;int*&gt; A,B;        while(headA!=NULL)&#123;            A.push_back(&amp;headA-&gt;val);            headA=headA-&gt;next;        &#125;        while(headB!=NULL)&#123;            B.push_back(&amp;headB-&gt;val);            headB=headB-&gt;next;        &#125;        int n=A.size(),m=B.size();        int idx;        int chk=false;        for(idx=1;idx&lt;=min(n,m);idx++)&#123;            if(A[n-idx]!=B[m-idx])&#123;                chk=true;                break;            &#125;        &#125;        if(idx&gt;min(n,m)&amp;&amp;chk)&#123;            return NULL;        &#125;else&#123;            for(int i=0;i&lt;=n-idx;i++)&#123;                temp=temp-&gt;next;            &#125;            return temp;        &#125;    &#125;&#125;;\n___6. Zigzag Conversionclass Solution &#123;public:    string convert(string s, int numRows) &#123;        if(numRows==1)&#123;            return s;        &#125;        vector&lt;vector&lt;char&gt;&gt; temp(numRows,vector&lt;char&gt;(1000,&#x27; &#x27;));        bool up=false;        int i=0,j=0;        for(char c:s)&#123;            temp[i][j]=c;            if(up)&#123;                i--;                j++;                if(i==0)&#123;                    up=false;                &#125;            &#125;else&#123;                i++;                if(i==numRows)&#123;                    up=true;                    i-=2;                    j++;                    if(i==0)&#123;                        up=false;                    &#125;                &#125;            &#125;        &#125;        string ans;        for(int ii=0;ii&lt;numRows;ii++)&#123;            for(int jj=0;jj&lt;j+1;jj++)&#123;                if(temp[ii][jj]!=&#x27; &#x27;)&#123;                    ans+=temp[ii][jj];                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n1366. Rank Teams by Votesclass Solution &#123;public:    static bool cmp(pair&lt;char,vector&lt;int&gt;&gt; a, pair&lt;char,vector&lt;int&gt;&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a.second[i]!=b.second[i])&#123;                return a.second[i]&gt;b.second[i];            &#125;        &#125;        return a.first&lt;b.first;    &#125;    string rankTeams(vector&lt;string&gt;&amp; votes) &#123;        vector&lt;pair&lt;char,vector&lt;int&gt;&gt;&gt; temp(26,&#123;&#x27; &#x27;,vector&lt;int&gt;(26,0)&#125;);        for(auto c:votes[0])&#123;            temp[c-&#x27;A&#x27;].first=c;        &#125;        int voteSize=votes[0].size();        for(auto vote:votes)&#123;            for(int i=0;i&lt;voteSize;i++)&#123;                temp[vote[i]-&#x27;A&#x27;].second[i]++;            &#125;        &#125;        sort(temp.begin(),temp.end(),cmp);        string ans=&quot;&quot;;        for(auto t:temp)&#123;            if(t.first!=&#x27; &#x27;)&#123;                ans+=t.first;            &#125;        &#125;        return ans;    &#125;&#125;;\n2769. Find the Maximum Achievable Numberclass Solution &#123;public:    int theMaximumAchievableX(int num, int t) &#123;        return num+2*t;    &#125;&#125;;\n6899. Maximum Number of Jumps to Reach the Last Indexclass Solution &#123;public:    int maximumJumps(vector&lt;int&gt;&amp; nums, int target) &#123;        int n=nums.size();        vector&lt;int&gt; distance(n,-2);        distance[0]=0;        for(int i=1;i&lt;n;i++)&#123;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(nums[j]-nums[i])&lt;=target&amp;&amp;distance[j]&gt;=0)&#123;                    distance[i]=max(distance[i],distance[j]);                &#125;            &#125;            distance[i]++;        &#125;        return distance[n-1];    &#125;&#125;;\n6912. Longest Non-decreasing Subarray From Two Arraysclass Solution &#123;public:    int maxNonDecreasingLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int n=nums1.size();        vector&lt;int&gt; nums1c(n,1);        vector&lt;int&gt; nums2c(n,1);        int now=0;        int ans=1;        for(int i=1;i&lt;n;i++)&#123;            if(nums2[i-1]&lt;=nums2[i])&#123;                nums2c[i]=nums2c[i-1]+1;            &#125;            if(nums1[i-1]&lt;=nums2[i])&#123;                nums2c[i]=max(nums1c[i-1]+1,nums2c[i]);            &#125;            if(nums1[i-1]&lt;=nums1[i])&#123;                nums1c[i]=nums1c[i-1]+1;            &#125;            if(nums2[i-1]&lt;=nums1[i])&#123;                nums1c[i]=max(nums2c[i-1]+1,nums1c[i]);            &#125;            ans=max(ans,max(nums1c[i],nums2c[i]));        &#125;        return ans;    &#125;&#125;;"},{"title":"LeetCode 2023/08/27","url":"/2023/08/28/LeetCode-2023-08-27/","content":"\n1929. Concatenation of Arrayclass Solution &#123;public:    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            nums.push_back(nums[i]);        &#125;        return nums;    &#125;&#125;;\n1886. Determine Whether Matrix Can Be Obtained By Rotationclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; rotate(vector&lt;vector&lt;int&gt;&gt; input)&#123;        int n=input.size();        vector&lt;vector&lt;int&gt;&gt; output(n,vector&lt;int&gt;(n,0));        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                output[j][n-i-1]=input[i][j];            &#125;        &#125;        return output;    &#125;    bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123;        int n=mat.size();        for(int turn=0;turn&lt;4;turn++)&#123;            bool chk=true;            for(int i=0;i&lt;n;i++)&#123;                for(int j=0;j&lt;n;j++)&#123;                    if(mat[i][j]!=target[i][j])&#123;                        chk=false;                    &#125;                &#125;            &#125;            if(chk)&#123;                return true;            &#125;            mat=rotate(mat);        &#125;        return false;    &#125;&#125;;\n1752. Check if Array Is Sorted and Rotatedclass Solution &#123;public:    bool isSorted(vector&lt;int&gt;&amp; nums)&#123;        int n=nums.size();        for(int i=1;i&lt;n;i++)&#123;            if(nums[i-1]&gt;nums[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    bool check(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(isSorted(nums))&#123;                return true;            &#125;            nums.push_back(nums[0]);            nums.erase(nums.begin());        &#125;        return false;    &#125;&#125;;\n1518. Water Bottlesclass Solution &#123;public:    int numWaterBottles(int numBottles, int numExchange) &#123;        int ans=numBottles;        while(numBottles&gt;=numExchange)&#123;            ans+=numBottles/numExchange;            numBottles=numBottles/numExchange+numBottles%numExchange;        &#125;        return ans;    &#125;&#125;;\n__57. Insert Intervalclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;        int n=intervals.size();        if(n==0)&#123;            return &#123;newInterval&#125;;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        int idx=0,left,right;        for(;idx&lt;n;idx++)&#123;            if(intervals[idx][1]&lt;newInterval[0])&#123;                ans.push_back(intervals[idx]);            &#125;else&#123;                break;            &#125;        &#125;        if(idx==0&amp;&amp;intervals[idx][1]&lt;newInterval[0])&#123;            ans.push_back(newInterval);        &#125;else if(idx==n)&#123;            ans.push_back(newInterval);        &#125;else if(intervals[idx][0]&lt;=newInterval[0]&amp;&amp;newInterval[1]&lt;=intervals[idx][1])&#123;                ans.push_back(intervals[idx]);                idx++;        &#125;else&#123;            left=min(intervals[idx][0],newInterval[0]);            right=newInterval[1];            for(;idx&lt;n;idx++)&#123;                if(intervals[idx][0]&lt;=newInterval[1])&#123;                    right=max(right,intervals[idx][1]);                &#125;else&#123;                    break;                &#125;            &#125;            ans.push_back(&#123;left,right&#125;);        &#125;        for(;idx&lt;n;idx++)&#123;            ans.push_back(intervals[idx]);        &#125;        return ans;    &#125;&#125;;\n_229. Majority Element IIclass Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;        int limit=nums.size()/3;        sort(nums.begin(),nums.end());        int now=nums[0],cnt=0;        for(auto num:nums)&#123;            if(now==num)&#123;                cnt++;            &#125;else&#123;                if(cnt&gt;limit)&#123;                    ans.push_back(now);                &#125;                now=num;                cnt=1;            &#125;        &#125;        if(cnt&gt;limit)&#123;            ans.push_back(now);        &#125;        return ans;    &#125;&#125;;\n2828. Check if a String Is an Acronym of Wordsclass Solution &#123;public:    bool isAcronym(vector&lt;string&gt;&amp; words, string s) &#123;        string temp=&quot;&quot;;        for(auto word:words)&#123;            temp+=word[0];        &#125;        return temp==s;    &#125;&#125;;\n2829. Determine the Minimum Sum of a k-avoiding Arrayclass Solution &#123;public:    int minimumSum(int n, int k) &#123;        int cnt=0,sum=0;        for(int i=1;cnt&lt;n;i++)&#123;            if(!(k/2&lt;i&amp;&amp;i&lt;k))&#123;                cout&lt;&lt;i&lt;&lt;endl;                cnt++;                sum+=i;            &#125;        &#125;        return sum;    &#125;&#125;;\n2831. Find the Longest Equal Subarrayclass Solution &#123;public:    int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) &#123;        int n=nums.size(),left=0,diff;        int ans=0;        unordered_map&lt;int,int&gt; count;        for(int i=0;i&lt;n;i++)&#123;            count[nums[i]]++;            ans=max(ans,count[nums[i]]);            if(i-left+1-ans&gt;k)&#123;                count[nums[left]]--;                left++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/09/03","url":"/2023/09/12/LeetCode-2023-09-03/","content":"\n2341. Maximum Number of Pairs in Arrayclass Solution &#123;public:    vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) &#123;        int pair=0,left=0,temp=0,now=nums[0];        sort(nums.begin(),nums.end());        for(auto num:nums)&#123;            if(now==num)&#123;                temp++;            &#125;else&#123;                pair+=temp/2;                left+=temp%2;                temp=1;                now=num;            &#125;        &#125;        pair+=temp/2;        left+=temp%2;        return &#123;pair,left&#125;;    &#125;&#125;;\n2331. Evaluate Boolean Binary Treeclass Solution &#123;public:    bool eval(TreeNode* root)&#123;        if(root-&gt;val==0)&#123;            return false;        &#125;        else if(root-&gt;val==1)&#123;            return true;        &#125;        else if(root-&gt;val==2)&#123;            return eval(root-&gt;left)||eval(root-&gt;right);        &#125;        else if(root-&gt;val==3)&#123;            return eval(root-&gt;left)&amp;&amp;eval(root-&gt;right);        &#125;        return false;    &#125;    bool evaluateTree(TreeNode* root) &#123;        return eval(root);    &#125;&#125;;\n2500. Delete Greatest Value in Each Rowclass Solution &#123;public:    int deleteGreatestValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans=0,temp=0;        int m=grid.size(),n=grid[0].size();        for(int i=0;i&lt;n;i++)&#123;            temp=0;            for(int j=0;j&lt;m;j++)&#123;                sort(grid[j].begin(),grid[j].end(),greater&lt;int&gt;());                temp=max(temp,grid[j][0]);                grid[j][0]=-1;            &#125;            ans+=temp;        &#125;        return ans;    &#125;&#125;;\n2744. Find Maximum Number of String Pairsclass Solution &#123;public:    int maximumNumberOfStringPairs(vector&lt;string&gt;&amp; words) &#123;        int pair=0,n=words.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(words[i][0]==words[j][1]&amp;&amp;words[i][1]==words[j][0])&#123;                    pair++;                    break;                &#125;            &#125;        &#125;        return pair;    &#125;&#125;;\n2833. Furthest Point From Originclass Solution &#123;public:    int furthestDistanceFromOrigin(string moves) &#123;        int space=0,pos=0;        for(auto c:moves)&#123;            if(c==&#x27;_&#x27;)&#123;                space++;            &#125;else if(c==&#x27;L&#x27;)&#123;                pos--;            &#125;else&#123;                pos++;            &#125;        &#125;        return pos&gt;=0?pos+space:-1*(pos-space);    &#125;&#125;;\n2834. Find the Minimum Possible Sum of a Beautiful Arrayclass Solution &#123;public:    long long minimumPossibleSum(int n, int target) &#123;        long long ans=0;        int cnt=0;        unordered_map&lt;int,int&gt; temp;        for(int i=1;cnt&lt;n;i++)&#123;            if(temp[min(i,target-i)]==0)&#123;                ans+=i;                temp[min(i,target-i)]=1;                cnt++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/09/17","url":"/2023/09/23/LeetCode-2023-09-17/","content":"2023&#x2F;09&#x2F;17\n_404. Sum of Left Leavesclass Solution &#123;public:    int calcLeft(TreeNode* root)&#123;        int val=0;        if(root-&gt;left!=NULL)&#123;            if(root-&gt;left-&gt;left==NULL&amp;&amp;root-&gt;left-&gt;right==NULL)&#123;                val+=root-&gt;left-&gt;val;            &#125;else&#123;                val+=calcLeft(root-&gt;left);            &#125;        &#125;        if(root-&gt;right!=NULL)&#123;            val+=calcLeft(root-&gt;right);        &#125;        return val;    &#125;    int sumOfLeftLeaves(TreeNode* root) &#123;        return calcLeft(root);    &#125;&#125;;\n_263. Ugly Numberclass Solution &#123;public:    bool isUgly(int n) &#123;        if(n==0)&#123;            return false;        &#125;        while(n%2==0)&#123;            n/=2;        &#125;        while(n%3==0)&#123;            n/=3;        &#125;        while(n%5==0)&#123;            n/=5;        &#125;        return n==1;    &#125;&#125;;\n_448. Find All Numbers Disappeared in an Arrayclass Solution &#123;public:    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; val(n);        vector&lt;int&gt; ans;        for(auto num:nums)&#123;            val[num-1]++;        &#125;        for(int i=0;i&lt;n;i++)&#123;            if(val[i]==0)&#123;                ans.push_back(i+1);            &#125;        &#125;        return ans;    &#125;&#125;;\n_653. Two Sum IV - Input is a BSTclass Solution &#123;public:    void remake(vector&lt;int&gt;&amp; val,TreeNode* root)&#123;        if(root!=NULL)&#123;            val.push_back(root-&gt;val);            remake(val,root-&gt;left);            remake(val,root-&gt;right);        &#125;        return;    &#125;    bool findTarget(TreeNode* root, int k) &#123;        vector&lt;int&gt; val;        remake(val,root);        sort(val.begin(),val.end());        for(auto num:val)&#123;            if(k-num!=num)&#123;                for(auto chk:val)&#123;                    if(chk==k-num)&#123;                        return true;                    &#125;                &#125;            &#125;else&#123;                int cnt=0;                for(auto chk:val)&#123;                    if(chk==num)&#123;                        cnt++;                        if(cnt&gt;1)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;&#125;;\n1010. Pairs of Songs With Total Durations Divisible by 60class Solution &#123;public:    int C(long long x)&#123;        if(x&lt;2)&#123;            return 0;        &#125;        long long ans=x*(x-1)/2;        return ans;    &#125;    int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) &#123;        vector&lt;int&gt; minute(60);        for(auto t:time)&#123;            minute[t%60]++;        &#125;        int ans=C(minute[0]);        for(int i=1;i&lt;30;i++)&#123;            ans+=minute[i]*minute[60-i];        &#125;        ans+=C(minute[30]);        return ans;    &#125;&#125;;\n2848. Points That Intersect With Carsclass Solution &#123;public:    int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;        vector&lt;int&gt; map(100,0);        for(auto num:nums)&#123;            for(int i=num[0];i&lt;=num[1];i++)&#123;                map[i-1]=1;            &#125;        &#125;        int cnt=0;        for(auto m:map)&#123;            cnt+=(m==1);        &#125;        return cnt;    &#125;&#125;;\n2849. Determine if a Cell Is Reachable at a Given Timeclass Solution &#123;public:    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) &#123;        int dis=max(abs(fx-sx),abs(fy-sy));        if(dis==0&amp;&amp;t==1)&#123;            return false;        &#125;        return t&gt;=dis;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/09/24","url":"/2023/09/24/LeetCode-2023-09-24/","content":"2023&#x2F;09&#x2F;24\n1078. Occurrences After Bigramclass Solution &#123;public:    vector&lt;string&gt; findOcurrences(string text, string first, string second) &#123;        vector&lt;string&gt; words;        string word=&quot;&quot;;        for(auto c:text)&#123;            if(c==&#x27; &#x27;)&#123;                words.push_back(word);                word=&quot;&quot;;            &#125;else&#123;                word=word+c;            &#125;        &#125;        if(word!=&quot;&quot;)&#123;            words.push_back(word);        &#125;        vector&lt;string&gt; ans;        int n=words.size();        for(int i=2;i&lt;n;i++)&#123;            if(words[i-2]==first&amp;&amp;words[i-1]==second)&#123;                ans.push_back(words[i]);            &#125;        &#125;        return ans;    &#125;&#125;;\n2582. Pass the Pillowclass Solution &#123;public:    int passThePillow(int n, int time) &#123;        int pass=time%((n-1)*2);        if(pass&gt;n-1)&#123;            return n-(pass-(n-1));        &#125;        return 1+pass;    &#125;&#125;;\n2586. Count the Number of Vowel Strings in Rangeclass Solution &#123;public:    bool isVowel(char temp)&#123;        return temp==&#x27;a&#x27;||temp==&#x27;e&#x27;||temp==&#x27;i&#x27;||temp==&#x27;o&#x27;||temp==&#x27;u&#x27;;    &#125;    int vowelStrings(vector&lt;string&gt;&amp; words, int left, int right) &#123;        int cnt=0;        for(int i=left;i&lt;=right;i++)&#123;            if(isVowel(words[i].front())&amp;&amp;isVowel(words[i].back()))&#123;                cnt++;            &#125;        &#125;        return cnt;    &#125;&#125;;\n2855. Minimum Right Shifts to Sort the Arrayclass Solution &#123;public:    int minimumRightShifts(vector&lt;int&gt;&amp; nums) &#123;        int idx=0,n=nums.size();        while(idx+1&lt;n&amp;&amp;nums[idx]&lt;nums[idx+1])&#123;            idx++;        &#125;        if(idx==n-1)&#123;            return 0;        &#125;        idx++;        int temp=idx;        while(idx+1&lt;n&amp;&amp;nums[idx]&lt;nums[idx+1])&#123;            idx++;        &#125;        if(idx!=n-1)&#123;            return -1;        &#125;        if(nums[temp]&lt;nums[0]&amp;&amp;nums[n-1]&lt;nums[0])&#123;            return n-temp;        &#125;        return -1;    &#125;&#125;;\n_240. Search a 2D Matrix IIclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m=matrix.size(),n=matrix[0].size();        int i=0,j=n-1;        while(i&lt;m&amp;&amp;j&gt;=0)&#123;            if(matrix[i][j]==target)&#123;                return true;            &#125;else if(matrix[i][j]&gt;target)&#123;                j--;            &#125;else&#123;                i++;            &#125;        &#125;        return false;    &#125;&#125;;\n2859. Sum of Values at Indices With K Set Bitsclass Solution &#123;public:    int binaryONES(int i)&#123;        int ones=0;        while(i&gt;0)&#123;            ones+=i%2;            i/=2;        &#125;        return ones;    &#125;    int sumIndicesWithKSetBits(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans=0,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(binaryONES(i)==k)&#123;                ans+=nums[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n2860. Happy Studentsclass Solution &#123;public:    int countWays(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        sort(nums.begin(),nums.end());        nums.push_back(1e5+1);        int cnt=0;        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]&lt;i+1&amp;&amp;i+1&lt;nums[i+1])&#123;                cnt++;            &#125;        &#125;        if(nums[0]!=0)&#123;            cnt++;        &#125;        return cnt;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/10/15","url":"/2023/10/15/LeetCode-2023-10-15/","content":"2023&#x2F;10&#x2F;15\n2413. Smallest Even Multipleclass Solution &#123;public:    int smallestEvenMultiple(int n) &#123;        if(n%2==0)&#123;            return n;        &#125;else&#123;            return n*2;        &#125;    &#125;&#125;;\n2409. Count Days Spent Togetherclass Solution &#123;public:    int stringToDate(string time)&#123;        int month[]=&#123;0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334&#125;;        return month[(time[0]-&#x27;0&#x27;)*10+(time[1]-&#x27;0&#x27;)-1]+(time[3]-&#x27;0&#x27;)*10+(time[4]-&#x27;0&#x27;);    &#125;    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) &#123;        int lea=min(stringToDate(leaveAlice),stringToDate(leaveBob));        int arr=max(stringToDate(arriveAlice),stringToDate(arriveBob));        if(lea-arr&lt;0)&#123;            return 0;        &#125;else&#123;            return lea-arr+1;        &#125;        return 0;    &#125;&#125;;\n2455. Average Value of Even Numbers That Are Divisible by Threeclass Solution &#123;public:    int averageValue(vector&lt;int&gt;&amp; nums) &#123;        int temp=0,cnt=0;        for(auto num:nums)&#123;            if(num%3==0&amp;&amp;num%2==0)&#123;                temp+=num;                cnt++;            &#125;        &#125;        if(cnt==0)&#123;            return 0;        &#125;        return temp/cnt;    &#125;&#125;;\n2485. Find the Pivot Integerclass Solution &#123;public:    int pivotInteger(int n) &#123;        int total=n*(n+1)/2;        if(n==1)return 1;        int now=0;        for(int i=1;i&lt;n;i++)&#123;            now+=i;            if(now==total)&#123;                return i;            &#125;            total-=i;        &#125;        return -1;    &#125;&#125;;\n2465. Number of Distinct Averagesclass Solution &#123;public:    int distinctAverages(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;double&gt; temp;        int n=nums.size();        double now;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;n/2;i++)&#123;            now=(nums[i]+nums[n-i-1])/2.0;            if(find(temp.begin(), temp.end(), now) == temp.end())&#123;                temp.push_back(now);            &#125;        &#125;        return temp.size();    &#125;&#125;;\n2264. Largest 3-Same-Digit Number in Stringclass Solution &#123;public:    string largestGoodInteger(string num) &#123;        int n=num.size();        int ret=-1;        for(int i=0;i&lt;n-2;i++)&#123;            if(num[i]==num[i+1]&amp;&amp;num[i]==num[i+2])&#123;                ret=max(ret,num[i]-&#x27;0&#x27;);            &#125;        &#125;        if(ret==-1)&#123;            return &quot;&quot;;        &#125;else&#123;            string c;            c=c+char(ret+&#x27;0&#x27;)+char(ret+&#x27;0&#x27;)+char(ret+&#x27;0&#x27;);            return c;        &#125;    &#125;&#125;;\n2367. Number of Arithmetic Tripletsclass Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        int cnt=0,n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[j]-nums[i]==diff)&#123;                    for(int k=j+1;k&lt;n;k++)&#123;                        if(nums[k]-nums[j]==diff)&#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;;\n2395. Find Subarrays With Equal Sumclass Solution &#123;public:    bool findSubarrays(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; s(n-1);        for(int i=0;i&lt;n-1;i++)&#123;            s[i]=nums[i]+nums[i+1];        &#125;        sort(s.begin(),s.end());        for(int i=0;i&lt;n-2;i++)&#123;            if(s[i]==s[i+1])&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n2605. Form Smallest Number From Two Digit Arraysclass Solution &#123;public:    int minNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        for(int i=1;i&lt;10;i++)&#123;            if(find(nums1.begin(),nums1.end(),i)!=nums1.end()&amp;&amp;find(nums2.begin(),nums2.end(),i)!=nums2.end())&#123;                return i;            &#125;        &#125;        int a=10,b=10;        for(auto num:nums1)&#123;            a=min(a,num);        &#125;        for(auto num:nums2)&#123;            b=min(b,num);        &#125;        if(a&gt;b)&#123;            return b*10+a;        &#125;        return a*10+b;    &#125;&#125;;\n2843. Count Symmetric Integersclass Solution &#123;public:    bool isSymmetric(int val)&#123;        if(val&lt;10)&#123;            return 0;        &#125;else if(val&lt;100)&#123;            val*=10;        &#125;else if(val&lt;1000)&#123;            return 0;        &#125;else if(val&gt;9999)&#123;            return 0;        &#125;        int a,b,c,d;        a=val%10;        val/=10;        b=val%10;        val/=10;        c=val%10;        val/=10;        d=val%10;        return a+b==c+d;    &#125;    int countSymmetricIntegers(int low, int high) &#123;        int cnt=0;        for(int i=low;i&lt;=high;i++)&#123;            cnt+=isSymmetric(i);        &#125;        return cnt;    &#125;&#125;;\n__50. pow(x, nclass Solution &#123;public:    double Pow(double x, long long n)&#123;        if(n==0) &#123;            return 1;        &#125;        if(n&lt;0) &#123;            n=-1*n;            x=1/x;        &#125;        if(n%2==0)&#123;            return Pow(x*x, n/2);        &#125;        else&#123;            return x*Pow(x, n-1);        &#125;    &#125;    double myPow(double x, int n) &#123;        return Pow(x,n);    &#125;&#125;;\n_260. Single Number IIIclass Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;        for(auto num:nums)&#123;            auto idx=find(ans.begin(),ans.end(),num);            if(idx==ans.end())&#123;                ans.push_back(num);            &#125;else&#123;                ans.erase(idx);            &#125;        &#125;        return ans;    &#125;&#125;;\n_309. Best Time to Buy and Sell Stock with Cooldownclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n=prices.size(),now;        vector&lt;int&gt; temp(n);        vector&lt;int&gt; historyMax(n);        if(n&lt;2)&#123;            return 0;        &#125;        temp[1]=max(temp[1],prices[1]-prices[0]);        historyMax[1]=temp[1];        for(int i=2;i&lt;n;i++)&#123;            for(int j=i-1;j&gt;=0;j--)&#123;                now=prices[i]-prices[j];                if(now&gt;temp[i])&#123;                    temp[i]=now;                &#125;                if(j!=0)&#123;                    if(j&gt;2)&#123;                        if(historyMax[j-2]+now&gt;temp[i])&#123;                            temp[i]=historyMax[j-2]+now;                        &#125;                    &#125;                &#125;            &#125;            historyMax[i]=max(historyMax[i-1],temp[i]);        &#125;        int ans=0;        for(auto p:temp)&#123;            ans=max(ans,p);        &#125;        return ans;    &#125;&#125;;\n2873. Maximum Value of an Ordered Triplet Iclass Solution &#123;public:    long long maximumTripletValue(vector&lt;int&gt;&amp; nums) &#123;        long long ans=0,m;        int n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[i]-nums[j]&gt;0)&#123;                    m=0;                    for(int k=j+1;k&lt;n;k++)&#123;                        m=max(m,(long long)nums[k]);                    &#125;                    ans=max(ans,(long long)(nums[i]-nums[j])*m);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2875. Minimum Size Subarray in Infinite Arrayclass Solution &#123;public:    int minSizeSubarray(vector&lt;int&gt;&amp; nums, int target) &#123;        long long sum=0,cnt=0,loop=0,ans=2e9;        vector&lt;int&gt; temp=nums;        for(auto num:nums)&#123;            sum+=num;            cnt++;            temp.push_back(num);        &#125;        if(target%sum==0)&#123;            return (target/sum)*cnt;        &#125;        if(target&gt;sum)&#123;            loop+=(target/sum)*cnt;            target%=sum;        &#125;        int n=nums.size();        int i=0,j=1;        int now=nums[i];        while(i&lt;n&amp;&amp;j&lt;2*n)&#123;            if(now&lt;target)&#123;                now+=temp[j];                j++;            &#125;else if(now==target)&#123;                ans=min(ans,loop+j-i);                now-=temp[i];                i++;            &#125;else&#123;                now-=temp[i];                i++;            &#125;        &#125;        return ans==2e9?-1:ans;    &#125;&#125;;\n2894. Divisible and Non-divisible Sums Differenceclass Solution &#123;public:    int differenceOfSums(int n, int m) &#123;        int div=0,nondiv=0;        for(int i=1;i&lt;=n;i++)&#123;            if(i%m==0)&#123;                div+=i;            &#125;else&#123;                nondiv+=i;            &#125;        &#125;        return nondiv-div;    &#125;&#125;;\n2895. Minimum Processing Timeclass Solution &#123;public:    int minProcessingTime(vector&lt;int&gt;&amp; processorTime, vector&lt;int&gt;&amp; tasks) &#123;        sort(processorTime.begin(),processorTime.end());        sort(tasks.begin(),tasks.end(),greater&lt;int&gt;());        int ans=0,n=tasks.size();        for(int i=0;i&lt;n;i++)&#123;            ans=max(ans,processorTime[i/4]+tasks[i]);        &#125;        return ans;    &#125;&#125;;\n\n"},{"title":"LeetCode 2023/10/22","url":"/2023/10/22/LeetCode-2023-10-22/","content":"2023&#x2F;10&#x2F;22\n2469. Convert the Temperatureclass Solution &#123;public:    vector&lt;double&gt; convertTemperature(double celsius) &#123;        return &#123;celsius+273.15,celsius*1.8+32.00&#125;;    &#125;&#125;;\n2432. The Employee That Worked on the Longest Taskclass Solution &#123;public:    int hardestWorker(int n, vector&lt;vector&lt;int&gt;&gt;&amp; logs) &#123;        int now=0,maxVal=0,maxIdx=0;        for(auto log:logs)&#123;            if(log[1]-now&gt;maxVal)&#123;                maxIdx=log[0];                maxVal=log[1]-now;            &#125;else if(log[1]-now==maxVal)&#123;                maxIdx=min(maxIdx,log[0]);            &#125;            now=log[1];        &#125;        return maxIdx;    &#125;&#125;;\n2578. Split With Minimum Sumclass Solution &#123;public:    int splitNum(int num) &#123;        vector&lt;int&gt; val;        while(num&gt;0)&#123;            val.push_back(num%10);            num/=10;        &#125;        sort(val.begin(),val.end());        int a=0,b=0;        int n=val.size();        for(int i=0;i&lt;n;i++)&#123;            if(i%2==0)&#123;                a=a*10+val[i];            &#125;else&#123;                b=b*10+val[i];            &#125;        &#125;        return a+b;    &#125;&#125;;\n2481. Minimum Cuts to Divide a Circleclass Solution &#123;public:    int numberOfCuts(int n) &#123;        if(n==1)&#123;            return 0;        &#125;        return n%2==1?n:n/2;    &#125;&#125;;\n2639. Find the Width of Columns of a Gridclass Solution &#123;public:    int lengthOfValue(int v)&#123;        int cnt=1;        if(v&lt;0)&#123;            cnt++;            v*=-1;        &#125;        while(v&gt;9)&#123;            cnt++;            v/=10;        &#125;        return cnt;    &#125;    vector&lt;int&gt; findColumnWidth(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m=grid.size(),n=grid[0].size(),maxL;        vector&lt;int&gt; ans;        for(int i=0;i&lt;n;i++)&#123;            maxL=0;            for(int j=0;j&lt;m;j++)&#123;                maxL=max(maxL,lengthOfValue(grid[j][i]));            &#125;            ans.push_back(maxL);        &#125;        return ans;    &#125;&#125;;\n1093. Statistics from a Large Sampleclass Solution &#123;public:    vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) &#123;        vector&lt;pair&lt;int,int&gt;&gt; nums;        double total=0,minV=256,maxV=0,maxCntVal=0,median,now;        int maxCnt=0,cnt=0;        for(int i=0;i&lt;256;i++)&#123;            now=count[i];            if(now&gt;0)&#123;                total+=i*now;                cnt+=now;                nums.push_back(&#123;i,cnt&#125;);                minV=min(minV,i*1.0);                maxV=max(maxV,i*1.0);                if(now&gt;maxCnt)&#123;                    maxCnt=now;                    maxCntVal=i;                &#125;            &#125;        &#125;        for(auto num:nums)&#123;            if(num.second&gt;cnt/2)&#123;                median=num.first;                break;            &#125;        &#125;        if(cnt%2==0)&#123;            for(auto num:nums)&#123;                if(num.second&gt;=cnt/2)&#123;                    median=(median+num.first)/2;                    break;                &#125;            &#125;        &#125;        return &#123;minV,maxV,total/cnt,median,maxCntVal&#125;;    &#125;&#125;;\n2903. Find Indices With Index and Value Difference Iclass Solution &#123;public:    vector&lt;int&gt; findIndices(vector&lt;int&gt;&amp; nums, int indexDifference, int valueDifference) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            for(int j=i;j&lt;n;j++)&#123;                if(abs(i-j)&gt;=indexDifference&amp;&amp;abs(nums[i]-nums[j])&gt;=valueDifference)&#123;                    return &#123;i,j&#125;;                &#125;            &#125;        &#125;        return &#123;-1,-1&#125;;    &#125;&#125;;\n2904. Shortest and Lexicographically Smallest Beautiful Stringclass Solution &#123;public:    string chooseBetter(string a,string b)&#123;        if(a==&quot;&quot;)&#123;            return b;        &#125;        if(a.size()==b.size())&#123;            int n=a.size();            for(int i=0;i&lt;n;i++)&#123;                if(a[i]&gt;b[i])&#123;                    return b;                &#125;else if(a[i]&lt;b[i])&#123;                    return a;                &#125;            &#125;        &#125;else if(a.size()&gt;b.size())&#123;            return b;        &#125;        return a;    &#125;    string shortestBeautifulSubstring(string s, int k) &#123;        string ans=&quot;&quot;,now=&quot;&quot;;        int i=0,j=0,n=s.size(),cnt=0;        while(i&lt;n&amp;&amp;j&lt;n)&#123;            cnt+=(s[i]==&#x27;1&#x27;);            now+=s[i];            i++;            if(cnt==k)&#123;                if(now[0]==&#x27;1&#x27;)&#123;                    ans=chooseBetter(ans,now);                    cnt--;                    now.erase(0,1);                &#125;else&#123;                    while(now[0]==&#x27;0&#x27;)&#123;                        ans=chooseBetter(ans,now);                        now.erase(0,1);                    &#125;                    ans=chooseBetter(ans,now);                    cnt--;                    now.erase(0,1);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2905. Find Indices With Index and Value Difference IIclass Solution &#123;public:    vector&lt;int&gt; findIndices(vector&lt;int&gt;&amp; nums, int indexDifference, int valueDifference) &#123;        int minIdx=0,maxIdx=0,n=nums.size();        for(int i=indexDifference;i&lt;n;i++)&#123;            if(nums[i-indexDifference]&lt;nums[minIdx])&#123;                minIdx=i-indexDifference;            &#125;            if(nums[i-indexDifference]&gt;nums[maxIdx])&#123;                maxIdx=i-indexDifference;            &#125;            if(nums[i]-nums[minIdx]&gt;=valueDifference)&#123;                return &#123;minIdx,i&#125;;            &#125;            if(nums[maxIdx]-nums[i]&gt;=valueDifference)&#123;                return &#123;maxIdx,i&#125;;            &#125;        &#125;        return &#123;-1,-1&#125;;    &#125;&#125;;\n2906. Construct Product Matrixclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; constructProductMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n=grid.size(),m=grid[0].size(),mod=12345;        long long p=1;        vector&lt;vector&lt;int&gt;&gt; ans(n,vector&lt;int&gt;(m));        vector&lt;vector&lt;int&gt;&gt; totalX(n,vector&lt;int&gt;(m));        vector&lt;vector&lt;int&gt;&gt; totalY(n,vector&lt;int&gt;(m));        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                totalX[i][j]=p;                p=(p*grid[i][j])%mod;            &#125;        &#125;        p=1;        for(int i=n-1;i&gt;=0;i--)&#123;            for(int j=m-1;j&gt;=0;j--)&#123;                totalY[i][j]=p;                p=(p*grid[i][j])%mod;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                ans[i][j]=(totalX[i][j]*totalY[i][j])%mod;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n"},{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n安裝cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n如果要獨立裝driver，就把driver取消\ndriversudo apt-get install nvidia-driver-470\nHuggingface 金鑰申請請到huggingface官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n登入hugging face將訓練完成的模型上傳到存放在huggingface，可以減少本地端空間占用。Token請自行去huggingface申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n載入Openai建立好的模型使用openai提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n語料轉換取樣率音檔取樣率轉換成16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\ncompute_metrics計算CER(或WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n開始訓練trainer.train()\n從本地上傳模型到HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,     &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n從HuggingFace下載模型你需要更改要下載model的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n"},{"title":"Openai Whisper Fine-Tuning Script by FSR2023","url":"/2023/08/28/Openai-Whisper-Fine-Tuning-Script-by-FSR2023/","content":"連結Github\n重點專案結構whisper-hakka ┗┳━ custom_data  ┃   ┗━ data_prep.py 資料檢查、產生binary檔案  ┣━ data-char 放字單位的文本  ┃   ┣━ dev  ┃   ┃   ┣━ audio_paths symbolic link to wav.scp  ┃   ┃   ┣━ spk2utt 語者ID與其語料ID  ┃   ┃   ┣━ text    語料ID與語料文本  ┃   ┃   ┣━ utt2spk 語料ID與其語者ID  ┃   ┃   ┗━ wav.scp 語料ID與語料路徑  ┃   ┣━ test  ┃   ┃   ┗━ 同(dev)  ┃   ┗━ train  ┃       ┗━ 同(dev)  ┣━ data-pinyin 放詞單位的文本  ┃   ┗━ 同(data-char)  ┣━ evaluate  ┃   ┗━ evaluate_on_custom_dataset.py 驗證腳本  ┣━ train  ┃   ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本  ┃   ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本  ┣━ requirements.txt library套件  ┗━ run.sh 所有會執行的指令\n\n安裝虛擬環境建議用虛擬環境virtual environment建置python環境，可以避免原始套件衝突。\n# 建立虛擬環境# python3 -m venv name-of-venvpython3 -m venv env# 啟動虛擬環境source env/bin/activate\n當成功使用虛擬環境時，命令列左側會顯示在虛擬環境中。\n# beforeuser@SERVER:/path-to-project$# after(env) user@SERVER:/path-to-project$\n\n安裝Python套件python3 -m pip install --upgrade pippip install -r requirements.txt\n\n資料準備接著進行資料準備，所有集合都放在data-char底下，一個資料夾為一個集合。需準備的資料有：text\nID_1 text-in-ID_1ID_2 text-in-ID_2ID_3 text-in-ID_3\nwav.scp\nID_1 path-to-ID_1ID_2 path-to-ID_2ID_3 path-to-ID_3\n建議data-char放中文字的text(字為單位)，data-pinyin放英文字的text(詞為單位)。\n接下來可以使用run.sh內的指令進行驗證，執行後會在output_data_dir的地方放生成後的binary檔案。\npython3 custom_data/data_prep.py \\--source_data_dir path-to-your-location \\--output_data_dir path-to-your-data-locationEx:python3 custom_data/data_prep.py \\--source_data_dir data-pinyin/train \\--output_data_dir output_data-pinyin/train\n如果輸出Data preparation done代表沒問題，可以進行下一步。\n開始訓練資料準備完成後，即可進行訓練，可以執行以下指令(以字元為例)nproc_per_node為GPU數量\ntorchrun --nproc_per_node=1 train/fine-tune_on_custom_dataset.py \\--model_name openai/whisper-base \\  # 基礎模型--language zh \\ # 調適的語言--sampling_rate 16000 \\    # 取樣率--num_proc 4 \\             # 同時只用多少CPU核心執行取樣轉換，越快越好--train_strategy epoch \\   # 訓練週期單位(epoch/steps)--learning_rate 6.25e-6 \\  # 學習率--warmup 1000 \\--train_batchsize 12 \\  # 訓練batch--eval_batchsize 6 \\    # 驗證batch--num_epochs 20 \\       # 訓練週期數--resume_from_ckpt None \\--output_dir op_dir_epoch-char \\           # 輸出路徑資料夾名，記得修改，不然容易忘記--train_datasets output_data-char/train  \\ # 訓練集路徑--eval_datasets output_data-char/dev       # 驗證集路徑\n完成訓練後，可以透過終端上每個checkpoint的WER去評估哪個模型比較好。\n訓練好的模型資料結構(僅說明重點)以預設名op_dir_epoch-char舉例\nwhisper-hakka ┗━━ op_dir_epoch-char      ┣━ checkpoint-(num)      ┃   ┣━ config.json 參數檔      ┃   ┗━ pytorch_model.bin 模型      ┣━ 每個checkpoint資料夾內的檔案      ┗━ README.md 訓練狀態\n\n測試選擇好最好的checkpoint後，就可以進行測試看看該模型效果如何，通常checkpoint前3名都有機會有好的結果，不一定會是checkpoint最好的為最好模型。\npython3 evaluate/evaluate_on_custom_dataset.py \\--is_public_repo False \\ --ckpt_dir &quot;op_dir_epoch-char/checkpoint&quot; \\  # checkpoint路徑--temp_ckpt_folder &quot;temp-char&quot; \\         # 暫存位置--language zh \\                          # 語言--eval_datasets output_data-char/test \\  # 測試集路徑--device 0 \\--batch_size 8 \\                   # 測試batch--output_dir predictions_dir-char  # 測試後輸出檔案\n\n測試後即可跟去輸出的WER(詞錯誤率)與CER(字錯誤率)去選擇最好的模型。\n輸出模型此腳本並無提供模型輸出的指令，可以使用以下我寫的程式碼：\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;path-to-checkpoint&#x27;whisper_checkpoint_path = &#x27;model-name.pt&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n此方法生成的模型可以使用在python的whisper套件。\n"}]