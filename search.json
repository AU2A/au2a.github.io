[{"title":"LeetCode 2023/07/30","url":"/2023/08/06/LeetCode-2023-07-30/","content":"\n1394. Find Lucky Integer in an Arrayclass Solution &#123;public:    int findLucky(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(),arr.end(),greater&lt;int&gt;());        int now=arr[0],cnt=0;        for(auto a:arr)&#123;            if(a==now)&#123;                cnt++;            &#125;else&#123;                if(cnt==now)&#123;                    return cnt;                &#125;                now=a;                cnt=1;            &#125;        &#125;        if(cnt==arr.back())&#123;            return cnt;        &#125;        return -1;    &#125;&#125;;\n1332. Remove Palindromic Subsequencesclass Solution &#123;public:    int removePalindromeSub(string s) &#123;            string temp=s;            reverse(temp.begin(),temp.end());            if(s==&quot;&quot;)&#123;                return 0;            &#125;            else if(s==temp)&#123;                return 1;            &#125;            return 2;        &#125;&#125;;\n1281. Subtract the Product and Sum of Digits of an Integerclass Solution &#123;public:    int subtractProductAndSum(int n) &#123;        int pro=1,sum=0;        while(n&gt;0)&#123;            pro*=n%10;            sum+=n%10;            n/=10;        &#125;        return pro-sum;    &#125;&#125;;\n1013. Partition Array Into Three Parts With Equal Sumclass Solution &#123;public:    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; arr) &#123;        int n=arr.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)        &#125;    &#125;&#125;;\n2249. Count Lattice Points Inside a Circleclass Solution &#123;public:    int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123;        set&lt;pair&lt;int,int&gt;&gt; temp;        for(auto c:circles)&#123;            int midx=c[0],midy=c[1],r=c[2],r_sqr=c[2]*c[2];            for(int x=-r;x&lt;=r;x++)&#123;                for(int y=-r;y&lt;=r;y++)&#123;                    if(x*x+y*y&lt;=r_sqr)&#123;                        temp.insert(&#123;midx+x,midy+y&#125;);                    &#125;                &#125;            &#125;        &#125;        return temp.size();    &#125;&#125;;\n2256. Minimum Average Differenceclass Solution &#123;public:    int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123;        long long sum=0;        for(auto num:nums)&#123;            sum+=num;        &#125;        int n=nums.size();        long long now=0,minVal=1e5,minIdx=0,temp;        for(int i=0;i&lt;n-1;i++)&#123;            now+=nums[i];            sum-=nums[i];            temp=abs(now/(i+1)-sum/(n-i-1));            if(temp&lt;minVal)&#123;                minVal=temp;                minIdx=i;            &#125;        &#125;        if((now+nums[n-1])/n&lt;minVal)&#123;            minIdx=n-1;        &#125;        return minIdx;    &#125;&#125;;\n2788. Split Strings by Separatorclass Solution &#123;public:    vector&lt;string&gt; splitWordsBySeparator(vector&lt;string&gt;&amp; words, char separator) &#123;        vector&lt;string&gt; ans;        string temp;        for(auto word:words)&#123;            temp=&quot;&quot;;            for(auto c:word)&#123;                if(c==separator)&#123;                    if(temp!=&quot;&quot;)&#123;                        ans.push_back(temp);                        temp=&quot;&quot;;                    &#125;                &#125;else&#123;                    temp+=c;                &#125;            &#125;            if(temp!=&quot;&quot;)&#123;                ans.push_back(temp);            &#125;        &#125;        return ans;    &#125;&#125;;\n2789. Largest Element in an Array after Merge Operationsclass Solution &#123;public:    long long maxArrayValue(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;long long&gt; temp(n,0);        long long ans=nums[n-1];        temp[n-1]=nums[n-1];        for(int i=n-1;i&gt;0;i--)&#123;            temp[i-1]=nums[i-1];            if(nums[i-1]&lt;=temp[i])&#123;                temp[i-1]+=temp[i];            &#125;            ans=max(ans,temp[i-1]);        &#125;        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;temp[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        return ans;    &#125;&#125;;\n\n"},{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用Docker時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -p 443:443 -p 5002:5002 au2a/hakka-website\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址，一開始可以使用hakka.corelab.dev會導向到127.0.0.1-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\nwhisper解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每90天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n"},{"title":"LeetCode 2023/07/23","url":"/2023/07/23/LeetCode-2023-07-23/","content":"2656. Maximum Sum With Exactly K Elementsclass Solution &#123;public:    int maximizeSum(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());        int ans=0;        for(int i=0;i&lt;k;i++)&#123;            ans+=nums[0]+i;        &#125;        return ans;    &#125;&#125;;\n2475. Number of Unequal Triplets in Arrayclass Solution &#123;public:    int unequalTriplets(vector&lt;int&gt;&amp; nums) &#123;        int cnt=0;        int n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[i]!=nums[j])&#123;                    for(int k=j+1;k&lt;n;k++)&#123;                        if(nums[j]!=nums[k]&amp;&amp;nums[i]!=nums[k])&#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;;\n2558. Take Gifts From the Richest Pileclass Solution &#123;public:    long long pickGifts(vector&lt;int&gt;&amp; gifts, int k) &#123;        for(int i=0;i&lt;k;i++)&#123;            sort(gifts.begin(),gifts.end(),greater&lt;int&gt;());            gifts[0]=sqrt(gifts[0]);        &#125;        long long ans=0;        for(auto gift:gifts)&#123;            ans+=gift;        &#125;        return ans;    &#125;&#125;;\n2278. Percentage of Letter in Stringclass Solution &#123;public:    int percentageLetter(string s, char letter) &#123;        double cnt=0;        for(auto c:s)&#123;            cnt+=(c==letter);        &#125;        return cnt/s.size()*100;    &#125;&#125;;\n_275. H-Index IIclass Solution &#123;public:    int hIndex(vector&lt;int&gt;&amp; citations) &#123;        int n=citations.size();        int l=0,r=n-1,m;        while(l&lt;=r)&#123;            m=(r+l+1)/2;            if(citations[m]==n-m)&#123;                return n-m;            &#125;            else if(citations[m]&lt;n-m)&#123;                l=m+1;            &#125;            else&#123;                r=m-1;            &#125;        &#125;        return n-l;    &#125;&#125;;\n_227. Basic Calculator IIclass Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;        int now=0;        char sign=&#x27;+&#x27;;        for(int i=0;i&lt;s.size();i++)&#123;            if(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;)&#123;                now = 10*now + (s[i]-&#x27;0&#x27;);            &#125;            if(!(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;) &amp;&amp; s[i]!=&#x27; &#x27; || i==s.size()-1)&#123;                if(sign==&#x27;+&#x27;)&#123;                    st.push(now);                &#125;                else if(sign==&#x27;-&#x27;)&#123;                    st.push(-1*now);                &#125;                else&#123;                    int num;                    if(sign==&#x27;*&#x27;)&#123;                        num=st.top()*now;                    &#125;                    else&#123;                        num=st.top()/now;                    &#125;                    st.pop();                    st.push(num);                &#125;                sign=s[i];                now=0;             &#125;         &#125;        int sum = 0;        while(!st.empty())&#123;            sum+=st.top();            st.pop();        &#125;        return sum;    &#125;&#125;;\n2778. Sum of Squares of Special Elementsclass Solution &#123;public:    int sumOfSquares(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        int ans=0;        for(int i=0;i&lt;n;i++)&#123;            if(n%(i+1)==0)&#123;                ans+=nums[i]*nums[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n2779. Maximum Beauty of an Array After Applying Operationclass Solution &#123;public:    int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; temp(100001,0);        for(auto num:nums)&#123;            temp[num]++;        &#125;        int now=0;        for(int i=0;i&lt;min(2*k,100001);i++)&#123;            now+=temp[i];        &#125;        int ans=now;        for(int i=2*k;i&lt;100001;i++)&#123;            now+=temp[i];            ans=max(ans,now);            now-=temp[i-2*k];        &#125;        return ans;    &#125;&#125;;\n2780. Minimum Index of a Valid Splitclass Solution &#123;public:    int minimumIndex(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        vector&lt;pair&lt;int,int&gt;&gt; left(n);        vector&lt;pair&lt;int,int&gt;&gt; right(n);                unordered_map&lt;int, int&gt; rFreq;        int rNum=0,rCnt=0;        for(int i=n-1;i&gt;0;i--)&#123;            rFreq[nums[i]]++;            if(rFreq[nums[i]]&gt;rCnt)&#123;                rNum = nums[i];                rCnt=rFreq[nums[i]];            &#125;            right[i-1]=&#123;rNum,rCnt&#125;;        &#125;                unordered_map&lt;int, int&gt; freq;        int leftNum=0,leftCnt=0;        for (int i=0;i&lt;n-1;i++) &#123;            freq[nums[i]]++;            if(freq[nums[i]]&gt;leftCnt)&#123;                leftNum = nums[i];                leftCnt = freq[nums[i]];            &#125;                        if (leftNum==right[i].first) &#123;                if(leftCnt * 2 &gt; i+1 &amp;&amp; right[i].second * 2 &gt; (n-i-1))&#123;                    return i;                &#125;             &#125;        &#125;        return -1;    &#125;&#125;;"},{"title":"LeetCode 2023/08/13","url":"/2023/08/14/LeetCode-2023-08-13/","content":"\n_108. Convert Sorted Array to Binary Search Treeclass Solution &#123;public:    TreeNode* pushNode(vector&lt;int&gt;&amp; nums,int left,int right)&#123;        if(left&lt;=right)&#123;            int mid=(left+right)/2;            TreeNode* root = new TreeNode(nums[mid]);            root-&gt;left = pushNode(nums,left,mid-1);            root-&gt;right = pushNode(nums,mid+1,right);            return root;        &#125;        return nullptr;    &#125;    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return pushNode(nums,0,nums.size()-1);    &#125;&#125;;\n_303. Range Sum Query - Immutableclass NumArray &#123;public:    vector&lt;int&gt; temp;    NumArray(vector&lt;int&gt;&amp; nums) &#123;        temp.clear();        for(auto num:nums)&#123;            temp.push_back(num);        &#125;    &#125;        int sumRange(int left, int right) &#123;        int sum=0;        for(int i=left;i&lt;=right;i++)&#123;            sum+=temp[i];        &#125;        return sum;    &#125;&#125;;\n_202. Happy Numberclass Solution &#123;public:    bool isHappy(int n) &#123;        int temp=0;        for(int i=0;i&lt;20;i++)&#123;            temp=0;            while(n&gt;0)&#123;                temp+=(n%10)*(n%10);                n/=10;            &#125;            n=temp;            // cout&lt;&lt;n&lt;&lt;endl;        &#125;        return n==1;    &#125;&#125;;\n_232. Implement Queue using Stacksclass MyQueue &#123;public:    vector&lt;int&gt; temp;    MyQueue() &#123;        temp.clear();    &#125;        void push(int x) &#123;        temp.push_back(x);    &#125;        int pop() &#123;        int val=temp[0];        temp.erase(temp.begin());        return val;    &#125;        int peek() &#123;        return temp[0];    &#125;        bool empty() &#123;        return temp.size()==0;    &#125;&#125;;\n2162. Minimum Cost to Set Cooking Timeclass Solution &#123;public:    int pushNum(int startAt, int moveCost, int pushCost, int s)&#123;        int val=0;        stack&lt;int&gt; st;        while(s&gt;0)&#123;            st.push(s%10);            s/=10;        &#125;        while(!st.empty())&#123;            if(startAt!=st.top())&#123;                val+=moveCost;                startAt=st.top();            &#125;            val+=pushCost;            st.pop();        &#125;        return val;    &#125;    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) &#123;        int m=0,s=targetSeconds;        int ans=1e9;        while(s&gt;=100)&#123;            m+=1;            s-=60;        &#125;        while(s&gt;=0&amp;&amp;m&lt;100)&#123;            ans=min(ans,pushNum(startAt,moveCost,pushCost,m*100+s));            m+=1;            s-=60;        &#125;        return ans;    &#125;&#125;;\n2810. Faulty Keyboardclass Solution &#123;public:    string finalString(string s) &#123;        string temp=&quot;&quot;;        for(auto c:s)&#123;            if(c==&#x27;i&#x27;)&#123;                reverse(temp.begin(),temp.end());            &#125;else&#123;                temp+=c;            &#125;        &#125;        return temp;    &#125;&#125;;\n2811. Check if it is Possible to Split Arrayclass Solution &#123;public:    bool canSplitArray(vector&lt;int&gt;&amp; nums, int m) &#123;        for(int i=0;i&lt;nums.size()-1;i++)            if(nums[i]+nums[i+1]&gt;=m)&#123;                return true;            &#125;        return nums.size()&lt;3;    &#125;&#125;;\n2812. Find the Safest Path in a Grid```* 2813\\. [Maximum Elegance of a K-Length Subsequence](https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence/)```Cpp\n\n"},{"title":"Leetcode 2023/07/09","url":"/2023/07/11/Leetcode-2023-07-09/","content":"2418. Sort the Peopleclass Solution &#123;public:    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123;        int n=names.size();        vector&lt;pair&lt;int,string&gt;&gt; temp(n);        for(int i=0;i&lt;n;i++)&#123;            temp[i]=&#123;heights[i],names[i]&#125;;        &#125;        sort(temp.begin(),temp.end());        vector&lt;string&gt; ans(n);        for(int i=0;i&lt;n;i++)&#123;            ans[n-i-1]=temp[i].second;        &#125;        return ans;    &#125;&#125;;\n2437. Number of Valid Clock Timesclass Solution &#123;public:    int countTime(string time) &#123;        int ans=1;        if(time[0]==&#x27;?&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=24;            &#125;else if(time[1]&gt;=&#x27;4&#x27;)&#123;                ans*=2;            &#125;else&#123;                ans*=3;            &#125;        &#125;else if(time[0]==&#x27;2&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=4;            &#125;        &#125;else&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=10;            &#125;        &#125;        if(time[3]==&#x27;?&#x27;)&#123;            ans*=6;        &#125;        if(time[4]==&#x27;?&#x27;)&#123;            ans*=10;        &#125;        return ans;    &#125;&#125;;\n2383. Minimum Hours of Training to Win a Competitionclass Solution &#123;public:    int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123;        int n=energy.size();        int time=0;        for(int i=0;i&lt;n;i++)&#123;            if(initialEnergy&gt;energy[i])&#123;                initialEnergy-=energy[i];            &#125;else&#123;                time+=energy[i]-initialEnergy+1;                initialEnergy=1;            &#125;            if(initialExperience&gt;experience[i])&#123;                initialExperience+=experience[i];            &#125;else&#123;                time+=experience[i]-initialExperience+1;                initialExperience=2*experience[i]+1;            &#125;        &#125;        return time;    &#125;&#125;;\n2363. Merge Similar Itemsclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123;        vector&lt;int&gt; temp(1001);        for(auto item:items1)&#123;            temp[item[0]]+=item[1];        &#125;        for(auto item:items2)&#123;            temp[item[0]]+=item[1];        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;1001;i++)&#123;            if(temp[i]!=0)&#123;                ans.push_back(&#123;i,temp[i]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;\n2461. Maximum Sum of Distinct Subarrays With Length Kclass Solution &#123;public:    long long maximumSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; cnt(1e5+1);        int chk=0,n=nums.size();        long long sum=0,ans=0;        for(int i=0;i&lt;k-1;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;            &#125;        &#125;        for(int i=k-1;i&lt;n;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;                if(chk==k)&#123;                    ans=max(ans,sum);                &#125;            &#125;            cnt[nums[i-k+1]]--;            sum-=nums[i-k+1];            if(cnt[nums[i-k+1]]==0)&#123;                chk--;            &#125;        &#125;        return ans;    &#125;&#125;;\n2419. Longest Subarray With Maximum Bitwise ANDclass Solution &#123;public:    int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;        int x=*max_element(nums.begin(),nums.end());        int n=nums.size();        int temp=1,ans=1;        for(int i=0;i&lt;n-1;i++)&#123;            if(nums[i]==nums[i+1]&amp;&amp;nums[i]==x)&#123;                temp++;                ans=max(ans,temp);            &#125;else&#123;                temp=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2760. Longest Even Odd Subarray With Thresholdclass Solution &#123;public:    int longestAlternatingSubarray(vector&lt;int&gt;&amp; nums, int threshold) &#123;        int ans=0,cnt=1,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]%2==0&amp;&amp;nums[i]&lt;=threshold)&#123;                ans=max(ans,cnt);                for(int j=i+1;j&lt;n;j++)&#123;                    if(nums[j]&lt;=threshold&amp;&amp;nums[j]%2!=nums[j-1]%2)&#123;                        cnt++;                    &#125;else&#123;                        cnt=1;                        break;                    &#125;                    ans=max(ans,cnt);                &#125;                cnt=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2761. Prime Pairs With Target Sumclass Solution &#123;public:    bool isPrime(int v)&#123;        int s=sqrt(v);        for(int i=2;i&lt;=s;i++)&#123;            if(v%i==0)&#123;                return false;            &#125;        &#125;        return true;    &#125;    vector&lt;vector&lt;int&gt;&gt; findPrimePairs(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        if(n&lt;=2)&#123;            return ans;        &#125;                int x=3;        while(x&lt;=n/2)&#123;            if(isPrime(x))&#123;                if(isPrime(n-x))&#123;                    ans.push_back(&#123;x,n-x&#125;);                &#125;            &#125;            x+=2;        &#125;        return ans;    &#125;&#125;;"},{"title":"LeetCode 2023/07/16","url":"/2023/07/17/LeetCode-2023-07-16/","content":"_557. Reverse Words in a String IIIclass Solution &#123;public:    string reverseWords(string s) &#123;        string ans=&quot;&quot;,temp=&quot;&quot;;        for(auto c:s)&#123;            if(c!=&#x27; &#x27;)&#123;                temp=c+temp;            &#125;else&#123;                if(ans==&quot;&quot;)&#123;                    ans=temp;                &#125;else&#123;                    ans+=&quot; &quot;+temp;                &#125;                temp=&quot;&quot;;            &#125;        &#125;        if(ans==&quot;&quot;)&#123;            ans=temp;        &#125;else&#123;            ans+=&quot; &quot;+temp;        &#125;        return ans;    &#125;&#125;;\n_345. Reverse Vowels of a Stringclass Solution &#123;public:    string reverseVowels(string s) &#123;        string ans;        int n=s.size();        int left=n-1;        for(int i=0;i&lt;n;i++)&#123;            if(s[i]==&#x27;a&#x27;||s[i]==&#x27;e&#x27;||s[i]==&#x27;i&#x27;||s[i]==&#x27;o&#x27;||s[i]==&#x27;u&#x27;||s[i]==&#x27;A&#x27;||s[i]==&#x27;E&#x27;||s[i]==&#x27;I&#x27;||s[i]==&#x27;O&#x27;||s[i]==&#x27;U&#x27;)&#123;                while(s[left]!=&#x27;a&#x27;&amp;&amp;s[left]!=&#x27;e&#x27;&amp;&amp;s[left]!=&#x27;i&#x27;&amp;&amp;s[left]!=&#x27;o&#x27;&amp;&amp;s[left]!=&#x27;u&#x27;&amp;&amp;s[left]!=&#x27;A&#x27;&amp;&amp;s[left]!=&#x27;E&#x27;&amp;&amp;s[left]!=&#x27;I&#x27;&amp;&amp;s[left]!=&#x27;O&#x27;&amp;&amp;s[left]!=&#x27;U&#x27;)&#123;                    left--;                &#125;                ans+=s[left];                left--;            &#125;else&#123;                ans+=s[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n_463. Island Perimeterclass Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int x=grid.size(),y=grid[0].size();        int ans=0;        bool chk=false;        for(int i=0;i&lt;x;i++)&#123;            chk=false;            for(int j=0;j&lt;y;j++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[i][y-1]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        for(int j=0;j&lt;y;j++)&#123;            chk=false;            for(int i=0;i&lt;x;i++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[x-1][j]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        return ans;    &#125;&#125;;\n_160. Intersection of Two Linked Listsclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *temp=headA;        vector&lt;int*&gt; A,B;        while(headA!=NULL)&#123;            A.push_back(&amp;headA-&gt;val);            headA=headA-&gt;next;        &#125;        while(headB!=NULL)&#123;            B.push_back(&amp;headB-&gt;val);            headB=headB-&gt;next;        &#125;        int n=A.size(),m=B.size();        int idx;        int chk=false;        for(idx=1;idx&lt;=min(n,m);idx++)&#123;            if(A[n-idx]!=B[m-idx])&#123;                chk=true;                break;            &#125;        &#125;        if(idx&gt;min(n,m)&amp;&amp;chk)&#123;            return NULL;        &#125;else&#123;            for(int i=0;i&lt;=n-idx;i++)&#123;                temp=temp-&gt;next;            &#125;            return temp;        &#125;    &#125;&#125;;\n___6. Zigzag Conversionclass Solution &#123;public:    string convert(string s, int numRows) &#123;        if(numRows==1)&#123;            return s;        &#125;        vector&lt;vector&lt;char&gt;&gt; temp(numRows,vector&lt;char&gt;(1000,&#x27; &#x27;));        bool up=false;        int i=0,j=0;        for(char c:s)&#123;            temp[i][j]=c;            if(up)&#123;                i--;                j++;                if(i==0)&#123;                    up=false;                &#125;            &#125;else&#123;                i++;                if(i==numRows)&#123;                    up=true;                    i-=2;                    j++;                    if(i==0)&#123;                        up=false;                    &#125;                &#125;            &#125;        &#125;        string ans;        for(int ii=0;ii&lt;numRows;ii++)&#123;            for(int jj=0;jj&lt;j+1;jj++)&#123;                if(temp[ii][jj]!=&#x27; &#x27;)&#123;                    ans+=temp[ii][jj];                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n1366. Rank Teams by Votesclass Solution &#123;public:    static bool cmp(pair&lt;char,vector&lt;int&gt;&gt; a, pair&lt;char,vector&lt;int&gt;&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a.second[i]!=b.second[i])&#123;                return a.second[i]&gt;b.second[i];            &#125;        &#125;        return a.first&lt;b.first;    &#125;    string rankTeams(vector&lt;string&gt;&amp; votes) &#123;        vector&lt;pair&lt;char,vector&lt;int&gt;&gt;&gt; temp(26,&#123;&#x27; &#x27;,vector&lt;int&gt;(26,0)&#125;);        for(auto c:votes[0])&#123;            temp[c-&#x27;A&#x27;].first=c;        &#125;        int voteSize=votes[0].size();        for(auto vote:votes)&#123;            for(int i=0;i&lt;voteSize;i++)&#123;                temp[vote[i]-&#x27;A&#x27;].second[i]++;            &#125;        &#125;        sort(temp.begin(),temp.end(),cmp);        string ans=&quot;&quot;;        for(auto t:temp)&#123;            if(t.first!=&#x27; &#x27;)&#123;                ans+=t.first;            &#125;        &#125;        return ans;    &#125;&#125;;\n2769. Find the Maximum Achievable Numberclass Solution &#123;public:    int theMaximumAchievableX(int num, int t) &#123;        return num+2*t;    &#125;&#125;;\n6899. Maximum Number of Jumps to Reach the Last Indexclass Solution &#123;public:    int maximumJumps(vector&lt;int&gt;&amp; nums, int target) &#123;        int n=nums.size();        vector&lt;int&gt; distance(n,-2);        distance[0]=0;        for(int i=1;i&lt;n;i++)&#123;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(nums[j]-nums[i])&lt;=target&amp;&amp;distance[j]&gt;=0)&#123;                    distance[i]=max(distance[i],distance[j]);                &#125;            &#125;            distance[i]++;        &#125;        return distance[n-1];    &#125;&#125;;\n6912. Longest Non-decreasing Subarray From Two Arraysclass Solution &#123;public:    int maxNonDecreasingLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int n=nums1.size();        vector&lt;int&gt; nums1c(n,1);        vector&lt;int&gt; nums2c(n,1);        int now=0;        int ans=1;        for(int i=1;i&lt;n;i++)&#123;            if(nums2[i-1]&lt;=nums2[i])&#123;                nums2c[i]=nums2c[i-1]+1;            &#125;            if(nums1[i-1]&lt;=nums2[i])&#123;                nums2c[i]=max(nums1c[i-1]+1,nums2c[i]);            &#125;            if(nums1[i-1]&lt;=nums1[i])&#123;                nums1c[i]=nums1c[i-1]+1;            &#125;            if(nums2[i-1]&lt;=nums1[i])&#123;                nums1c[i]=max(nums2c[i-1]+1,nums1c[i]);            &#125;            ans=max(ans,max(nums1c[i],nums2c[i]));        &#125;        return ans;    &#125;&#125;;"},{"title":"Leetcode 2023/07/02","url":"/2023/07/03/Leetcode-2023-07-02/","content":"1232. Check If It Is a Straight Lineclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        int x1=coordinates[0][0],y1=coordinates[0][1];        int diffx=coordinates[1][0]-coordinates[0][0];        int diffy=coordinates[1][1]-coordinates[0][1];        for(auto c:coordinates)&#123;            if(diffx*(c[1]-y1)!=diffy*(c[0]-x1))&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n1071. Greatest Common Divisor of Stringsclass Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        string now,ans=&quot;&quot;,longString,shortString;        if(str1.size()&lt;str2.size())&#123;            longString=str2;            shortString=str1;        &#125;        else&#123;            longString=str1;            shortString=str2;        &#125;        bool chk;        for(auto c:shortString)&#123;            now+=c;            chk=true;            for(int i=0;i&lt;shortString.size();i+=now.size())&#123;                if(shortString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(shortString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            for(int i=0;i&lt;longString.size();i+=now.size())&#123;                if(longString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(longString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            if(chk&amp;&amp;longString.size()%now.size()==0&amp;&amp;shortString.size()%now.size()==0)&#123;                // cout&lt;&lt;now&lt;&lt;endl;                 ans=now;            &#125;            // cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n1160. Find Words That Can Be Formed by Charactersclass Solution &#123;public:    bool checkCount(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a[i]&lt;b[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;        int ans=0;        vector&lt;int&gt; target(26);        for(auto c:chars)&#123;            target[c-&#x27;a&#x27;]++;        &#125;        for(auto word:words)&#123;            vector&lt;int&gt; temp(26);            for(auto c:word)&#123;                temp[c-&#x27;a&#x27;]++;            &#125;            if(checkCount(target,temp))&#123;                ans+=word.size();            &#125;        &#125;        return ans;    &#125;&#125;;\n1323. Maximum 69 Numberclass Solution &#123;public:    int maximum69Number (int num) &#123;        int ans=num;        int temp=num;        for(int i=1;temp&gt;0;i++)&#123;            if(temp%10==6)&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+9*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;else&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+6*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n_858. Mirror Reflectionclass Solution &#123;public:    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int mirrorReflection(int p, int q) &#123;        int ap=p/gcd(p,q);        int aq=q/gcd(p,q);        if(ap==aq)&#123;            return 1;        &#125;        int sum=0,cnt=1;        while(aq*cnt%ap!=0)&#123;            cnt++;        &#125;        if(cnt%2==0)&#123;            return 2;        &#125;else if(aq%2==0)&#123;            return 0;        &#125;else&#123;            return 1;        &#125;        return 0;    &#125;&#125;;\n_946. Validate Stack Sequencesclass Solution &#123;public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;        stack&lt;int&gt; s;        int idxPush=0,idxPop=0,n=popped.size();        for(auto push_val:pushed)&#123;            s.push(push_val);            while(!s.empty()&amp;&amp;idxPop&lt;n)&#123;               if(s.top()==popped[idxPop])&#123;                   s.pop();                   idxPop++;               &#125;else&#123;                   break;               &#125;            &#125;        &#125;        return idxPop==n;    &#125;&#125;;\n2748. Number of Beautiful Pairsclass Solution &#123;public:    int first_digit(int a)&#123;        while(a&gt;=10)&#123;            a/=10;        &#125;        return a;    &#125;    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int countBeautifulPairs(vector&lt;int&gt;&amp; nums) &#123;        int ans=0;        int n=nums.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(gcd(first_digit(nums[i]),nums[j]%10)==1)&#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2750. Ways to Split Array Into Good Subarraysclass Solution &#123;public:    int numberOfGoodSubarraySplits(vector&lt;int&gt;&amp; nums) &#123;        int MOD=1e9+7;        int n=nums.size();        int temp=1;        long long int ans=1;        int i;        bool allz=true;        for(i=0;i&lt;n;i++)&#123;            if(nums[i]==1)&#123;                allz=false;                break;            &#125;        &#125;        if(allz)&#123;            return 0;        &#125;        for(i=i+1;i&lt;n;i++)&#123;            if(nums[i])&#123;                ans=(ans*temp)%MOD;                temp=1;            &#125;else&#123;                temp++;            &#125;        &#125;        return ans;    &#125;&#125;;"},{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n安裝cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n如果要獨立裝driver，就把driver取消\ndriversudo apt-get install nvidia-driver-470\nHuggingface 金鑰申請請到huggingface官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n登入hugging face將訓練完成的模型上傳到存放在huggingface，可以減少本地端空間占用。Token請自行去huggingface申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n載入Openai建立好的模型使用openai提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n語料轉換取樣率音檔取樣率轉換成16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\ncompute_metrics計算CER(或WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n開始訓練trainer.train()\n從本地上傳模型到HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,     &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n從HuggingFace下載模型你需要更改要下載model的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n"}]