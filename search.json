[{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n安裝cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n如果要獨立裝driver，就把driver取消\ndriversudo apt-get install nvidia-driver-470\nHuggingface 金鑰申請請到huggingface官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n登入hugging face將訓練完成的模型上傳到存放在huggingface，可以減少本地端空間占用。Token請自行去huggingface申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n載入Openai建立好的模型使用openai提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n語料轉換取樣率音檔取樣率轉換成16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\ncompute_metrics計算CER(或WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n開始訓練trainer.train()\n從本地上傳模型到HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,     &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n從HuggingFace下載模型你需要更改要下載model的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n"},{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用Docker時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -p 443:443 -p 5002:5002 au2a/hakka-website\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址，一開始可以使用hakka.corelab.dev會導向到127.0.0.1-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\nwhisper解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每90天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n"},{"title":"Leetcode 2023/07/02","url":"/2023/07/03/Leetcode-2023-07-02/","content":"1232. Check If It Is a Straight Lineclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        int x1=coordinates[0][0],y1=coordinates[0][1];        int diffx=coordinates[1][0]-coordinates[0][0];        int diffy=coordinates[1][1]-coordinates[0][1];        for(auto c:coordinates)&#123;            if(diffx*(c[1]-y1)!=diffy*(c[0]-x1))&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n1071. Greatest Common Divisor of Stringsclass Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        string now,ans=&quot;&quot;,longString,shortString;        if(str1.size()&lt;str2.size())&#123;            longString=str2;            shortString=str1;        &#125;        else&#123;            longString=str1;            shortString=str2;        &#125;        bool chk;        for(auto c:shortString)&#123;            now+=c;            chk=true;            for(int i=0;i&lt;shortString.size();i+=now.size())&#123;                if(shortString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(shortString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            for(int i=0;i&lt;longString.size();i+=now.size())&#123;                if(longString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(longString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            if(chk&amp;&amp;longString.size()%now.size()==0&amp;&amp;shortString.size()%now.size()==0)&#123;                // cout&lt;&lt;now&lt;&lt;endl;                 ans=now;            &#125;            // cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n1160. Find Words That Can Be Formed by Charactersclass Solution &#123;public:    bool checkCount(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a[i]&lt;b[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;        int ans=0;        vector&lt;int&gt; target(26);        for(auto c:chars)&#123;            target[c-&#x27;a&#x27;]++;        &#125;        for(auto word:words)&#123;            vector&lt;int&gt; temp(26);            for(auto c:word)&#123;                temp[c-&#x27;a&#x27;]++;            &#125;            if(checkCount(target,temp))&#123;                ans+=word.size();            &#125;        &#125;        return ans;    &#125;&#125;;\n1323. Maximum 69 Numberclass Solution &#123;public:    int maximum69Number (int num) &#123;        int ans=num;        int temp=num;        for(int i=1;temp&gt;0;i++)&#123;            if(temp%10==6)&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+9*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;else&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+6*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n_858. Mirror Reflectionclass Solution &#123;public:    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int mirrorReflection(int p, int q) &#123;        int ap=p/gcd(p,q);        int aq=q/gcd(p,q);        if(ap==aq)&#123;            return 1;        &#125;        int sum=0,cnt=1;        while(aq*cnt%ap!=0)&#123;            cnt++;        &#125;        if(cnt%2==0)&#123;            return 2;        &#125;else if(aq%2==0)&#123;            return 0;        &#125;else&#123;            return 1;        &#125;        return 0;    &#125;&#125;;\n_946. Validate Stack Sequencesclass Solution &#123;public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;        stack&lt;int&gt; s;        int idxPush=0,idxPop=0,n=popped.size();        for(auto push_val:pushed)&#123;            s.push(push_val);            while(!s.empty()&amp;&amp;idxPop&lt;n)&#123;               if(s.top()==popped[idxPop])&#123;                   s.pop();                   idxPop++;               &#125;else&#123;                   break;               &#125;            &#125;        &#125;        return idxPop==n;    &#125;&#125;;\n2748. Number of Beautiful Pairsclass Solution &#123;public:    int first_digit(int a)&#123;        while(a&gt;=10)&#123;            a/=10;        &#125;        return a;    &#125;    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int countBeautifulPairs(vector&lt;int&gt;&amp; nums) &#123;        int ans=0;        int n=nums.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(gcd(first_digit(nums[i]),nums[j]%10)==1)&#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n2750. Ways to Split Array Into Good Subarraysclass Solution &#123;public:    int numberOfGoodSubarraySplits(vector&lt;int&gt;&amp; nums) &#123;        int MOD=1e9+7;        int n=nums.size();        int temp=1;        long long int ans=1;        int i;        bool allz=true;        for(i=0;i&lt;n;i++)&#123;            if(nums[i]==1)&#123;                allz=false;                break;            &#125;        &#125;        if(allz)&#123;            return 0;        &#125;        for(i=i+1;i&lt;n;i++)&#123;            if(nums[i])&#123;                ans=(ans*temp)%MOD;                temp=1;            &#125;else&#123;                temp++;            &#125;        &#125;        return ans;    &#125;&#125;;"},{"title":"Leetcode 2023/07/09","url":"/2023/07/11/Leetcode-2023-07-09/","content":"2418. Sort the Peopleclass Solution &#123;public:    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123;        int n=names.size();        vector&lt;pair&lt;int,string&gt;&gt; temp(n);        for(int i=0;i&lt;n;i++)&#123;            temp[i]=&#123;heights[i],names[i]&#125;;        &#125;        sort(temp.begin(),temp.end());        vector&lt;string&gt; ans(n);        for(int i=0;i&lt;n;i++)&#123;            ans[n-i-1]=temp[i].second;        &#125;        return ans;    &#125;&#125;;\n2437. Number of Valid Clock Timesclass Solution &#123;public:    int countTime(string time) &#123;        int ans=1;        if(time[0]==&#x27;?&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=24;            &#125;else if(time[1]&gt;=&#x27;4&#x27;)&#123;                ans*=2;            &#125;else&#123;                ans*=3;            &#125;        &#125;else if(time[0]==&#x27;2&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=4;            &#125;        &#125;else&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=10;            &#125;        &#125;        if(time[3]==&#x27;?&#x27;)&#123;            ans*=6;        &#125;        if(time[4]==&#x27;?&#x27;)&#123;            ans*=10;        &#125;        return ans;    &#125;&#125;;\n2383. Minimum Hours of Training to Win a Competitionclass Solution &#123;public:    int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123;        int n=energy.size();        int time=0;        for(int i=0;i&lt;n;i++)&#123;            if(initialEnergy&gt;energy[i])&#123;                initialEnergy-=energy[i];            &#125;else&#123;                time+=energy[i]-initialEnergy+1;                initialEnergy=1;            &#125;            if(initialExperience&gt;experience[i])&#123;                initialExperience+=experience[i];            &#125;else&#123;                time+=experience[i]-initialExperience+1;                initialExperience=2*experience[i]+1;            &#125;        &#125;        return time;    &#125;&#125;;\n2363. Merge Similar Itemsclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123;        vector&lt;int&gt; temp(1001);        for(auto item:items1)&#123;            temp[item[0]]+=item[1];        &#125;        for(auto item:items2)&#123;            temp[item[0]]+=item[1];        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;1001;i++)&#123;            if(temp[i]!=0)&#123;                ans.push_back(&#123;i,temp[i]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;\n2461. Maximum Sum of Distinct Subarrays With Length Kclass Solution &#123;public:    long long maximumSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; cnt(1e5+1);        int chk=0,n=nums.size();        long long sum=0,ans=0;        for(int i=0;i&lt;k-1;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;            &#125;        &#125;        for(int i=k-1;i&lt;n;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;                if(chk==k)&#123;                    ans=max(ans,sum);                &#125;            &#125;            cnt[nums[i-k+1]]--;            sum-=nums[i-k+1];            if(cnt[nums[i-k+1]]==0)&#123;                chk--;            &#125;        &#125;        return ans;    &#125;&#125;;\n2419. Longest Subarray With Maximum Bitwise ANDclass Solution &#123;public:    int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;        int x=*max_element(nums.begin(),nums.end());        int n=nums.size();        int temp=1,ans=1;        for(int i=0;i&lt;n-1;i++)&#123;            if(nums[i]==nums[i+1]&amp;&amp;nums[i]==x)&#123;                temp++;                ans=max(ans,temp);            &#125;else&#123;                temp=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2760. Longest Even Odd Subarray With Thresholdclass Solution &#123;public:    int longestAlternatingSubarray(vector&lt;int&gt;&amp; nums, int threshold) &#123;        int ans=0,cnt=1,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]%2==0&amp;&amp;nums[i]&lt;=threshold)&#123;                ans=max(ans,cnt);                for(int j=i+1;j&lt;n;j++)&#123;                    if(nums[j]&lt;=threshold&amp;&amp;nums[j]%2!=nums[j-1]%2)&#123;                        cnt++;                    &#125;else&#123;                        cnt=1;                        break;                    &#125;                    ans=max(ans,cnt);                &#125;                cnt=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n2761. Prime Pairs With Target Sumclass Solution &#123;public:    bool isPrime(int v)&#123;        int s=sqrt(v);        for(int i=2;i&lt;=s;i++)&#123;            if(v%i==0)&#123;                return false;            &#125;        &#125;        return true;    &#125;    vector&lt;vector&lt;int&gt;&gt; findPrimePairs(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        if(n&lt;=2)&#123;            return ans;        &#125;                int x=3;        while(x&lt;=n/2)&#123;            if(isPrime(x))&#123;                if(isPrime(n-x))&#123;                    ans.push_back(&#123;x,n-x&#125;);                &#125;            &#125;            x+=2;        &#125;        return ans;    &#125;&#125;;"}]