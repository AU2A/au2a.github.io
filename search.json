[{"title":"HakkaASR Website","url":"/2023/06/28/HakkaASR-Website/","content":"連結DockerGithub\nDocker 執行使用 Docker 時，可以使用以下指令：\ndocker run -d -e psw=a_string -e domain=a_domain \\        -e port1=5001 -e port2=5002 \\        -p 5001:443 -p 5002:5002 au2a/hakka-website\n\npsw為密碼，需要密碼才能執行，如需要請向我詢問。domain為網址，設定網頁使用的網址port1為外部的網頁 portport2為外部的解碼用 port\n-p 443:443網頁使用的是https通道-p 5002:5002網頁解碼使用的通道\n專案結構files ┗┳━ decode  ┃   ┗━ espnet解碼後的文本  ┣━ initFiles  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案  ┣━ keys  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案  ┣━ openai  ┃   ┣━ decode  ┃   ┃   ┗━openai whisper解碼後的文本  ┃   ┣━ model  ┃   ┃   ┗━openai whisper使用的model  ┃   ┣━ upload  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本  ┃   ┣━ download.py 下載youtube檔案轉wav檔  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式  ┣━ upload  ┃   ┗━ 上傳espnet解碼的音檔存放區  ┣━ views  ┃   ┗━ 網頁  ┣━ website  ┃   ┣━ demo  ┃   ┃   ┗━範例音檔與文本  ┃   ┣━ files  ┃   ┃   ┗━網頁主題、網頁JS程式碼  ┃   ┗━ server.js 伺服器主程式  ┣━ aidecodeList.txt 待whisper解碼清單  ┣━ decodeList.txt 待espnet解碼清單  ┣━ domainName 網址  ┣━ init.py 初始化  ┣━ run.sh docker用啟動執行檔  ┗━ test.sh 測試用啟動執行檔\n\n執行全部執行如果要在本地端執行，請執行test.sh\n# 將hakka.corelab.dev文字放入domainNameecho &quot;hakka.corelab.dev&quot; &gt; domainName# 初始化所有檔案python3 init.py# 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/openai_whisper.py &amp; python3 openai/delete.py &amp; node website/server.js\n\n分開執行請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行執行網頁前，需先安裝網頁需要的套件請先到website/底下安裝\n~/Hakka_Website/website$ npm install\n\n在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js\n\nwhisper 解碼執行~/Hakka_Website$ python3 openai/openai_whisper.py\n\n安全憑證因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。我是使用LetsEncrypt的安全憑證，每 90 天需要重新申請一次。參考網站請將申請後的安全憑證檔案放到keys/底下即可運作網頁。檔案有三：cert.pem, chain.pem, privkey.pem\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning - Hakka","url":"/2023/07/04/Openai-Whisper-Fine-Tuning-Hakka/","content":"連結Github\n重點專案結構whisper_hakka ┗┳━ audio  ┃   ┣━ test  ┃   ┃   ┗━ test語料存放區  ┃   ┣━ train  ┃   ┃   ┗━ train語料存放區  ┃   ┗━ metadata.csv 檔案路徑與文本內容  ┣━ model  ┃   ┗━ 模型存放區  ┣━ fine_tune.ipynb jupyter訓練腳本  ┗━ huggingface_token huggingfacer金鑰\n\n安裝 cudacudawget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.runsudo sh cuda_11.4.0_470.42.01_linux.run\n\n如果要獨立裝 driver，就把 driver 取消\ndriversudo apt-get install nvidia-driver-470\n\nHuggingface 金鑰申請請到huggingface 官網右上的選項 → Settings → Access Tokens點選New token，Name自訂，Role選writeGenerate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明建立模型名稱請輸入檔案名稱\nmodel_name=&#x27;model name&#x27;\n\n登入 hugging face將訓練完成的模型上傳到存放在 huggingface，可以減少本地端空間占用。Token請自行去 huggingface 申請\nfrom huggingface_hub.hf_api import HfFoldertoken=open(&#x27;huggingface_token&#x27;,&#x27;r&#x27;).readlines()[0].split(&#x27;\\n&#x27;)[0]HfFolder.save_token(token)\n\n載入音檔資料會從data_dir底下拉語料進行使用\nfrom datasets import load_datasetcommon_voice = load_dataset(&quot;./&quot;, data_dir=&quot;audio&quot;,use_auth_token=True)# 可以使用以下程式碼查看dataset結構print(common_voice)\n\n載入 Openai 建立好的模型使用 openai 提供的基礎模型，模型大小或語言，請自行更換\nfrom transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessorfeature_extractor = WhisperFeatureExtractor.from_pretrained(&quot;openai/whisper-base&quot;)tokenizer = WhisperTokenizer.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)processor = WhisperProcessor.from_pretrained(&quot;openai/whisper-base&quot;, language=&quot;zh&quot;, task=&quot;transcribe&quot;)\n\n語料轉換取樣率音檔取樣率轉換成 16000HkHz\nfrom datasets import Audiocommon_voice = common_voice.cast_column(&quot;audio&quot;, Audio(sampling_rate=16000))def prepare_dataset(batch):    audio = batch[&quot;audio&quot;]    batch[&quot;input_features&quot;] = feature_extractor(audio[&quot;array&quot;], sampling_rate=audio[&quot;sampling_rate&quot;]).input_features[0]    batch[&quot;labels&quot;] = tokenizer(batch[&quot;sentence&quot;]).input_ids    return batchcommon_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[&quot;train&quot;], num_proc=2)\n\ndata_collatorimport torchfrom dataclasses import dataclassfrom typing import Any, Dict, List, Union@dataclassclass DataCollatorSpeechSeq2SeqWithPadding:    processor: Any    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -&gt; Dict[str, torch.Tensor]:        # split inputs and labels since they have to be of different lengths and need different padding methods        # first treat the audio inputs by simply returning torch tensors        input_features = [&#123;&quot;input_features&quot;: feature[&quot;input_features&quot;]&#125; for feature in features]        batch = self.processor.feature_extractor.pad(input_features, return_tensors=&quot;pt&quot;)        # get the tokenized label sequences        label_features = [&#123;&quot;input_ids&quot;: feature[&quot;labels&quot;]&#125; for feature in features]        # pad the labels to max length        labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=&quot;pt&quot;)        # replace padding with -100 to ignore loss correctly        labels = labels_batch[&quot;input_ids&quot;].masked_fill(labels_batch.attention_mask.ne(1), -100)        # if bos token is appended in previous tokenization step,        # cut bos token here as it&#x27;s append later anyways        if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item():            labels = labels[:, 1:]        batch[&quot;labels&quot;] = labels        return batchdata_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor)\n\ncompute_metrics計算 CER(或 WER)\nimport evaluatemetric = evaluate.load(&quot;cer&quot;)def compute_metrics(pred):    pred_ids = pred.predictions    label_ids = pred.label_ids    # replace -100 with the pad_token_id    label_ids[label_ids == -100] = tokenizer.pad_token_id    # we do not want to group tokens when computing the metrics    pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True)    label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True)    cer = 100 * metric.compute(predictions=pred_str, references=label_str)    return &#123;&quot;cer&quot;: cer&#125;\n\nmodelfrom transformers import WhisperForConditionalGenerationmodel = WhisperForConditionalGeneration.from_pretrained(&quot;openai/whisper-base&quot;)model.config.forced_decoder_ids = Nonemodel.config.suppress_tokens = []\n\ntraining_argsfrom transformers import Seq2SeqTrainingArgumentstraining_args = Seq2SeqTrainingArguments(    output_dir=&quot;./model_name&quot;, # 模型名稱，你需要更改    per_device_train_batch_size=16, # 批次大小，你可能會需要調整    gradient_accumulation_steps=1,    learning_rate=1e-5, # 學習率，你可能會需要調整    warmup_steps=500,    max_steps=4000, # 訓練次數，你可能會需要調整    gradient_checkpointing=True,    fp16=True,    evaluation_strategy=&quot;steps&quot;,    per_device_eval_batch_size=8,    predict_with_generate=True,    generation_max_length=225,    save_steps=1000,    eval_steps=1000,    logging_steps=25,    report_to=[&quot;tensorboard&quot;],    load_best_model_at_end=True,    metric_for_best_model=&quot;cer&quot;,    greater_is_better=False,    push_to_hub=True,)\n\ntrainerfrom transformers import Seq2SeqTrainertrainer = Seq2SeqTrainer(    args=training_args,    model=model,    train_dataset=common_voice[&quot;train&quot;],    eval_dataset=common_voice[&quot;test&quot;],    data_collator=data_collator,    compute_metrics=compute_metrics,    tokenizer=processor.feature_extractor,)processor.save_pretrained(training_args.output_dir)\n\n開始訓練trainer.train()\n\n從本地上傳模型到 HuggingFacekwargs = &#123;    &quot;dataset_tags&quot;: &quot;-&quot;,    &quot;dataset&quot;: &quot;some hakka audio&quot;,  # 輸入資料及名稱    &quot;dataset_args&quot;: &quot;config: zh, split: test&quot;,    &quot;language&quot;: &quot;zh&quot;,    &quot;model_name&quot;: &quot;a name&quot;,  # 輸入模型名稱    &quot;finetuned_from&quot;: &quot;openai/whisper-base&quot;, # 基礎模型    &quot;tasks&quot;: &quot;automatic-speech-recognition&quot;,    &quot;tags&quot;: &quot;whisper&quot;,&#125;trainer.push_to_hub(**kwargs)\n\n從 HuggingFace 下載模型你需要更改要下載 model 的位置與存放位置\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;model_name_on_hugging_face&#x27;whisper_checkpoint_path = &#x27;save_model_path&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\nreferencehttps://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoyhttps://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5https://huggingface.co/jlondonobo/whisper-medium-pthttps://github.com/bayartsogt-ya/whisper-multiple-hf-datasetshttps://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynbhttps://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-filehttps://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWzhttps://huggingface.co/spaces/openai/whisper/discussions/6https://huggingface.co/blog/fine-tune-whisperhttps://github.com/openai/whisper/discussions/98\n","categories":["HakkaASR"]},{"title":"Openai Whisper Fine-Tuning Script by FSR2023","url":"/2023/08/28/Openai-Whisper-Fine-Tuning-Script-by-FSR2023/","content":"連結Github\n重點專案結構whisper-hakka ┗┳━ custom_data  ┃   ┗━ data_prep.py 資料檢查、產生binary檔案  ┣━ data-char 放字單位的文本  ┃   ┣━ dev  ┃   ┃   ┣━ audio_paths symbolic link to wav.scp  ┃   ┃   ┣━ spk2utt 語者ID與其語料ID  ┃   ┃   ┣━ text    語料ID與語料文本  ┃   ┃   ┣━ utt2spk 語料ID與其語者ID  ┃   ┃   ┗━ wav.scp 語料ID與語料路徑  ┃   ┣━ test  ┃   ┃   ┗━ 同(dev)  ┃   ┗━ train  ┃       ┗━ 同(dev)  ┣━ data-pinyin 放詞單位的文本  ┃   ┗━ 同(data-char)  ┣━ evaluate  ┃   ┗━ evaluate_on_custom_dataset.py 驗證腳本  ┣━ train  ┃   ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本  ┃   ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本  ┣━ requirements.txt library套件  ┗━ run.sh 所有會執行的指令\n\n安裝虛擬環境建議用虛擬環境 virtual environment 建置 python 環境，可以避免原始套件衝突。\n# 建立虛擬環境# python3 -m venv name-of-venvpython3 -m venv env# 啟動虛擬環境source env/bin/activate\n\n當成功使用虛擬環境時，命令列左側會顯示在虛擬環境中。\n# beforeuser@SERVER:/path-to-project$# after(env) user@SERVER:/path-to-project$\n\n安裝 Python 套件python3 -m pip install --upgrade pippip install -r requirements.txt\n\n資料準備接著進行資料準備，所有集合都放在data-char底下，一個資料夾為一個集合。需準備的資料有：text\nID_1 text-in-ID_1ID_2 text-in-ID_2ID_3 text-in-ID_3\n\nwav.scp\nID_1 path-to-ID_1ID_2 path-to-ID_2ID_3 path-to-ID_3\n\n建議data-char放中文字的 text(字為單位)，data-pinyin放英文字的 text(詞為單位)。\n接下來可以使用run.sh內的指令進行驗證，執行後會在output_data_dir的地方放生成後的 binary 檔案。\npython3 custom_data/data_prep.py \\--source_data_dir path-to-your-location \\--output_data_dir path-to-your-data-locationEx:python3 custom_data/data_prep.py \\--source_data_dir data-pinyin/train \\--output_data_dir output_data-pinyin/train\n\n如果輸出Data preparation done代表沒問題，可以進行下一步。\n開始訓練資料準備完成後，即可進行訓練，可以執行以下指令(以字元為例)nproc_per_node為 GPU 數量\ntorchrun --nproc_per_node=1 train/fine-tune_on_custom_dataset.py \\--model_name openai/whisper-base \\  # 基礎模型--language zh \\ # 調適的語言--sampling_rate 16000 \\    # 取樣率--num_proc 4 \\             # 同時只用多少CPU核心執行取樣轉換，越快越好--train_strategy epoch \\   # 訓練週期單位(epoch/steps)--learning_rate 6.25e-6 \\  # 學習率--warmup 1000 \\--train_batchsize 12 \\  # 訓練batch--eval_batchsize 6 \\    # 驗證batch--num_epochs 20 \\       # 訓練週期數--resume_from_ckpt None \\--output_dir op_dir_epoch-char \\           # 輸出路徑資料夾名，記得修改，不然容易忘記--train_datasets output_data-char/train  \\ # 訓練集路徑--eval_datasets output_data-char/dev       # 驗證集路徑\n\n完成訓練後，可以透過終端上每個checkpoint的 WER 去評估哪個模型比較好。\n訓練好的模型資料結構(僅說明重點)以預設名op_dir_epoch-char舉例\nwhisper-hakka ┗━━ op_dir_epoch-char      ┣━ checkpoint-(num)      ┃   ┣━ config.json 參數檔      ┃   ┗━ pytorch_model.bin 模型      ┣━ 每個checkpoint資料夾內的檔案      ┗━ README.md 訓練狀態\n\n測試選擇好最好的 checkpoint 後，就可以進行測試看看該模型效果如何，通常 checkpoint 前 3 名都有機會有好的結果，不一定會是 checkpoint 最好的為最好模型。\npython3 evaluate/evaluate_on_custom_dataset.py \\--is_public_repo False \\--ckpt_dir &quot;op_dir_epoch-char/checkpoint&quot; \\  # checkpoint路徑--temp_ckpt_folder &quot;temp-char&quot; \\         # 暫存位置--language zh \\                          # 語言--eval_datasets output_data-char/test \\  # 測試集路徑--device 0 \\--batch_size 8 \\                   # 測試batch--output_dir predictions_dir-char  # 測試後輸出檔案\n\n測試後即可跟去輸出的 WER(詞錯誤率)與 CER(字錯誤率)去選擇最好的模型。\n輸出模型此腳本並無提供模型輸出的指令，可以使用以下我寫的程式碼：\nfrom multiple_datasets.hub_default_utils import convert_hf_whispermodel_name_or_path = &#x27;path-to-checkpoint&#x27;whisper_checkpoint_path = &#x27;model-name.pt&#x27;convert_hf_whisper(model_name_or_path, whisper_checkpoint_path)\n\n此方法生成的模型可以使用在 python 的 whisper 套件。\n","categories":["HakkaASR"]},{"title":"LeetCode 2023/07","url":"/2023/07/03/LeetCode/LeetCode-2023-07/","content":"2023&#x2F;07&#x2F;03\n1232. Check If It Is a Straight Line\n\nclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        int x1=coordinates[0][0],y1=coordinates[0][1];        int diffx=coordinates[1][0]-coordinates[0][0];        int diffy=coordinates[1][1]-coordinates[0][1];        for(auto c:coordinates)&#123;            if(diffx*(c[1]-y1)!=diffy*(c[0]-x1))&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n\n1071. Greatest Common Divisor of Strings\n\nclass Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        string now,ans=&quot;&quot;,longString,shortString;        if(str1.size()&lt;str2.size())&#123;            longString=str2;            shortString=str1;        &#125;        else&#123;            longString=str1;            shortString=str2;        &#125;        bool chk;        for(auto c:shortString)&#123;            now+=c;            chk=true;            for(int i=0;i&lt;shortString.size();i+=now.size())&#123;                if(shortString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(shortString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            for(int i=0;i&lt;longString.size();i+=now.size())&#123;                if(longString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(longString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            if(chk&amp;&amp;longString.size()%now.size()==0&amp;&amp;shortString.size()%now.size()==0)&#123;                // cout&lt;&lt;now&lt;&lt;endl;                ans=now;            &#125;            // cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n\n\n1160. Find Words That Can Be Formed by Characters\n\nclass Solution &#123;public:    bool checkCount(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a[i]&lt;b[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;        int ans=0;        vector&lt;int&gt; target(26);        for(auto c:chars)&#123;            target[c-&#x27;a&#x27;]++;        &#125;        for(auto word:words)&#123;            vector&lt;int&gt; temp(26);            for(auto c:word)&#123;                temp[c-&#x27;a&#x27;]++;            &#125;            if(checkCount(target,temp))&#123;                ans+=word.size();            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n1323. Maximum 69 Number\n\nclass Solution &#123;public:    int maximum69Number (int num) &#123;        int ans=num;        int temp=num;        for(int i=1;temp&gt;0;i++)&#123;            if(temp%10==6)&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+9*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;else&#123;                ans=max(ans,int(int(num/pow(10,i))*pow(10,i)+6*pow(10,i-1)+num%int(pow(10,i-1))));            &#125;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n\n\n_858. Mirror Reflection\n\nclass Solution &#123;public:    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int mirrorReflection(int p, int q) &#123;        int ap=p/gcd(p,q);        int aq=q/gcd(p,q);        if(ap==aq)&#123;            return 1;        &#125;        int sum=0,cnt=1;        while(aq*cnt%ap!=0)&#123;            cnt++;        &#125;        if(cnt%2==0)&#123;            return 2;        &#125;else if(aq%2==0)&#123;            return 0;        &#125;else&#123;            return 1;        &#125;        return 0;    &#125;&#125;;\n\n\n_946. Validate Stack Sequences\n\nclass Solution &#123;public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;        stack&lt;int&gt; s;        int idxPush=0,idxPop=0,n=popped.size();        for(auto push_val:pushed)&#123;            s.push(push_val);            while(!s.empty()&amp;&amp;idxPop&lt;n)&#123;               if(s.top()==popped[idxPop])&#123;                   s.pop();                   idxPop++;               &#125;else&#123;                   break;               &#125;            &#125;        &#125;        return idxPop==n;    &#125;&#125;;\n\n\n2748. Number of Beautiful Pairs\n\nclass Solution &#123;public:    int first_digit(int a)&#123;        while(a&gt;=10)&#123;            a/=10;        &#125;        return a;    &#125;    int gcd(int a, int b)&#123;        while(b &gt; 0)&#123;            int t = a % b;            a = b;            b = t;        &#125;        return a;    &#125;    int countBeautifulPairs(vector&lt;int&gt;&amp; nums) &#123;        int ans=0;        int n=nums.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(gcd(first_digit(nums[i]),nums[j]%10)==1)&#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2750. Ways to Split Array Into Good Subarrays\n\nclass Solution &#123;public:    int numberOfGoodSubarraySplits(vector&lt;int&gt;&amp; nums) &#123;        int MOD=1e9+7;        int n=nums.size();        int temp=1;        long long int ans=1;        int i;        bool allz=true;        for(i=0;i&lt;n;i++)&#123;            if(nums[i]==1)&#123;                allz=false;                break;            &#125;        &#125;        if(allz)&#123;            return 0;        &#125;        for(i=i+1;i&lt;n;i++)&#123;            if(nums[i])&#123;                ans=(ans*temp)%MOD;                temp=1;            &#125;else&#123;                temp++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;07&#x2F;09\n2418. Sort the People\n\nclass Solution &#123;public:    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123;        int n=names.size();        vector&lt;pair&lt;int,string&gt;&gt; temp(n);        for(int i=0;i&lt;n;i++)&#123;            temp[i]=&#123;heights[i],names[i]&#125;;        &#125;        sort(temp.begin(),temp.end());        vector&lt;string&gt; ans(n);        for(int i=0;i&lt;n;i++)&#123;            ans[n-i-1]=temp[i].second;        &#125;        return ans;    &#125;&#125;;\n\n\n2437. Number of Valid Clock Times\n\nclass Solution &#123;public:    int countTime(string time) &#123;        int ans=1;        if(time[0]==&#x27;?&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=24;            &#125;else if(time[1]&gt;=&#x27;4&#x27;)&#123;                ans*=2;            &#125;else&#123;                ans*=3;            &#125;        &#125;else if(time[0]==&#x27;2&#x27;)&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=4;            &#125;        &#125;else&#123;            if(time[1]==&#x27;?&#x27;)&#123;                ans*=10;            &#125;        &#125;        if(time[3]==&#x27;?&#x27;)&#123;            ans*=6;        &#125;        if(time[4]==&#x27;?&#x27;)&#123;            ans*=10;        &#125;        return ans;    &#125;&#125;;\n\n\n2383. Minimum Hours of Training to Win a Competition\n\nclass Solution &#123;public:    int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123;        int n=energy.size();        int time=0;        for(int i=0;i&lt;n;i++)&#123;            if(initialEnergy&gt;energy[i])&#123;                initialEnergy-=energy[i];            &#125;else&#123;                time+=energy[i]-initialEnergy+1;                initialEnergy=1;            &#125;            if(initialExperience&gt;experience[i])&#123;                initialExperience+=experience[i];            &#125;else&#123;                time+=experience[i]-initialExperience+1;                initialExperience=2*experience[i]+1;            &#125;        &#125;        return time;    &#125;&#125;;\n\n\n2363. Merge Similar Items\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123;        vector&lt;int&gt; temp(1001);        for(auto item:items1)&#123;            temp[item[0]]+=item[1];        &#125;        for(auto item:items2)&#123;            temp[item[0]]+=item[1];        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;1001;i++)&#123;            if(temp[i]!=0)&#123;                ans.push_back(&#123;i,temp[i]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2461. Maximum Sum of Distinct Subarrays With Length K\n\nclass Solution &#123;public:    long long maximumSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; cnt(1e5+1);        int chk=0,n=nums.size();        long long sum=0,ans=0;        for(int i=0;i&lt;k-1;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;            &#125;        &#125;        for(int i=k-1;i&lt;n;i++)&#123;            cnt[nums[i]]++;            sum+=nums[i];            if(cnt[nums[i]]==1)&#123;                chk++;                if(chk==k)&#123;                    ans=max(ans,sum);                &#125;            &#125;            cnt[nums[i-k+1]]--;            sum-=nums[i-k+1];            if(cnt[nums[i-k+1]]==0)&#123;                chk--;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2419. Longest Subarray With Maximum Bitwise AND\n\nclass Solution &#123;public:    int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;        int x=*max_element(nums.begin(),nums.end());        int n=nums.size();        int temp=1,ans=1;        for(int i=0;i&lt;n-1;i++)&#123;            if(nums[i]==nums[i+1]&amp;&amp;nums[i]==x)&#123;                temp++;                ans=max(ans,temp);            &#125;else&#123;                temp=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2760. Longest Even Odd Subarray With Threshold\n\nclass Solution &#123;public:    int longestAlternatingSubarray(vector&lt;int&gt;&amp; nums, int threshold) &#123;        int ans=0,cnt=1,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]%2==0&amp;&amp;nums[i]&lt;=threshold)&#123;                ans=max(ans,cnt);                for(int j=i+1;j&lt;n;j++)&#123;                    if(nums[j]&lt;=threshold&amp;&amp;nums[j]%2!=nums[j-1]%2)&#123;                        cnt++;                    &#125;else&#123;                        cnt=1;                        break;                    &#125;                    ans=max(ans,cnt);                &#125;                cnt=1;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2761. Prime Pairs With Target Sum\n\nclass Solution &#123;public:    bool isPrime(int v)&#123;        int s=sqrt(v);        for(int i=2;i&lt;=s;i++)&#123;            if(v%i==0)&#123;                return false;            &#125;        &#125;        return true;    &#125;    vector&lt;vector&lt;int&gt;&gt; findPrimePairs(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        if(n&lt;=2)&#123;            return ans;        &#125;        int x=3;        while(x&lt;=n/2)&#123;            if(isPrime(x))&#123;                if(isPrime(n-x))&#123;                    ans.push_back(&#123;x,n-x&#125;);                &#125;            &#125;            x+=2;        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;07&#x2F;16\n_557. Reverse Words in a String III\n\nclass Solution &#123;public:    string reverseWords(string s) &#123;        string ans=&quot;&quot;,temp=&quot;&quot;;        for(auto c:s)&#123;            if(c!=&#x27; &#x27;)&#123;                temp=c+temp;            &#125;else&#123;                if(ans==&quot;&quot;)&#123;                    ans=temp;                &#125;else&#123;                    ans+=&quot; &quot;+temp;                &#125;                temp=&quot;&quot;;            &#125;        &#125;        if(ans==&quot;&quot;)&#123;            ans=temp;        &#125;else&#123;            ans+=&quot; &quot;+temp;        &#125;        return ans;    &#125;&#125;;\n\n\n_345. Reverse Vowels of a String\n\nclass Solution &#123;public:    string reverseVowels(string s) &#123;        string ans;        int n=s.size();        int left=n-1;        for(int i=0;i&lt;n;i++)&#123;            if(s[i]==&#x27;a&#x27;||s[i]==&#x27;e&#x27;||s[i]==&#x27;i&#x27;||s[i]==&#x27;o&#x27;||s[i]==&#x27;u&#x27;||s[i]==&#x27;A&#x27;||s[i]==&#x27;E&#x27;||s[i]==&#x27;I&#x27;||s[i]==&#x27;O&#x27;||s[i]==&#x27;U&#x27;)&#123;                while(s[left]!=&#x27;a&#x27;&amp;&amp;s[left]!=&#x27;e&#x27;&amp;&amp;s[left]!=&#x27;i&#x27;&amp;&amp;s[left]!=&#x27;o&#x27;&amp;&amp;s[left]!=&#x27;u&#x27;&amp;&amp;s[left]!=&#x27;A&#x27;&amp;&amp;s[left]!=&#x27;E&#x27;&amp;&amp;s[left]!=&#x27;I&#x27;&amp;&amp;s[left]!=&#x27;O&#x27;&amp;&amp;s[left]!=&#x27;U&#x27;)&#123;                    left--;                &#125;                ans+=s[left];                left--;            &#125;else&#123;                ans+=s[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_463. Island Perimeter\n\nclass Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int x=grid.size(),y=grid[0].size();        int ans=0;        bool chk=false;        for(int i=0;i&lt;x;i++)&#123;            chk=false;            for(int j=0;j&lt;y;j++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[i][y-1]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        for(int j=0;j&lt;y;j++)&#123;            chk=false;            for(int i=0;i&lt;x;i++)&#123;                if(grid[i][j]&amp;&amp;!chk)&#123;                    ans++;                    chk=true;                &#125;else if(!grid[i][j]&amp;&amp;chk)&#123;                    ans++;                    chk=false;                &#125;            &#125;            if(grid[x-1][j]&amp;&amp;chk)&#123;                ans++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_160. Intersection of Two Linked Lists\n\nclass Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *temp=headA;        vector&lt;int*&gt; A,B;        while(headA!=NULL)&#123;            A.push_back(&amp;headA-&gt;val);            headA=headA-&gt;next;        &#125;        while(headB!=NULL)&#123;            B.push_back(&amp;headB-&gt;val);            headB=headB-&gt;next;        &#125;        int n=A.size(),m=B.size();        int idx;        int chk=false;        for(idx=1;idx&lt;=min(n,m);idx++)&#123;            if(A[n-idx]!=B[m-idx])&#123;                chk=true;                break;            &#125;        &#125;        if(idx&gt;min(n,m)&amp;&amp;chk)&#123;            return NULL;        &#125;else&#123;            for(int i=0;i&lt;=n-idx;i++)&#123;                temp=temp-&gt;next;            &#125;            return temp;        &#125;    &#125;&#125;;\n\n\n___6. Zigzag Conversion\n\nclass Solution &#123;public:    string convert(string s, int numRows) &#123;        if(numRows==1)&#123;            return s;        &#125;        vector&lt;vector&lt;char&gt;&gt; temp(numRows,vector&lt;char&gt;(1000,&#x27; &#x27;));        bool up=false;        int i=0,j=0;        for(char c:s)&#123;            temp[i][j]=c;            if(up)&#123;                i--;                j++;                if(i==0)&#123;                    up=false;                &#125;            &#125;else&#123;                i++;                if(i==numRows)&#123;                    up=true;                    i-=2;                    j++;                    if(i==0)&#123;                        up=false;                    &#125;                &#125;            &#125;        &#125;        string ans;        for(int ii=0;ii&lt;numRows;ii++)&#123;            for(int jj=0;jj&lt;j+1;jj++)&#123;                if(temp[ii][jj]!=&#x27; &#x27;)&#123;                    ans+=temp[ii][jj];                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n1366. Rank Teams by Votes\n\nclass Solution &#123;public:    static bool cmp(pair&lt;char,vector&lt;int&gt;&gt; a, pair&lt;char,vector&lt;int&gt;&gt; b)&#123;        for(int i=0;i&lt;26;i++)&#123;            if(a.second[i]!=b.second[i])&#123;                return a.second[i]&gt;b.second[i];            &#125;        &#125;        return a.first&lt;b.first;    &#125;    string rankTeams(vector&lt;string&gt;&amp; votes) &#123;        vector&lt;pair&lt;char,vector&lt;int&gt;&gt;&gt; temp(26,&#123;&#x27; &#x27;,vector&lt;int&gt;(26,0)&#125;);        for(auto c:votes[0])&#123;            temp[c-&#x27;A&#x27;].first=c;        &#125;        int voteSize=votes[0].size();        for(auto vote:votes)&#123;            for(int i=0;i&lt;voteSize;i++)&#123;                temp[vote[i]-&#x27;A&#x27;].second[i]++;            &#125;        &#125;        sort(temp.begin(),temp.end(),cmp);        string ans=&quot;&quot;;        for(auto t:temp)&#123;            if(t.first!=&#x27; &#x27;)&#123;                ans+=t.first;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2769. Find the Maximum Achievable Number\n\nclass Solution &#123;public:    int theMaximumAchievableX(int num, int t) &#123;        return num+2*t;    &#125;&#125;;\n\n\n6899. Maximum Number of Jumps to Reach the Last Index\n\nclass Solution &#123;public:    int maximumJumps(vector&lt;int&gt;&amp; nums, int target) &#123;        int n=nums.size();        vector&lt;int&gt; distance(n,-2);        distance[0]=0;        for(int i=1;i&lt;n;i++)&#123;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(nums[j]-nums[i])&lt;=target&amp;&amp;distance[j]&gt;=0)&#123;                    distance[i]=max(distance[i],distance[j]);                &#125;            &#125;            distance[i]++;        &#125;        return distance[n-1];    &#125;&#125;;\n\n\n6912. Longest Non-decreasing Subarray From Two Arrays\n\nclass Solution &#123;public:    int maxNonDecreasingLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int n=nums1.size();        vector&lt;int&gt; nums1c(n,1);        vector&lt;int&gt; nums2c(n,1);        int now=0;        int ans=1;        for(int i=1;i&lt;n;i++)&#123;            if(nums2[i-1]&lt;=nums2[i])&#123;                nums2c[i]=nums2c[i-1]+1;            &#125;            if(nums1[i-1]&lt;=nums2[i])&#123;                nums2c[i]=max(nums1c[i-1]+1,nums2c[i]);            &#125;            if(nums1[i-1]&lt;=nums1[i])&#123;                nums1c[i]=nums1c[i-1]+1;            &#125;            if(nums2[i-1]&lt;=nums1[i])&#123;                nums1c[i]=max(nums2c[i-1]+1,nums1c[i]);            &#125;            ans=max(ans,max(nums1c[i],nums2c[i]));        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;07&#x2F;23\n2656. Maximum Sum With Exactly K Elements\n\nclass Solution &#123;public:    int maximizeSum(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());        int ans=0;        for(int i=0;i&lt;k;i++)&#123;            ans+=nums[0]+i;        &#125;        return ans;    &#125;&#125;;\n\n\n2475. Number of Unequal Triplets in Array\n\nclass Solution &#123;public:    int unequalTriplets(vector&lt;int&gt;&amp; nums) &#123;        int cnt=0;        int n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[i]!=nums[j])&#123;                    for(int k=j+1;k&lt;n;k++)&#123;                        if(nums[j]!=nums[k]&amp;&amp;nums[i]!=nums[k])&#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;;\n\n\n2558. Take Gifts From the Richest Pile\n\nclass Solution &#123;public:    long long pickGifts(vector&lt;int&gt;&amp; gifts, int k) &#123;        for(int i=0;i&lt;k;i++)&#123;            sort(gifts.begin(),gifts.end(),greater&lt;int&gt;());            gifts[0]=sqrt(gifts[0]);        &#125;        long long ans=0;        for(auto gift:gifts)&#123;            ans+=gift;        &#125;        return ans;    &#125;&#125;;\n\n\n2278. Percentage of Letter in String\n\nclass Solution &#123;public:    int percentageLetter(string s, char letter) &#123;        double cnt=0;        for(auto c:s)&#123;            cnt+=(c==letter);        &#125;        return cnt/s.size()*100;    &#125;&#125;;\n\n\n_275. H-Index II\n\nclass Solution &#123;public:    int hIndex(vector&lt;int&gt;&amp; citations) &#123;        int n=citations.size();        int l=0,r=n-1,m;        while(l&lt;=r)&#123;            m=(r+l+1)/2;            if(citations[m]==n-m)&#123;                return n-m;            &#125;            else if(citations[m]&lt;n-m)&#123;                l=m+1;            &#125;            else&#123;                r=m-1;            &#125;        &#125;        return n-l;    &#125;&#125;;\n\n\n_227. Basic Calculator II\n\nclass Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;        int now=0;        char sign=&#x27;+&#x27;;        for(int i=0;i&lt;s.size();i++)&#123;            if(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;)&#123;                now = 10*now + (s[i]-&#x27;0&#x27;);            &#125;            if(!(&#x27;0&#x27;&lt;=s[i] &amp;&amp; s[i]&lt;=&#x27;9&#x27;) &amp;&amp; s[i]!=&#x27; &#x27; || i==s.size()-1)&#123;                if(sign==&#x27;+&#x27;)&#123;                    st.push(now);                &#125;                else if(sign==&#x27;-&#x27;)&#123;                    st.push(-1*now);                &#125;                else&#123;                    int num;                    if(sign==&#x27;*&#x27;)&#123;                        num=st.top()*now;                    &#125;                    else&#123;                        num=st.top()/now;                    &#125;                    st.pop();                    st.push(num);                &#125;                sign=s[i];                now=0;            &#125;        &#125;        int sum = 0;        while(!st.empty())&#123;            sum+=st.top();            st.pop();        &#125;        return sum;    &#125;&#125;;\n\n\n2778. Sum of Squares of Special Elements\n\nclass Solution &#123;public:    int sumOfSquares(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        int ans=0;        for(int i=0;i&lt;n;i++)&#123;            if(n%(i+1)==0)&#123;                ans+=nums[i]*nums[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2779. Maximum Beauty of an Array After Applying Operation\n\nclass Solution &#123;public:    int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; temp(100001,0);        for(auto num:nums)&#123;            temp[num]++;        &#125;        int now=0;        for(int i=0;i&lt;min(2*k,100001);i++)&#123;            now+=temp[i];        &#125;        int ans=now;        for(int i=2*k;i&lt;100001;i++)&#123;            now+=temp[i];            ans=max(ans,now);            now-=temp[i-2*k];        &#125;        return ans;    &#125;&#125;;\n\n\n2780. Minimum Index of a Valid Split\n\nclass Solution &#123;public:    int minimumIndex(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        vector&lt;pair&lt;int,int&gt;&gt; left(n);        vector&lt;pair&lt;int,int&gt;&gt; right(n);        unordered_map&lt;int, int&gt; rFreq;        int rNum=0,rCnt=0;        for(int i=n-1;i&gt;0;i--)&#123;            rFreq[nums[i]]++;            if(rFreq[nums[i]]&gt;rCnt)&#123;                rNum = nums[i];                rCnt=rFreq[nums[i]];            &#125;            right[i-1]=&#123;rNum,rCnt&#125;;        &#125;        unordered_map&lt;int, int&gt; freq;        int leftNum=0,leftCnt=0;        for (int i=0;i&lt;n-1;i++) &#123;            freq[nums[i]]++;            if(freq[nums[i]]&gt;leftCnt)&#123;                leftNum = nums[i];                leftCnt = freq[nums[i]];            &#125;            if (leftNum==right[i].first) &#123;                if(leftCnt * 2 &gt; i+1 &amp;&amp; right[i].second * 2 &gt; (n-i-1))&#123;                    return i;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n2023&#x2F;07&#x2F;30\n1394. Find Lucky Integer in an Array\n\nclass Solution &#123;public:    int findLucky(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(),arr.end(),greater&lt;int&gt;());        int now=arr[0],cnt=0;        for(auto a:arr)&#123;            if(a==now)&#123;                cnt++;            &#125;else&#123;                if(cnt==now)&#123;                    return cnt;                &#125;                now=a;                cnt=1;            &#125;        &#125;        if(cnt==arr.back())&#123;            return cnt;        &#125;        return -1;    &#125;&#125;;\n\n\n1332. Remove Palindromic Subsequences\n\nclass Solution &#123;public:    int removePalindromeSub(string s) &#123;            string temp=s;            reverse(temp.begin(),temp.end());            if(s==&quot;&quot;)&#123;                return 0;            &#125;            else if(s==temp)&#123;                return 1;            &#125;            return 2;        &#125;&#125;;\n\n\n1281. Subtract the Product and Sum of Digits of an Integer\n\nclass Solution &#123;public:    int subtractProductAndSum(int n) &#123;        int pro=1,sum=0;        while(n&gt;0)&#123;            pro*=n%10;            sum+=n%10;            n/=10;        &#125;        return pro-sum;    &#125;&#125;;\n\n\n1013. Partition Array Into Three Parts With Equal Sum\n\nclass Solution &#123;public:    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; arr) &#123;        int n=arr.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)        &#125;    &#125;&#125;;\n\n\n2249. Count Lattice Points Inside a Circle\n\nclass Solution &#123;public:    int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123;        set&lt;pair&lt;int,int&gt;&gt; temp;        for(auto c:circles)&#123;            int midx=c[0],midy=c[1],r=c[2],r_sqr=c[2]*c[2];            for(int x=-r;x&lt;=r;x++)&#123;                for(int y=-r;y&lt;=r;y++)&#123;                    if(x*x+y*y&lt;=r_sqr)&#123;                        temp.insert(&#123;midx+x,midy+y&#125;);                    &#125;                &#125;            &#125;        &#125;        return temp.size();    &#125;&#125;;\n\n\n2256. Minimum Average Difference\n\nclass Solution &#123;public:    int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123;        long long sum=0;        for(auto num:nums)&#123;            sum+=num;        &#125;        int n=nums.size();        long long now=0,minVal=1e5,minIdx=0,temp;        for(int i=0;i&lt;n-1;i++)&#123;            now+=nums[i];            sum-=nums[i];            temp=abs(now/(i+1)-sum/(n-i-1));            if(temp&lt;minVal)&#123;                minVal=temp;                minIdx=i;            &#125;        &#125;        if((now+nums[n-1])/n&lt;minVal)&#123;            minIdx=n-1;        &#125;        return minIdx;    &#125;&#125;;\n\n\n2788. Split Strings by Separator\n\nclass Solution &#123;public:    vector&lt;string&gt; splitWordsBySeparator(vector&lt;string&gt;&amp; words, char separator) &#123;        vector&lt;string&gt; ans;        string temp;        for(auto word:words)&#123;            temp=&quot;&quot;;            for(auto c:word)&#123;                if(c==separator)&#123;                    if(temp!=&quot;&quot;)&#123;                        ans.push_back(temp);                        temp=&quot;&quot;;                    &#125;                &#125;else&#123;                    temp+=c;                &#125;            &#125;            if(temp!=&quot;&quot;)&#123;                ans.push_back(temp);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2789. Largest Element in an Array after Merge Operations\n\nclass Solution &#123;public:    long long maxArrayValue(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;long long&gt; temp(n,0);        long long ans=nums[n-1];        temp[n-1]=nums[n-1];        for(int i=n-1;i&gt;0;i--)&#123;            temp[i-1]=nums[i-1];            if(nums[i-1]&lt;=temp[i])&#123;                temp[i-1]+=temp[i];            &#125;            ans=max(ans,temp[i-1]);        &#125;        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;temp[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        return ans;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2023/08","url":"/2023/08/14/LeetCode/LeetCode-2023-08/","content":"2023&#x2F;08&#x2F;13\n_108. Convert Sorted Array to Binary Search Tree\n\nclass Solution &#123;public:    TreeNode* pushNode(vector&lt;int&gt;&amp; nums,int left,int right)&#123;        if(left&lt;=right)&#123;            int mid=(left+right)/2;            TreeNode* root = new TreeNode(nums[mid]);            root-&gt;left = pushNode(nums,left,mid-1);            root-&gt;right = pushNode(nums,mid+1,right);            return root;        &#125;        return nullptr;    &#125;    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        return pushNode(nums,0,nums.size()-1);    &#125;&#125;;\n\n\n_303. Range Sum Query - Immutable\n\nclass NumArray &#123;public:    vector&lt;int&gt; temp;    NumArray(vector&lt;int&gt;&amp; nums) &#123;        temp.clear();        for(auto num:nums)&#123;            temp.push_back(num);        &#125;    &#125;    int sumRange(int left, int right) &#123;        int sum=0;        for(int i=left;i&lt;=right;i++)&#123;            sum+=temp[i];        &#125;        return sum;    &#125;&#125;;\n\n\n_202. Happy Number\n\nclass Solution &#123;public:    bool isHappy(int n) &#123;        int temp=0;        for(int i=0;i&lt;20;i++)&#123;            temp=0;            while(n&gt;0)&#123;                temp+=(n%10)*(n%10);                n/=10;            &#125;            n=temp;            // cout&lt;&lt;n&lt;&lt;endl;        &#125;        return n==1;    &#125;&#125;;\n\n\n_232. Implement Queue using Stacks\n\nclass MyQueue &#123;public:    vector&lt;int&gt; temp;    MyQueue() &#123;        temp.clear();    &#125;    void push(int x) &#123;        temp.push_back(x);    &#125;    int pop() &#123;        int val=temp[0];        temp.erase(temp.begin());        return val;    &#125;    int peek() &#123;        return temp[0];    &#125;    bool empty() &#123;        return temp.size()==0;    &#125;&#125;;\n\n\n2162. Minimum Cost to Set Cooking Time\n\nclass Solution &#123;public:    int pushNum(int startAt, int moveCost, int pushCost, int s)&#123;        int val=0;        stack&lt;int&gt; st;        while(s&gt;0)&#123;            st.push(s%10);            s/=10;        &#125;        while(!st.empty())&#123;            if(startAt!=st.top())&#123;                val+=moveCost;                startAt=st.top();            &#125;            val+=pushCost;            st.pop();        &#125;        return val;    &#125;    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) &#123;        int m=0,s=targetSeconds;        int ans=1e9;        while(s&gt;=100)&#123;            m+=1;            s-=60;        &#125;        while(s&gt;=0&amp;&amp;m&lt;100)&#123;            ans=min(ans,pushNum(startAt,moveCost,pushCost,m*100+s));            m+=1;            s-=60;        &#125;        return ans;    &#125;&#125;;\n\n\n2810. Faulty Keyboard\n\nclass Solution &#123;public:    string finalString(string s) &#123;        string temp=&quot;&quot;;        for(auto c:s)&#123;            if(c==&#x27;i&#x27;)&#123;                reverse(temp.begin(),temp.end());            &#125;else&#123;                temp+=c;            &#125;        &#125;        return temp;    &#125;&#125;;\n\n\n2811. Check if it is Possible to Split Array\n\nclass Solution &#123;public:    bool canSplitArray(vector&lt;int&gt;&amp; nums, int m) &#123;        for(int i=0;i&lt;nums.size()-1;i++)            if(nums[i]+nums[i+1]&gt;=m)&#123;                return true;            &#125;        return nums.size()&lt;3;    &#125;&#125;;\n\n\n2812. Find the Safest Path in a Grid\n\n\n\n\n2813. Maximum Elegance of a K-Length Subsequence\n\n\n\n2023&#x2F;08&#x2F;20\n2441. Largest Positive Integer That Exists With Its Negative\n\nclass Solution &#123;public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int left=0,right=nums.size()-1;        while(left&lt;right)&#123;            cout&lt;&lt;nums[left]&lt;&lt;&#x27; &#x27;&lt;&lt;nums[right]&lt;&lt;endl;            if(nums[left]*-1==nums[right])&#123;                return nums[right];            &#125;else if(nums[left]*-1&lt;nums[right])&#123;                right--;            &#125;else&#123;                left++;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n\n2520. Count the Digits That Divide a Number\n\nclass Solution &#123;public:    int countDigits(int num) &#123;        int ans=0;        int temp=num;        while(temp&gt;0)&#123;            ans+=(num%(temp%10))==0;            temp/=10;        &#125;        return ans;    &#125;&#125;;\n\n\n2299. Strong Password Checker II\n\nclass Solution &#123;public:    bool check_special_char(char c)&#123;        string special=&quot;!@#$%^&amp;*()-+&quot;;        for(auto s:special)&#123;            if(c==s)&#123;                return true;            &#125;        &#125;        return false;    &#125;    bool strongPasswordCheckerII(string password) &#123;        int n=password.size();        bool upper=false,lower=false,digit=false,special=false;        char lastword=&#x27;&gt;&#x27;;        for(auto c:password)&#123;            if(c==lastword)                return false;            else if(&#x27;A&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;Z&#x27;)                upper=true;            else if(&#x27;a&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;z&#x27;)                lower=true;            else if(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)                digit=true;            else if(check_special_char(c))                special=true;            lastword=c;        &#125;        return n&gt;7&amp;&amp;upper&amp;&amp;lower&amp;&amp;digit&amp;&amp;special;    &#125;&#125;;\n\n\n2423. Remove Letter To Equalize Frequency\n\nclass Solution &#123;public:    bool chk_one(vector&lt;int&gt;&amp; now)&#123;        bool chk=true;        int idx;        for(idx=1;now[idx]&gt;1;idx++)&#123;            if(now[0]!=now[idx])&#123;                return false;            &#125;        &#125;        if(now[idx]==0)&#123;            return false;        &#125;        if(idx==now.size()-1)&#123;            return true;        &#125;        if(now[idx+1]==1)&#123;            return false;        &#125;        return true;    &#125;    bool equalFrequency(string word) &#123;        vector&lt;int&gt; abc(26,0);        for(auto c:word)&#123;            abc[c-&#x27;a&#x27;]++;        &#125;        sort(abc.begin(),abc.end(),greater&lt;int&gt;());        if(abc[0]==1)&#123;            return true;        &#125;        if(chk_one(abc))&#123;            return true;        &#125;        bool chk=true;        for(int i=0;i&lt;26;i++)&#123;            if(abc[i]==0)&#123;                break;            &#125;            chk=true;            for(int j=0;j&lt;26;j++)&#123;                if(abc[j]==0)&#123;                    break;                &#125;                if(i!=j&amp;&amp;abc[i]-1!=abc[j])&#123;                    chk=false;                    break;                &#125;            &#125;            if(chk)&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n_957. Prison Cells After N Days\n\nclass Solution &#123;public:    int calc(int a,int b,int c)&#123;        if(a==c)&#123;            return 1;        &#125;        return 0;    &#125;    vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int n) &#123;        vector&lt;int&gt; now(8),temp(8);        int loop=(n-1)%14;        for(int i=0;i&lt;8;i++)&#123;            now[i]=cells[i];        &#125;        for(int cnt=0;cnt&lt;=loop;cnt++)&#123;            temp[0]=0;            for(int i=1;i&lt;7;i++)&#123;                temp[i]=calc(now[i-1],now[i],now[i+1]);            &#125;            temp[7]=0;            for(int i=0;i&lt;8;i++)&#123;                now[i]=temp[i];            &#125;        &#125;        return now;    &#125;&#125;;//chk loop// vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int n) &#123;//     vector&lt;int&gt; now(8),temp(8);//     now[0]=cells[0]&amp;&amp;cells[1];//     for(int i=1;i&lt;7;i++)&#123;//         now[i]=calc(cells[i-1],cells[i],cells[i+1]);//     &#125;//     now[7]=cells[6]&amp;&amp;cells[7];//     for(int i=0;i&lt;8;i++)&#123;//         cells[i]=now[i];//     &#125;//     while(true)&#123;//         temp[0]=now[0]&amp;&amp;now[1];//         for(int i=1;i&lt;7;i++)&#123;//             temp[i]=calc(now[i-1],now[i],now[i+1]);//         &#125;//         temp[7]=now[6]&amp;&amp;now[7];//         bool chk=true;//         for(int i=0;i&lt;8;i++)&#123;//             now[i]=temp[i];//             cout&lt;&lt;now[i]&lt;&lt;&#x27; &#x27;;//             if(now[i]!=cells[i])&#123;//                 chk=false;//             &#125;//         &#125;//         cout&lt;&lt;endl;//         if(chk)&#123;//             break;//         &#125;//     &#125;//     return &#123;&#125;;// &#125;\n\n\n_900. RLE Iterator\n\nclass RLEIterator &#123;public:    vector&lt;int&gt; num;    vector&lt;int&gt; cnt;    int idx=0,num_siz;    RLEIterator(vector&lt;int&gt;&amp; encoding) &#123;        int n=encoding.size();        idx=0;        for(int i=0;i&lt;n;i+=2)&#123;            cnt.push_back(encoding[i]);            num.push_back(encoding[i+1]);        &#125;        num_siz=num.size();    &#125;    int next(int n) &#123;        for(;idx&lt;num_siz;idx++)&#123;            if(cnt[idx]&gt;=n)&#123;                cnt[idx]-=n;                return num[idx];            &#125;else&#123;                n-=cnt[idx];                cnt[idx]=0;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n\n2815. Max Pair Sum in an Array\n\nclass Solution &#123;public:    int maxdigit(int n)&#123;        int output=0;        while(n&gt;0)&#123;            output=max(output,n%10);            n/=10;        &#125;        return output;    &#125;    int maxSum(vector&lt;int&gt;&amp; nums) &#123;        int ans=-1;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(maxdigit(nums[i])==maxdigit(nums[j]))&#123;                    ans=max(ans,nums[i]+nums[j]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2816. Double a Number Represented as a Linked List\n\nclass Solution &#123;public:    ListNode* doubleIt(ListNode* head) &#123;        ListNode* ans=new ListNode();        if(head-&gt;val&gt;4)&#123;            ans-&gt;next=head;        &#125;else&#123;            ans=head;        &#125;        ListNode* temp=ans;        while(temp)&#123;            temp-&gt;val=(2*temp-&gt;val)%10;            if(temp-&gt;next)                if(temp-&gt;next-&gt;val&gt;4)                    temp-&gt;val++;            temp=temp-&gt;next;        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;08&#x2F;27\n1929. Concatenation of Array\n\nclass Solution &#123;public:    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            nums.push_back(nums[i]);        &#125;        return nums;    &#125;&#125;;\n\n\n1886. Determine Whether Matrix Can Be Obtained By Rotation\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; rotate(vector&lt;vector&lt;int&gt;&gt; input)&#123;        int n=input.size();        vector&lt;vector&lt;int&gt;&gt; output(n,vector&lt;int&gt;(n,0));        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                output[j][n-i-1]=input[i][j];            &#125;        &#125;        return output;    &#125;    bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123;        int n=mat.size();        for(int turn=0;turn&lt;4;turn++)&#123;            bool chk=true;            for(int i=0;i&lt;n;i++)&#123;                for(int j=0;j&lt;n;j++)&#123;                    if(mat[i][j]!=target[i][j])&#123;                        chk=false;                    &#125;                &#125;            &#125;            if(chk)&#123;                return true;            &#125;            mat=rotate(mat);        &#125;        return false;    &#125;&#125;;\n\n\n1752. Check if Array Is Sorted and Rotated\n\nclass Solution &#123;public:    bool isSorted(vector&lt;int&gt;&amp; nums)&#123;        int n=nums.size();        for(int i=1;i&lt;n;i++)&#123;            if(nums[i-1]&gt;nums[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    bool check(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(isSorted(nums))&#123;                return true;            &#125;            nums.push_back(nums[0]);            nums.erase(nums.begin());        &#125;        return false;    &#125;&#125;;\n\n\n1518. Water Bottles\n\nclass Solution &#123;public:    int numWaterBottles(int numBottles, int numExchange) &#123;        int ans=numBottles;        while(numBottles&gt;=numExchange)&#123;            ans+=numBottles/numExchange;            numBottles=numBottles/numExchange+numBottles%numExchange;        &#125;        return ans;    &#125;&#125;;\n\n\n__57. Insert Interval\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;        int n=intervals.size();        if(n==0)&#123;            return &#123;newInterval&#125;;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        int idx=0,left,right;        for(;idx&lt;n;idx++)&#123;            if(intervals[idx][1]&lt;newInterval[0])&#123;                ans.push_back(intervals[idx]);            &#125;else&#123;                break;            &#125;        &#125;        if(idx==0&amp;&amp;intervals[idx][1]&lt;newInterval[0])&#123;            ans.push_back(newInterval);        &#125;else if(idx==n)&#123;            ans.push_back(newInterval);        &#125;else if(intervals[idx][0]&lt;=newInterval[0]&amp;&amp;newInterval[1]&lt;=intervals[idx][1])&#123;                ans.push_back(intervals[idx]);                idx++;        &#125;else&#123;            left=min(intervals[idx][0],newInterval[0]);            right=newInterval[1];            for(;idx&lt;n;idx++)&#123;                if(intervals[idx][0]&lt;=newInterval[1])&#123;                    right=max(right,intervals[idx][1]);                &#125;else&#123;                    break;                &#125;            &#125;            ans.push_back(&#123;left,right&#125;);        &#125;        for(;idx&lt;n;idx++)&#123;            ans.push_back(intervals[idx]);        &#125;        return ans;    &#125;&#125;;\n\n\n_229. Majority Element II\n\nclass Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;        int limit=nums.size()/3;        sort(nums.begin(),nums.end());        int now=nums[0],cnt=0;        for(auto num:nums)&#123;            if(now==num)&#123;                cnt++;            &#125;else&#123;                if(cnt&gt;limit)&#123;                    ans.push_back(now);                &#125;                now=num;                cnt=1;            &#125;        &#125;        if(cnt&gt;limit)&#123;            ans.push_back(now);        &#125;        return ans;    &#125;&#125;;\n\n\n2828. Check if a String Is an Acronym of Words\n\nclass Solution &#123;public:    bool isAcronym(vector&lt;string&gt;&amp; words, string s) &#123;        string temp=&quot;&quot;;        for(auto word:words)&#123;            temp+=word[0];        &#125;        return temp==s;    &#125;&#125;;\n\n\n2829. Determine the Minimum Sum of a k-avoiding Array\n\nclass Solution &#123;public:    int minimumSum(int n, int k) &#123;        int cnt=0,sum=0;        for(int i=1;cnt&lt;n;i++)&#123;            if(!(k/2&lt;i&amp;&amp;i&lt;k))&#123;                cout&lt;&lt;i&lt;&lt;endl;                cnt++;                sum+=i;            &#125;        &#125;        return sum;    &#125;&#125;;\n\n\n2831. Find the Longest Equal Subarray\n\nclass Solution &#123;public:    int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) &#123;        int n=nums.size(),left=0,diff;        int ans=0;        unordered_map&lt;int,int&gt; count;        for(int i=0;i&lt;n;i++)&#123;            count[nums[i]]++;            ans=max(ans,count[nums[i]]);            if(i-left+1-ans&gt;k)&#123;                count[nums[left]]--;                left++;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2024/03","url":"/2024/03/10/LeetCode/LeetCode-2024-03/","content":"2024&#x2F;03&#x2F;10\n1750. Minimum Length of String After Deleting Similar Ends\n\nclass Solution &#123;public:    int minimumLength(string s) &#123;        int left=0,right=s.size()-1;        while(left&lt;right)&#123;            if(s[left]!=s[right])&#123;                break;            &#125;            int now = left;            while(now&lt;right&amp;&amp;s[now]==s[left])&#123;                left++;            &#125;            while(right&gt;left&amp;&amp;s[now]==s[right])&#123;                right--;            &#125;            // cout&lt;&lt;left&lt;&lt;&#x27; &#x27;&lt;&lt;right&lt;&lt;endl;        &#125;        return right-left+1;    &#125;&#125;;\n\n\n876. Middle of the Linked List\n\nclass Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        ListNode* ans=head;        int cnt=0;        while(head)&#123;            if(cnt)&#123;                ans=ans-&gt;next;            &#125;            head=head-&gt;next;            cnt=(cnt+1)%2;        &#125;        return ans;    &#125;&#125;;\n\n\n141. Linked List Cycle\n\nclass Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if(head==NULL||head-&gt;next==NULL||head-&gt;next-&gt;next==NULL)&#123;            return false;        &#125;        ListNode *f=head,*s=head;        while(f!=NULL&amp;&amp;f-&gt;next!=NULL)&#123;            f=f-&gt;next-&gt;next;            s=s-&gt;next;            if(f==s)&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n3005. Count Elements With Maximum Frequency\n\nclass Solution &#123;public:    int maxFrequencyElements(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; cnts(100);        for(auto num:nums)&#123;            cnts[num-1]++;        &#125;        int singleMax=0,total=0;        for(auto cnt:cnts)&#123;            if(cnt&gt;singleMax)&#123;                total=cnt;                singleMax=cnt;            &#125;else if(cnt==singleMax)&#123;                total+=cnt;            &#125;        &#125;        return total;    &#125;&#125;;\n\n\n1768. Merge Strings Alternately\n\nclass Solution &#123;public:    string mergeAlternately(string word1, string word2) &#123;        int idx1=0,idx2=0,size1=word1.length(),size2=word2.length();        string ans;        while(idx1&lt;size1||idx2&lt;size2)&#123;            if(idx1&lt;size1)&#123;                ans+=word1[idx1];                idx1++;            &#125;            if(idx2&lt;size2)&#123;                ans+=word2[idx2];                idx2++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2540. Minimum Common Value\n\nclass Solution &#123;public:    int getCommon(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int i=0,j=0,m=nums1.size(),n=nums2.size();        while(i&lt;m&amp;&amp;j&lt;n)&#123;            if(nums1[i]&lt;nums2[j])                i++;            else if(nums1[i]&gt;nums2[j])                j++;            else                return nums1[i];        &#125;        return -1;    &#125;&#125;;\n\n\n3074. Apple Redistribution into Boxes\n\nclass Solution &#123;public:    int minimumBoxes(vector&lt;int&gt;&amp; apple, vector&lt;int&gt;&amp; capacity) &#123;        int total=0;        for(auto a:apple)&#123;            total+=a;        &#125;        sort(capacity.begin(),capacity.end(),greater&lt;int&gt;());        int i=0;        for(auto c:capacity)&#123;            i++;            total-=c;            if(total&lt;=0)&#123;                break;            &#125;        &#125;        return i;    &#125;&#125;;\n\n\n3075. Maximize Happiness of Selected Children\n\nclass Solution &#123;public:    long long maximumHappinessSum(vector&lt;int&gt;&amp; happiness, int k) &#123;        sort(happiness.begin(),happiness.end(),greater&lt;int&gt;());        long long ret=0;        for(long long i=0;i&lt;k;i++)&#123;            if(happiness[i]-i&gt;0)&#123;                ret+=happiness[i]-i;            &#125;else&#123;                break;            &#125;        &#125;        return ret;    &#125;&#125;;\n\n\n3076. Shortest Uncommon Substring in an Array\n\nclass Solution &#123;public:    static bool cmp(string a, string b)    &#123;        if(a.size()&lt;b.size())&#123;            return true;        &#125;else if(a.size()&gt;b.size())&#123;            return false;        &#125;        for(int i=0;i&lt;a.size();i++)&#123;            if(a[i]&lt;b[i])&#123;                return true;            &#125;else if(a[i]&gt;b[i])&#123;                return false;            &#125;        &#125;        return false;    &#125;    vector&lt;string&gt; sublist(string a)&#123;        vector&lt;string&gt; ret;        for(int i=1;i&lt;=a.size();i++)&#123;            for(int j=0;j+i&lt;=a.size();j++)&#123;                // cout&lt;&lt;a.substr(i+j-i,i)&lt;&lt;endl;                if(find(ret.begin(),ret.end(),a.substr(i+j-i,i))==ret.end())&#123;                    ret.push_back(a.substr(i+j-i,i));                &#125;            &#125;        &#125;        sort(ret.begin(),ret.end(),cmp);        return ret;    &#125;    vector&lt;string&gt; shortestSubstrings(vector&lt;string&gt;&amp; arr) &#123;        vector&lt;string&gt; ans;        int n=arr.size();        for(int i=0;i&lt;n;i++)&#123;            vector&lt;string&gt; substring=sublist(arr[i]);            string now=&quot;&quot;;            for(auto s:substring)&#123;                bool chk=false;                for(int j=0;j&lt;n&amp;&amp;chk==false;j++)&#123;                    if(i!=j)&#123;                        if(arr[j].find(s)!=string::npos)&#123;                            chk=true;                        &#125;                    &#125;                &#125;                if(!chk)&#123;                    now=s;                    break;                &#125;            &#125;            ans.push_back(now);        &#125;        return ans;    &#125;&#125;;\n\n\n349. Intersection of Two Arrays\n\nclass Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int table[1001];        for(auto num:nums1)&#123;            table[num]=1;        &#125;        vector&lt;int&gt; ans;        for(auto num:nums2)&#123;            if(table[num])&#123;                ans.push_back(num);                table[num]=0;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2024&#x2F;03&#x2F;17\n_791. Custom Sort String\n\nclass Solution &#123;public:    string customSortString(string order, string s) &#123;        int abc[26];        for(auto c:s)&#123;            abc[c-&#x27;a&#x27;]++;        &#125;        string ans;        for(auto o:order)&#123;            while(abc[o-&#x27;a&#x27;])&#123;                ans+=o;                abc[o-&#x27;a&#x27;]--;            &#125;        &#125;        for(int i=0;i&lt;26;i++)&#123;            if(abc[i])&#123;                while(abc[i])&#123;                    ans+=char(&#x27;a&#x27;+i);                    abc[i]--;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_238. Product of Array Except Self\n\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; ans(n),left(n),right(n);        left[0]=1;        right[n-1]=1;        for(int i=1;i&lt;n-1;i++)&#123;            left[i]=nums[i-1]*left[i-1];            right[n-i-1]=nums[n-i]*right[n-i];        &#125;        left[n-1]=nums[n-2]*left[n-2];        right[0]=nums[1]*right[1];        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;left[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;right[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        for(int i=0;i&lt;n;i++)&#123;            ans[i]=right[i]*left[i];        &#125;        return ans;    &#125;&#125;;\n\n2024&#x2F;03&#x2F;24\n_452. Minimum Number of Arrows to Burst Balloons\n\nclass Solution &#123;public:    static bool cmp(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;        if(a[0]==b[0])            return a[1]&lt;b[1];        return a[0]&lt;b[0];    &#125;    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        sort(points.begin(),points.end(),cmp);        int n=points.size();        int pos=points[0][1];        int arrow=1;        for(int i=1;i&lt;n;i++)&#123;            if(points[i][1]&lt;pos)&#123;                pos=points[i][1];            &#125;            else if(points[i][0]&gt;pos)&#123;                arrow++;                pos=points[i][1];            &#125;        &#125;        return arrow;    &#125;&#125;;\n\n\n1669. Merge In Between Linked Lists\n\nclass Solution &#123;public:    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) &#123;        ListNode* left=list1;        for(int i=0;i&lt;a-1;i++)&#123;            left=left-&gt;next;        &#125;        ListNode* right=left;        for(int i=0;i&lt;b-a+2;i++)&#123;            right=right-&gt;next;        &#125;        // return right;        left-&gt;next=list2;        while(left-&gt;next)&#123;            left=left-&gt;next;        &#125;        left-&gt;next=right;        return list1;    &#125;&#125;;\n\n\n_206. Reverse Linked List\n\nclass Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        vector&lt;int&gt; val;        ListNode* temp = head;        while(temp)&#123;            val.push_back(temp-&gt;val);            temp=temp-&gt;next;        &#125;        temp = head;        reverse(val.begin(),val.end());        for(auto n:val)&#123;            temp-&gt;val=n;            temp=temp-&gt;next;        &#125;        return head;    &#125;&#125;;\n\n\n_143. Reorder List\n\nclass Solution &#123;public:    void reorderList(ListNode* head) &#123;        vector&lt;int&gt; val;        ListNode *now=head;        while(now)&#123;            val.push_back(now-&gt;val);            now=now-&gt;next;        &#125;        int l=0,r=val.size()-1,n=r;        now=head;        while(l&lt;=r)&#123;            if(n-r&lt;l)&#123;                now-&gt;val=val[r];                r--;                now=now-&gt;next;            &#125;else&#123;                now-&gt;val=val[l];                l++;                now=now-&gt;next;            &#125;        &#125;        return;    &#125;&#125;;\n\n\n_287. Find the Duplicate Number\n\nclass Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int n[100000]=&#123;0&#125;;        for(auto num:nums)&#123;            if(n[num-1]==0)&#123;                n[num-1]++;            &#125;else&#123;                return num;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n\n_442. Find All Duplicates in an Array\n\nclass Solution &#123;public:    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123;        map&lt;int,int&gt; list;        for(auto num:nums)&#123;            if(list.find(num)==list.end())&#123;                list[num]=1;            &#125;else&#123;                list[num]++;            &#125;        &#125;        vector&lt;int&gt; ans;        for(auto l:list)&#123;            if(l.second==2)&#123;                ans.push_back(l.first);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2024&#x2F;03&#x2F;31\n__41. First Missing Positive\n\nclass Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        int idx=0,n=nums.size();        for(;idx&lt;n;idx++)&#123;            if(nums[idx]&gt;0)&#123;                break;            &#125;        &#125;        int i=1;        for(;idx&lt;n;i++)&#123;            if(nums[idx]==i)&#123;                while(nums[idx]==i&amp;&amp;idx+1&lt;n)&#123;                    idx++;                &#125;            &#125;else&#123;                return i;            &#125;        &#125;        return i;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2023/10","url":"/2023/10/15/LeetCode/LeetCode-2023-10/","content":"2023&#x2F;10&#x2F;15\n2413. Smallest Even Multiple\n\nclass Solution &#123;public:    int smallestEvenMultiple(int n) &#123;        if(n%2==0)&#123;            return n;        &#125;else&#123;            return n*2;        &#125;    &#125;&#125;;\n\n\n2409. Count Days Spent Together\n\nclass Solution &#123;public:    int stringToDate(string time)&#123;        int month[]=&#123;0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334&#125;;        return month[(time[0]-&#x27;0&#x27;)*10+(time[1]-&#x27;0&#x27;)-1]+(time[3]-&#x27;0&#x27;)*10+(time[4]-&#x27;0&#x27;);    &#125;    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) &#123;        int lea=min(stringToDate(leaveAlice),stringToDate(leaveBob));        int arr=max(stringToDate(arriveAlice),stringToDate(arriveBob));        if(lea-arr&lt;0)&#123;            return 0;        &#125;else&#123;            return lea-arr+1;        &#125;        return 0;    &#125;&#125;;\n\n\n2455. Average Value of Even Numbers That Are Divisible by Three\n\nclass Solution &#123;public:    int averageValue(vector&lt;int&gt;&amp; nums) &#123;        int temp=0,cnt=0;        for(auto num:nums)&#123;            if(num%3==0&amp;&amp;num%2==0)&#123;                temp+=num;                cnt++;            &#125;        &#125;        if(cnt==0)&#123;            return 0;        &#125;        return temp/cnt;    &#125;&#125;;\n\n\n2485. Find the Pivot Integer\n\nclass Solution &#123;public:    int pivotInteger(int n) &#123;        int total=n*(n+1)/2;        if(n==1)return 1;        int now=0;        for(int i=1;i&lt;n;i++)&#123;            now+=i;            if(now==total)&#123;                return i;            &#125;            total-=i;        &#125;        return -1;    &#125;&#125;;\n\n\n2465. Number of Distinct Averages\n\nclass Solution &#123;public:    int distinctAverages(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;double&gt; temp;        int n=nums.size();        double now;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;n/2;i++)&#123;            now=(nums[i]+nums[n-i-1])/2.0;            if(find(temp.begin(), temp.end(), now) == temp.end())&#123;                temp.push_back(now);            &#125;        &#125;        return temp.size();    &#125;&#125;;\n\n\n2264. Largest 3-Same-Digit Number in String\n\nclass Solution &#123;public:    string largestGoodInteger(string num) &#123;        int n=num.size();        int ret=-1;        for(int i=0;i&lt;n-2;i++)&#123;            if(num[i]==num[i+1]&amp;&amp;num[i]==num[i+2])&#123;                ret=max(ret,num[i]-&#x27;0&#x27;);            &#125;        &#125;        if(ret==-1)&#123;            return &quot;&quot;;        &#125;else&#123;            string c;            c=c+char(ret+&#x27;0&#x27;)+char(ret+&#x27;0&#x27;)+char(ret+&#x27;0&#x27;);            return c;        &#125;    &#125;&#125;;\n\n\n2367. Number of Arithmetic Triplets\n\nclass Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        int cnt=0,n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[j]-nums[i]==diff)&#123;                    for(int k=j+1;k&lt;n;k++)&#123;                        if(nums[k]-nums[j]==diff)&#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;;\n\n\n2395. Find Subarrays With Equal Sum\n\nclass Solution &#123;public:    bool findSubarrays(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; s(n-1);        for(int i=0;i&lt;n-1;i++)&#123;            s[i]=nums[i]+nums[i+1];        &#125;        sort(s.begin(),s.end());        for(int i=0;i&lt;n-2;i++)&#123;            if(s[i]==s[i+1])&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n2605. Form Smallest Number From Two Digit Arrays\n\nclass Solution &#123;public:    int minNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        for(int i=1;i&lt;10;i++)&#123;            if(find(nums1.begin(),nums1.end(),i)!=nums1.end()&amp;&amp;find(nums2.begin(),nums2.end(),i)!=nums2.end())&#123;                return i;            &#125;        &#125;        int a=10,b=10;        for(auto num:nums1)&#123;            a=min(a,num);        &#125;        for(auto num:nums2)&#123;            b=min(b,num);        &#125;        if(a&gt;b)&#123;            return b*10+a;        &#125;        return a*10+b;    &#125;&#125;;\n\n\n2843. Count Symmetric Integers\n\nclass Solution &#123;public:    bool isSymmetric(int val)&#123;        if(val&lt;10)&#123;            return 0;        &#125;else if(val&lt;100)&#123;            val*=10;        &#125;else if(val&lt;1000)&#123;            return 0;        &#125;else if(val&gt;9999)&#123;            return 0;        &#125;        int a,b,c,d;        a=val%10;        val/=10;        b=val%10;        val/=10;        c=val%10;        val/=10;        d=val%10;        return a+b==c+d;    &#125;    int countSymmetricIntegers(int low, int high) &#123;        int cnt=0;        for(int i=low;i&lt;=high;i++)&#123;            cnt+=isSymmetric(i);        &#125;        return cnt;    &#125;&#125;;\n\n\n__50. pow(x, n\n\nclass Solution &#123;public:    double Pow(double x, long long n)&#123;        if(n==0) &#123;            return 1;        &#125;        if(n&lt;0) &#123;            n=-1*n;            x=1/x;        &#125;        if(n%2==0)&#123;            return Pow(x*x, n/2);        &#125;        else&#123;            return x*Pow(x, n-1);        &#125;    &#125;    double myPow(double x, int n) &#123;        return Pow(x,n);    &#125;&#125;;\n\n\n_260. Single Number III\n\nclass Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;        for(auto num:nums)&#123;            auto idx=find(ans.begin(),ans.end(),num);            if(idx==ans.end())&#123;                ans.push_back(num);            &#125;else&#123;                ans.erase(idx);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_309. Best Time to Buy and Sell Stock with Cooldown\n\nclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n=prices.size(),now;        vector&lt;int&gt; temp(n);        vector&lt;int&gt; historyMax(n);        if(n&lt;2)&#123;            return 0;        &#125;        temp[1]=max(temp[1],prices[1]-prices[0]);        historyMax[1]=temp[1];        for(int i=2;i&lt;n;i++)&#123;            for(int j=i-1;j&gt;=0;j--)&#123;                now=prices[i]-prices[j];                if(now&gt;temp[i])&#123;                    temp[i]=now;                &#125;                if(j!=0)&#123;                    if(j&gt;2)&#123;                        if(historyMax[j-2]+now&gt;temp[i])&#123;                            temp[i]=historyMax[j-2]+now;                        &#125;                    &#125;                &#125;            &#125;            historyMax[i]=max(historyMax[i-1],temp[i]);        &#125;        int ans=0;        for(auto p:temp)&#123;            ans=max(ans,p);        &#125;        return ans;    &#125;&#125;;\n\n\n2873. Maximum Value of an Ordered Triplet I\n\nclass Solution &#123;public:    long long maximumTripletValue(vector&lt;int&gt;&amp; nums) &#123;        long long ans=0,m;        int n=nums.size();        for(int i=0;i&lt;n-2;i++)&#123;            for(int j=i+1;j&lt;n-1;j++)&#123;                if(nums[i]-nums[j]&gt;0)&#123;                    m=0;                    for(int k=j+1;k&lt;n;k++)&#123;                        m=max(m,(long long)nums[k]);                    &#125;                    ans=max(ans,(long long)(nums[i]-nums[j])*m);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2875. Minimum Size Subarray in Infinite Array\n\nclass Solution &#123;public:    int minSizeSubarray(vector&lt;int&gt;&amp; nums, int target) &#123;        long long sum=0,cnt=0,loop=0,ans=2e9;        vector&lt;int&gt; temp=nums;        for(auto num:nums)&#123;            sum+=num;            cnt++;            temp.push_back(num);        &#125;        if(target%sum==0)&#123;            return (target/sum)*cnt;        &#125;        if(target&gt;sum)&#123;            loop+=(target/sum)*cnt;            target%=sum;        &#125;        int n=nums.size();        int i=0,j=1;        int now=nums[i];        while(i&lt;n&amp;&amp;j&lt;2*n)&#123;            if(now&lt;target)&#123;                now+=temp[j];                j++;            &#125;else if(now==target)&#123;                ans=min(ans,loop+j-i);                now-=temp[i];                i++;            &#125;else&#123;                now-=temp[i];                i++;            &#125;        &#125;        return ans==2e9?-1:ans;    &#125;&#125;;\n\n\n2894. Divisible and Non-divisible Sums Difference\n\nclass Solution &#123;public:    int differenceOfSums(int n, int m) &#123;        int div=0,nondiv=0;        for(int i=1;i&lt;=n;i++)&#123;            if(i%m==0)&#123;                div+=i;            &#125;else&#123;                nondiv+=i;            &#125;        &#125;        return nondiv-div;    &#125;&#125;;\n\n\n2895. Minimum Processing Time\n\nclass Solution &#123;public:    int minProcessingTime(vector&lt;int&gt;&amp; processorTime, vector&lt;int&gt;&amp; tasks) &#123;        sort(processorTime.begin(),processorTime.end());        sort(tasks.begin(),tasks.end(),greater&lt;int&gt;());        int ans=0,n=tasks.size();        for(int i=0;i&lt;n;i++)&#123;            ans=max(ans,processorTime[i/4]+tasks[i]);        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;10&#x2F;22\n2469. Convert the Temperature\n\nclass Solution &#123;public:    vector&lt;double&gt; convertTemperature(double celsius) &#123;        return &#123;celsius+273.15,celsius*1.8+32.00&#125;;    &#125;&#125;;\n\n\n2432. The Employee That Worked on the Longest Task\n\nclass Solution &#123;public:    int hardestWorker(int n, vector&lt;vector&lt;int&gt;&gt;&amp; logs) &#123;        int now=0,maxVal=0,maxIdx=0;        for(auto log:logs)&#123;            if(log[1]-now&gt;maxVal)&#123;                maxIdx=log[0];                maxVal=log[1]-now;            &#125;else if(log[1]-now==maxVal)&#123;                maxIdx=min(maxIdx,log[0]);            &#125;            now=log[1];        &#125;        return maxIdx;    &#125;&#125;;\n\n\n2578. Split With Minimum Sum\n\nclass Solution &#123;public:    int splitNum(int num) &#123;        vector&lt;int&gt; val;        while(num&gt;0)&#123;            val.push_back(num%10);            num/=10;        &#125;        sort(val.begin(),val.end());        int a=0,b=0;        int n=val.size();        for(int i=0;i&lt;n;i++)&#123;            if(i%2==0)&#123;                a=a*10+val[i];            &#125;else&#123;                b=b*10+val[i];            &#125;        &#125;        return a+b;    &#125;&#125;;\n\n\n2481. Minimum Cuts to Divide a Circle\n\nclass Solution &#123;public:    int numberOfCuts(int n) &#123;        if(n==1)&#123;            return 0;        &#125;        return n%2==1?n:n/2;    &#125;&#125;;\n\n\n2639. Find the Width of Columns of a Grid\n\nclass Solution &#123;public:    int lengthOfValue(int v)&#123;        int cnt=1;        if(v&lt;0)&#123;            cnt++;            v*=-1;        &#125;        while(v&gt;9)&#123;            cnt++;            v/=10;        &#125;        return cnt;    &#125;    vector&lt;int&gt; findColumnWidth(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m=grid.size(),n=grid[0].size(),maxL;        vector&lt;int&gt; ans;        for(int i=0;i&lt;n;i++)&#123;            maxL=0;            for(int j=0;j&lt;m;j++)&#123;                maxL=max(maxL,lengthOfValue(grid[j][i]));            &#125;            ans.push_back(maxL);        &#125;        return ans;    &#125;&#125;;\n\n\n1093. Statistics from a Large Sample\n\nclass Solution &#123;public:    vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) &#123;        vector&lt;pair&lt;int,int&gt;&gt; nums;        double total=0,minV=256,maxV=0,maxCntVal=0,median,now;        int maxCnt=0,cnt=0;        for(int i=0;i&lt;256;i++)&#123;            now=count[i];            if(now&gt;0)&#123;                total+=i*now;                cnt+=now;                nums.push_back(&#123;i,cnt&#125;);                minV=min(minV,i*1.0);                maxV=max(maxV,i*1.0);                if(now&gt;maxCnt)&#123;                    maxCnt=now;                    maxCntVal=i;                &#125;            &#125;        &#125;        for(auto num:nums)&#123;            if(num.second&gt;cnt/2)&#123;                median=num.first;                break;            &#125;        &#125;        if(cnt%2==0)&#123;            for(auto num:nums)&#123;                if(num.second&gt;=cnt/2)&#123;                    median=(median+num.first)/2;                    break;                &#125;            &#125;        &#125;        return &#123;minV,maxV,total/cnt,median,maxCntVal&#125;;    &#125;&#125;;\n\n\n2903. Find Indices With Index and Value Difference I\n\nclass Solution &#123;public:    vector&lt;int&gt; findIndices(vector&lt;int&gt;&amp; nums, int indexDifference, int valueDifference) &#123;        int n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            for(int j=i;j&lt;n;j++)&#123;                if(abs(i-j)&gt;=indexDifference&amp;&amp;abs(nums[i]-nums[j])&gt;=valueDifference)&#123;                    return &#123;i,j&#125;;                &#125;            &#125;        &#125;        return &#123;-1,-1&#125;;    &#125;&#125;;\n\n\n2904. Shortest and Lexicographically Smallest Beautiful String\n\nclass Solution &#123;public:    string chooseBetter(string a,string b)&#123;        if(a==&quot;&quot;)&#123;            return b;        &#125;        if(a.size()==b.size())&#123;            int n=a.size();            for(int i=0;i&lt;n;i++)&#123;                if(a[i]&gt;b[i])&#123;                    return b;                &#125;else if(a[i]&lt;b[i])&#123;                    return a;                &#125;            &#125;        &#125;else if(a.size()&gt;b.size())&#123;            return b;        &#125;        return a;    &#125;    string shortestBeautifulSubstring(string s, int k) &#123;        string ans=&quot;&quot;,now=&quot;&quot;;        int i=0,j=0,n=s.size(),cnt=0;        while(i&lt;n&amp;&amp;j&lt;n)&#123;            cnt+=(s[i]==&#x27;1&#x27;);            now+=s[i];            i++;            if(cnt==k)&#123;                if(now[0]==&#x27;1&#x27;)&#123;                    ans=chooseBetter(ans,now);                    cnt--;                    now.erase(0,1);                &#125;else&#123;                    while(now[0]==&#x27;0&#x27;)&#123;                        ans=chooseBetter(ans,now);                        now.erase(0,1);                    &#125;                    ans=chooseBetter(ans,now);                    cnt--;                    now.erase(0,1);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2905. Find Indices With Index and Value Difference II\n\nclass Solution &#123;public:    vector&lt;int&gt; findIndices(vector&lt;int&gt;&amp; nums, int indexDifference, int valueDifference) &#123;        int minIdx=0,maxIdx=0,n=nums.size();        for(int i=indexDifference;i&lt;n;i++)&#123;            if(nums[i-indexDifference]&lt;nums[minIdx])&#123;                minIdx=i-indexDifference;            &#125;            if(nums[i-indexDifference]&gt;nums[maxIdx])&#123;                maxIdx=i-indexDifference;            &#125;            if(nums[i]-nums[minIdx]&gt;=valueDifference)&#123;                return &#123;minIdx,i&#125;;            &#125;            if(nums[maxIdx]-nums[i]&gt;=valueDifference)&#123;                return &#123;maxIdx,i&#125;;            &#125;        &#125;        return &#123;-1,-1&#125;;    &#125;&#125;;\n\n\n2906. Construct Product Matrix\n\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; constructProductMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n=grid.size(),m=grid[0].size(),mod=12345;        long long p=1;        vector&lt;vector&lt;int&gt;&gt; ans(n,vector&lt;int&gt;(m));        vector&lt;vector&lt;int&gt;&gt; totalX(n,vector&lt;int&gt;(m));        vector&lt;vector&lt;int&gt;&gt; totalY(n,vector&lt;int&gt;(m));        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                totalX[i][j]=p;                p=(p*grid[i][j])%mod;            &#125;        &#125;        p=1;        for(int i=n-1;i&gt;=0;i--)&#123;            for(int j=m-1;j&gt;=0;j--)&#123;                totalY[i][j]=p;                p=(p*grid[i][j])%mod;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                ans[i][j]=(totalX[i][j]*totalY[i][j])%mod;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;10&#x2F;29\n2000. Reverse Prefix of Word\n\nclass Solution &#123;public:    string reversePrefix(string word, char ch) &#123;        int idx=0,n=word.size();        bool rev=true;        string ans;        for(;idx&lt;n;idx++)&#123;            ans+=word[idx];            if(word[idx]==ch&amp;&amp;rev)&#123;                reverse(ans.begin(),ans.end());                rev=false;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2287. Rearrange Characters to Make Target String\n\nclass Solution &#123;public:    int rearrangeCharacters(string s, string target) &#123;        vector&lt;int&gt; s_cnt(26);        vector&lt;int&gt; t_cnt(26);        for(auto c:s)&#123;            s_cnt[c-&#x27;a&#x27;]++;        &#125;        for(auto c:target)&#123;            t_cnt[c-&#x27;a&#x27;]++;        &#125;        int ans=1e9;        for(int i=0;i&lt;26;i++)&#123;            if(t_cnt[i]&gt;0)&#123;                ans=min(ans,s_cnt[i]/t_cnt[i]);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n1848. Minimum Distance to the Target Element\n\nclass Solution &#123;public:    int getMinDistance(vector&lt;int&gt;&amp; nums, int target, int start) &#123;        int ans=1e9,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]==target)&#123;                ans=min(ans,abs(i-start));            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2562. Find the Array Concatenation Value\n\nclass Solution &#123;public:    long long sizeOfVal(int n)&#123;        int ret=1;        while(n&gt;0)&#123;            ret*=10;            n/=10;        &#125;        return ret;    &#125;    long long findTheArrayConcVal(vector&lt;int&gt;&amp; nums) &#123;        int i=0,j=nums.size()-1;        long long ans=0;        while(i&lt;j)&#123;            ans+=nums[i]*sizeOfVal(nums[j])+nums[j];            i++;            j--;        &#125;        if(i==j)&#123;            ans+=nums[i];        &#125;        return ans;    &#125;&#125;;\n\n\n2108. Find First Palindromic String in the Array\n\nclass Solution &#123;public:    bool isPalindrome(string word)&#123;        string rev=word;        reverse(rev.begin(),rev.end());        int n=word.size();        for(int i=0;i&lt;n;i++)&#123;            if(word[i]!=rev[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;    string firstPalindrome(vector&lt;string&gt;&amp; words) &#123;        for(auto word:words)&#123;            if(isPalindrome(word))&#123;                return word;            &#125;        &#125;        return &quot;&quot;;    &#125;&#125;;\n\n\n1315. Sum of Nodes with Even-Valued Grandparent\n\nclass Solution &#123;public:    void findAns(int&amp; ans,TreeNode* root,bool parent,bool grand)&#123;        if(root==NULL)&#123;            return;        &#125;        if(grand)&#123;            ans+=root-&gt;val;        &#125;        findAns(ans,root-&gt;left,root-&gt;val%2==0,parent);        findAns(ans,root-&gt;right,root-&gt;val%2==0,parent);    &#125;    int sumEvenGrandparent(TreeNode* root) &#123;        int ans=0;        findAns(ans,root-&gt;left,root-&gt;val%2==0,false);        findAns(ans,root-&gt;right,root-&gt;val%2==0,false);        return ans;    &#125;&#125;;\n\n\n2908. Minimum Sum of Mountain Triplets I\n\nclass Solution &#123;public:    int minimumSum(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; l(n,1e9),r(n,1e9);        int lmin=nums[0],rmin=nums[n-1];        for(int i=0;i&lt;n;i++)&#123;            lmin=min(lmin,nums[i]);            l[i]=lmin;        &#125;        for(int i=n-1;i&gt;=0;i--)&#123;            rmin=min(rmin,nums[i]);            r[i]=rmin;        &#125;        int ans=1e9;        for(int i=1;i&lt;n-1;i++)&#123;            if(l[i]&lt;nums[i]&amp;&amp;r[i]&lt;nums[i])&#123;                ans=min(ans,nums[i]+l[i]+r[i]);            &#125;        &#125;        if(ans==1e9)&#123;            return -1;        &#125;        return ans;    &#125;&#125;;\n\n\n2909. Minimum Sum of Mountain Triplets II\n\nclass Solution &#123;public:    int minimumSum(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; l(n,1e9),r(n,1e9);        int lmin=nums[0],rmin=nums[n-1];        for(int i=0;i&lt;n;i++)&#123;            lmin=min(lmin,nums[i]);            l[i]=lmin;        &#125;        for(int i=n-1;i&gt;=0;i--)&#123;            rmin=min(rmin,nums[i]);            r[i]=rmin;        &#125;        int ans=1e9;        for(int i=1;i&lt;n-1;i++)&#123;            if(l[i]&lt;nums[i]&amp;&amp;r[i]&lt;nums[i])&#123;                ans=min(ans,nums[i]+l[i]+r[i]);            &#125;        &#125;        if(ans==1e9)&#123;            return -1;        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2023/11","url":"/2023/11/05/LeetCode/LeetCode-2023-11/","content":"2023&#x2F;11&#x2F;05\n1768. Merge Strings Alternately\n\nclass Solution &#123;public:    string mergeAlternately(string word1, string word2) &#123;        int idx1=0,idx2=0,size1=word1.length(),size2=word2.length();        string ans;        while(idx1&lt;size1||idx2&lt;size2)&#123;            if(idx1&lt;size1)&#123;                ans+=word1[idx1];                idx1++;            &#125;            if(idx2&lt;size2)&#123;                ans+=word2[idx2];                idx2++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n1071. Greatest Common Divisor of Strings\n\nclass Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        string now,ans=&quot;&quot;,longString,shortString;        if(str1.size()&lt;str2.size())&#123;            longString=str2;            shortString=str1;        &#125;        else&#123;            longString=str1;            shortString=str2;        &#125;        bool chk;        for(auto c:shortString)&#123;            now+=c;            chk=true;            for(int i=0;i&lt;shortString.size();i+=now.size())&#123;                if(shortString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(shortString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            for(int i=0;i&lt;longString.size();i+=now.size())&#123;                if(longString.substr(i,now.size()).size()==now.size())&#123;                    // cout&lt;&lt;shortString.substr(i,now.size())&lt;&lt;endl;                    if(longString.substr(i,now.size())!=now)&#123;                        chk=false;                    &#125;                &#125;else&#123;                    chk=false;                &#125;            &#125;            if(chk&amp;&amp;longString.size()%now.size()==0&amp;&amp;shortString.size()%now.size()==0)&#123;                // cout&lt;&lt;now&lt;&lt;endl;                ans=now;            &#125;            // cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n\n\n1431. Kids With the Greatest Number of Candies\n\nclass Solution &#123;public:    vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123;        int n=candies.size();        vector&lt;bool&gt; ans(n);        int chk;        for(int i=0;i&lt;n;i++)&#123;            chk=true;            for(auto c:candies)&#123;                if(candies[i]+extraCandies&lt;c)&#123;                    chk=false;                &#125;            &#125;            ans[i]=chk;        &#125;        return ans;    &#125;&#125;;\n\n\n_605. Can Place Flowers\n\nclass Solution &#123;public:    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;        if(flowerbed.size()==1&amp;&amp;flowerbed[0]==0)&#123;            flowerbed[0]=1;            n--;        &#125;        else&#123;            for(int i=0;i&lt;flowerbed.size();i++)&#123;                if(i==0&amp;&amp;flowerbed[i]==0&amp;&amp;flowerbed[i+1]==0)&#123;                    flowerbed[i]=1;                    n--;                &#125;                else if(i==flowerbed.size()-1&amp;&amp;flowerbed[i]==0&amp;&amp;flowerbed[i-1]==0)&#123;                    flowerbed[i]=1;                    n--;                &#125;                else if(i!=0&amp;&amp;i!=flowerbed.size()-1&amp;&amp;flowerbed[i-1]+flowerbed[i]+flowerbed[i+1]==0)&#123;                    flowerbed[i]=1;                    n--;                &#125;            &#125;        &#125;        if(n&gt;0)&#123;            return false;        &#125;        else&#123;            return true;        &#125;    &#125;&#125;;\n\n\n_345. Reverse Vowels of a String\n\nclass Solution &#123;public:    string reverseVowels(string s) &#123;        string ans;        int n=s.size();        int left=n-1;        for(int i=0;i&lt;n;i++)&#123;            if(s[i]==&#x27;a&#x27;||s[i]==&#x27;e&#x27;||s[i]==&#x27;i&#x27;||s[i]==&#x27;o&#x27;||s[i]==&#x27;u&#x27;||s[i]==&#x27;A&#x27;||s[i]==&#x27;E&#x27;||s[i]==&#x27;I&#x27;||s[i]==&#x27;O&#x27;||s[i]==&#x27;U&#x27;)&#123;                while(s[left]!=&#x27;a&#x27;&amp;&amp;s[left]!=&#x27;e&#x27;&amp;&amp;s[left]!=&#x27;i&#x27;&amp;&amp;s[left]!=&#x27;o&#x27;&amp;&amp;s[left]!=&#x27;u&#x27;&amp;&amp;s[left]!=&#x27;A&#x27;&amp;&amp;s[left]!=&#x27;E&#x27;&amp;&amp;s[left]!=&#x27;I&#x27;&amp;&amp;s[left]!=&#x27;O&#x27;&amp;&amp;s[left]!=&#x27;U&#x27;)&#123;                    left--;                &#125;                ans+=s[left];                left--;            &#125;else&#123;                ans+=s[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_151. Reverse Words in a String\n\nclass Solution &#123;public:    string reverseWords(string s) &#123;        stringstream input;        string now,ans;        input&lt;&lt;s;        while(true)&#123;            input&gt;&gt;now;            if(input.fail()) break;            if(ans==&quot;&quot;)&#123;                ans=now;            &#125;else&#123;                ans=now+&quot; &quot;+ans;            &#125;            cout&lt;&lt;now&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;\n\n\n2917. Find the K-or of an Array\n\nclass Solution &#123;public:    int findKOr(vector&lt;int&gt;&amp; nums, int k) &#123;        int cnt,ans=0,n=nums.size();        for(int i=0;i&lt;31;i++)&#123;            cnt=0;            for(int j=0;j&lt;n;j++)&#123;                cnt+=nums[j]%2;                nums[j]/=2;            &#125;            if(cnt&gt;=k)&#123;                ans+=pow(2,i);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2918. Minimum Equal Sum of Two Arrays After Replacing Zeros\n\nclass Solution &#123;public:    long long minSum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        long long total1=0,total2=0;        int zero1=0,zero2=0;        for(auto num:nums1)&#123;            if(num==0)&#123;                zero1++;            &#125;else&#123;                total1+=num;            &#125;        &#125;        for(auto num:nums2)&#123;            if(num==0)&#123;                zero2++;            &#125;else&#123;                total2+=num;            &#125;        &#125;        cout&lt;&lt;total1&lt;&lt;&#x27; &#x27;&lt;&lt;zero1&lt;&lt;endl;        cout&lt;&lt;total2&lt;&lt;&#x27; &#x27;&lt;&lt;zero2&lt;&lt;endl;        if(zero1!=0&amp;&amp;zero2!=0)&#123;            return max(total1+zero1,total2+zero2);        &#125;else if(zero1==0&amp;&amp;zero2!=0)&#123;            if(total1&gt;=total2+zero2)&#123;                return total1;            &#125;        &#125;else if(zero1!=0&amp;&amp;zero2==0)&#123;            if(total2&gt;=total1+zero1)&#123;                return total2;            &#125;        &#125;else&#123;            if(total1==total2)&#123;                return total1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n2023&#x2F;11&#x2F;12\n_283. Move Zeroes\n\nclass Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int idx=0;        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums[i]==0)&#123;                for(int j=i+1;j&lt;nums.size();j++)&#123;                    if(nums[j]!=0)&#123;                        nums[i]=nums[j];                        nums[j]=0;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;;\n\n\n_392. Is Subsequence\n\nclass Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        int idx=0;        for(auto c:t)&#123;            if(s[idx]==c)&#123;                idx++;            &#125;        &#125;        return idx==s.length();    &#125;&#125;;\n\n\n_643. Maximum Average Subarray I\n\nclass Solution &#123;public:    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123;        double sum=0,ans=-100000;        int n=nums.size();        for(int i=0;i&lt;k-1;i++)&#123;            sum+=nums[i];        &#125;        for(int i=k-1;i&lt;n;i++)&#123;            sum+=nums[i];            ans=max(ans,sum/k);            sum-=nums[i-k+1];        &#125;        return ans;    &#125;&#125;;\n\n\n1732. Find the Highest Altitude\n\nclass Solution &#123;public:    int largestAltitude(vector&lt;int&gt;&amp; gain) &#123;        int ans=0,now=0;        for(auto g:gain)&#123;            now+=g;            ans=max(ans,now);        &#125;        return ans;    &#125;&#125;;\n\n\n_724. Find Pivot Index\n\nclass Solution &#123;public:    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;        int left=0,right=0,idx=0;        for(auto n:nums)&#123;            right+=n;        &#125;        for(auto n:nums)&#123;            if(left==right-n)&#123;                return idx;            &#125;            left+=n;            right-=n;            idx++;        &#125;        return -1;    &#125;&#125;;\n\n\n_238. Product of Array Except Self\n\nclass Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; ans(n),left(n),right(n);        left[0]=1;        right[n-1]=1;        for(int i=1;i&lt;n-1;i++)&#123;            left[i]=nums[i-1]*left[i-1];            right[n-i-1]=nums[n-i]*right[n-i];        &#125;        left[n-1]=nums[n-2]*left[n-2];        right[0]=nums[1]*right[1];        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;left[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        // for(int i=0;i&lt;n;i++)&#123;        //     cout&lt;&lt;right[i]&lt;&lt;&#x27; &#x27;;        // &#125;cout&lt;&lt;endl;        for(int i=0;i&lt;n;i++)&#123;            ans[i]=right[i]*left[i];        &#125;        return ans;    &#125;&#125;;\n\n\n2923. Find Champion I\n\nclass Solution &#123;public:    int findChampion(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans=0,cnt=0,max_cnt=0,n=grid.size();        for(int i=0;i&lt;n;i++)&#123;            cnt=0;            for(auto g:grid[i])&#123;                cnt+=g;            &#125;            if(cnt&gt;max_cnt)&#123;                ans=i;                max_cnt=cnt;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2024/04","url":"/2024/04/07/LeetCode/LeetCode-2024-04/","content":"2024&#x2F;04&#x2F;07\n_205. Isomorphic Strings\n\nclass Solution &#123;   public:    bool isIsomorphic(string s, string t) &#123;        int len = s.length();        bool chk;        for (int i = 1; i &lt; len; i++) &#123;            if (s.find(s[i]) != t.find(t[i])) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n\n1544. Make The String Great\n\nclass Solution &#123;   public:    string makeGood(string s) &#123;        for (int i = 0; i &lt; s.size() - 1 &amp;&amp; s != &quot;&quot;; i++) &#123;            if (abs(s[i + 1] - s[i]) == 32) &#123;                s.erase(i, 2);                i = -1;            &#125;        &#125;        return s;    &#125;&#125;;\n\n\n1249. Minimum Remove to Make Valid Parentheses\n\nclass Solution &#123;   public:    string minRemoveToMakeValid(string s) &#123;        int left = 0, right = 0;        for (int i = 0; i &lt; s.size(); i++) &#123;            if (s[i] == &#x27;(&#x27;) &#123;                left++;            &#125; else if (s[i] == &#x27;)&#x27;) &#123;                if (left == 0 || left == right) &#123;                    s.erase(i, 1);                    i--;                &#125; else &#123;                    right++;                &#125;            &#125;        &#125;        for (int i = s.size() - 1; left &gt; right &amp;&amp; i &gt;= 0; i--) &#123;            if (s[i] == &#x27;(&#x27;) &#123;                s.erase(i, 1);                i++;                left--;            &#125;        &#125;        return s;    &#125;&#125;;\n\n2023&#x2F;04&#x2F;14\n_771. Jewels and Stones\n\nclass Solution &#123;   public:    int numJewelsInStones(string jewels, string stones) &#123;        int ans = 0;        for (auto c : stones) ans += jewels.find(c) != string::npos;        return ans;    &#125;&#125;;\n\n\n__42. Trapping Rain Water\n\nclass Solution &#123;   public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n = height.size() - 1;        int leftMax = height[0], rightMax = height[n];        vector&lt;int&gt; left(n + 1), right(n + 1);        for (int i = 0; i &lt;= n; i++) &#123;            if (height[i] &gt; leftMax) &#123;                leftMax = height[i];            &#125; else &#123;                left[i] = leftMax - height[i];            &#125;            if (height[n - i] &gt; rightMax) &#123;                rightMax = height[n - i];            &#125; else &#123;                right[n - i] = rightMax - height[n - i];            &#125;        &#125;        int ans = 0;        for (int i = 0; i &lt;= n; i++) &#123;            ans += min(left[i], right[i]);        &#125;        return ans;    &#125;&#125;;\n\n\n_404. Sum of Left Leaves\n\nclass Solution &#123;   public:    int calcLeft(TreeNode* root) &#123;        int val = 0;        if (root-&gt;left != NULL) &#123;            if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) &#123;                val += root-&gt;left-&gt;val;            &#125; else &#123;                val += calcLeft(root-&gt;left);            &#125;        &#125;        if (root-&gt;right != NULL) &#123;            val += calcLeft(root-&gt;right);        &#125;        return val;    &#125;    int sumOfLeftLeaves(TreeNode* root) &#123; return calcLeft(root); &#125;&#125;;\n\n\n3114. Latest Time You Can Obtain After Replacing Characters\n\nclass Solution &#123;   public:    string findLatestTime(string s) &#123;        if (s[0] == &#x27;?&#x27;) &#123;            if (s[1] == &#x27;?&#x27;) &#123;                s[0] = &#x27;1&#x27;;                s[1] = &#x27;1&#x27;;            &#125; else if (s[1] &lt;= &#x27;1&#x27;) &#123;                s[0] = &#x27;1&#x27;;            &#125; else &#123;                s[0] = &#x27;0&#x27;;            &#125;        &#125;        if (s[1] == &#x27;?&#x27;) &#123;            if (s[0] == &#x27;0&#x27;) &#123;                s[1] = &#x27;9&#x27;;            &#125; else &#123;                s[1] = &#x27;1&#x27;;            &#125;        &#125;        if (s[3] == &#x27;?&#x27;) &#123;            s[3] = &#x27;5&#x27;;        &#125;        if (s[4] == &#x27;?&#x27;) &#123;            s[4] = &#x27;9&#x27;;        &#125;        return s;    &#125;&#125;;\n\n\n3115. Maximum Prime Difference\n\nclass Solution &#123;   public:    bool isPrime(int a) &#123;        for (int i = a - 1; i &gt; 1; i--) &#123;            if (a % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;    int maximumPrimeDifference(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; prime;        prime.push_back(2);        for (int i = 3; i &lt; 100; i++) &#123;            if (isPrime(i)) &#123;                prime.push_back(i);            &#125;        &#125;        int left = 0, right = nums.size() - 1;        while (find(prime.begin(), prime.end(), nums[left]) == prime.end()) &#123;            left++;        &#125;        while (find(prime.begin(), prime.end(), nums[right]) == prime.end()) &#123;            right--;        &#125;        cout &lt;&lt; left &lt;&lt; &#x27; &#x27; &lt;&lt; right &lt;&lt; endl;        return right - left;    &#125;&#125;;\n\n2023&#x2F;04&#x2F;28\n310. Minimum Height Trees\n\nclass Solution &#123;   public:    vector&lt;vector&lt;int&gt;&gt; tree;    vector&lt;int&gt; treeCnt;    vector&lt;int&gt; maxDepth(vector&lt;int&gt; leafs) &#123;        vector&lt;int&gt; newLeafs;        for (auto leaf : leafs) &#123;            for (auto node : tree[leaf]) &#123;                if (treeCnt[node] != 0) &#123;                    treeCnt[node]--;                    if (treeCnt[node] == 1) &#123;                        newLeafs.push_back(node);                    &#125;                &#125;            &#125;        &#125;        if (newLeafs.size() == 0) &#123;            return leafs;        &#125;        return maxDepth(newLeafs);    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if (n == 1) &#123;            return &#123;0&#125;;        &#125;        tree.resize(n);        treeCnt.resize(n);        for (auto edge : edges) &#123;            tree[edge[0]].push_back(edge[1]);            tree[edge[1]].push_back(edge[0]);            treeCnt[edge[0]]++;            treeCnt[edge[1]]++;        &#125;        vector&lt;int&gt; leafs;        for (int i = 0; i &lt; treeCnt.size(); i++) &#123;            if (treeCnt[i] == 1) &#123;                treeCnt[i]--;                leafs.push_back(i);            &#125;        &#125;        return maxDepth(leafs);    &#125;&#125;;\n\n\n1137. N-th Tribonacci Number\n\nclass Solution &#123;   public:    int tribonacci(int n) &#123;        int T[38];        T[0] = 0;        T[1] = 1;        T[2] = 1;        for (int i = 3; i &lt;= n; i++) &#123;            T[i] = T[i - 3] + T[i - 2] + T[i - 1];        &#125;        return T[n];    &#125;&#125;;\n\n\n2370. Longest Ideal Subsequence\n\nclass Solution &#123;   public:    int longestIdealString(string s, int k) &#123;        int n = s.size(), ans = 0, temp = 0, nowWordIdx;        vector&lt;int&gt; cnt(26, 0);        for (int i = 0; i &lt; n; i++) &#123;            temp = 0;            nowWordIdx = s[i] - &#x27;a&#x27;;            for (int j = max(nowWordIdx - k, 0); j &lt;= min(nowWordIdx + k, 25); j++) &#123;                if (cnt[j] &gt; temp) &#123;                    temp = cnt[j];                &#125;            &#125;            cnt[nowWordIdx] = temp + 1;            ans = max(ans, temp + 1);        &#125;        return ans;    &#125;&#125;;\n\n\n3131. Find the Integer Added to Array I\n\nclass Solution &#123;   public:    int addedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int sum1 = 0, sum2 = 0, n = nums1.size();        for (auto num : nums1) &#123;            sum1 += num;        &#125;        for (auto num : nums2) &#123;            sum2 += num;        &#125;        return (sum2 - sum1) / n;    &#125;&#125;;\n\n\n3132. Find the Integer Added to Array II\n\nclass Solution &#123;public:    int minimumAddedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int sum1=0,sum2=0,n1=nums1.size(),n2=nums2.size(),idx2;        sort(nums1.begin(),nums1.end());        sort(nums2.begin(),nums2.end());        for(auto num:nums1)&#123;            sum1+=num;        &#125;        for(auto num:nums2)&#123;            sum2+=num;        &#125;        int temp;        for(int i=0;i&lt;n1;i++)&#123;            for(int j=i+1;j&lt;n1;j++)&#123;                temp=(sum2-sum1+nums1[i]+nums1[j])/n2;                idx2=0;                for(int k=0;j&lt;n1&amp;&amp;idx2&lt;n2;k++)&#123;                    if(k==i||k==j)&#123;                        continue;                    &#125;                    if(nums2[idx2]-nums1[k]==temp)&#123;                        idx2++;                    &#125;else&#123;                        break;                    &#125;                &#125;                if(idx2==n2)&#123;                    return temp;                &#125;            &#125;        &#125;        return 0;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode 2024/05/05","url":"/2024/05/02/LeetCode/LeetCode-2024-05-05/","content":"2024&#x2F;04&#x2F;07\n2997. Minimum Number of Operations to Make Array XOR Equal to K\n\nclass Solution &#123;   public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) &#123;        int temp = k;        for (auto num : nums) &#123;            temp ^= num;        &#125;        int ans = 0;        while (temp &gt; 0) &#123;            ans += temp % 2;            temp = temp &gt;&gt; 1;        &#125;        return ans;    &#125;&#125;;\n\n\n2000. Reverse Prefix of Word\n\nclass Solution &#123;   public:    string reversePrefix(string word, char ch) &#123;        int n = word.size();        for (int idx = 0; idx &lt; n; idx++) &#123;            if (word[idx] == ch) &#123;                reverse(word.begin(), word.begin() + idx + 1);                break;            &#125;        &#125;        return word;    &#125;&#125;;\n\n\n2441. Largest Positive Integer That Exists With Its Negative\n\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        int table[1001] = &#123;0&#125;;        int ans = -1;        for (auto num : nums) &#123;            if (num &gt; 0) &#123;                if (table[num] == 0 || table[num] == 2) &#123;                    table[num] += 1;                &#125;            &#125; else &#123;                if (table[-num] == 0 || table[-num] == 1) &#123;                    table[-num] += 2;                &#125;            &#125;            cout &lt;&lt; table[abs(num)] &lt;&lt; endl;            if (table[abs(num)] == 3) &#123;                ans = max(ans, abs(num));            &#125;        &#125;        return ans;    &#125;&#125;;\n\nclass Solution &#123;   public:    static bool cmp(int a, int b) &#123;        if (abs(a) == abs(b)) &#123;            return a &gt; b;        &#125;        return abs(a) &gt; abs(b);    &#125;    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end(), cmp);        int n = nums.size();        for (int i = 0; i &lt; n - 1; i++) &#123;            if (nums[i] == -nums[i + 1]) &#123;                return nums[i];            &#125;        &#125;        return -1;    &#125;&#125;;\n\nclass Solution &#123;   public:    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        int left = 0, right = nums.size() - 1;        while (left &lt; right) &#123;            if (nums[left] * -1 == nums[right]) &#123;                return nums[right];            &#125; else if (nums[left] * -1 &lt; nums[right]) &#123;                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return -1;    &#125;&#125;;\n","categories":["LeetCode"]},{"title":"LeetCode-Writeup 310. Minimum Height Trees","url":"/2024/04/25/LeetCode-Writeup/LeetCode-Writeup-310-Minimum-Height-Trees/","content":"Minimum Height Trees這題問題不難，難在要如何在時間內完成。\nSolution 1 TLE 70&#x2F;71Main function先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    dict[edge[0]].push_back(edge[1]);    dict[edge[1]].push_back(edge[0]);    dictCnt[edge[0]]++;    dictCnt[edge[1]]++;&#125;\n\n再來就是從第 0 個節點開始，迴圈找跟第 0 個節點連結的節點後，用遞迴的方式往下尋找以第 0 個節點為首的最常深度，以下用第 0 個節點開始作為範例。如果當前節點連結數只有 1，代表他只和第 0 個節點有連接，因此不須往下檢查。\nif (dictCnt[i] == 1) &#123;    continue;&#125;\n\n如果有大於 1 的連接數，則可繼續往下，檢查第 0 個節點是否有更深的深度。depth 為當前節點所記錄的深度，ansDepth 為整體最短深度，當前節點深度已經大於記錄到的最短深度時，則代表一定不會是答案，則跳出了不需浪費時間檢查。\nfor (auto now : dict[i]) &#123;    depth = max(depth, maxDepth(i, now, ansDepth));    if (depth &gt; ansDepth) &#123;        break;    &#125;&#125;\n\n因為題目是要找出哪些節點做為根節點有最低深度，因此如果當前節點深度與目前最低深度的節點相同，則同為答案，如果小於最低深度，代表有更小深度的根節點，則最小深度要重新記錄。\nif (depth == ansDepth) &#123;    ans.push_back(i);&#125; else if (depth &lt; ansDepth) &#123;    ansDepth = depth;    ans = &#123;i&#125;;&#125;\n\nRecursion那我的要遞迴什麼?當找到子節點又有除了根節點以外的連結，則須往下檢查深度。參數有三個：根節點值、當前節點值、最低深度\n先用一個 for 迴圈，去尋訪一次當前節點有的所有連接節點。如果當前節點的連接只有 1，代表只和根節點有連接，因此不必浪費時間檢查。\nfor (auto node : dict[now]) &#123;    if (dictCnt[node] == 1) &#123;        continue;    &#125;    .    .    .\n\n如果當前節點的子節點為根節點，則跳過，反之其他都要往下尋找，如果當前深度已經大於目前最低深度了，則可提前跳出。\nif (node != last) &#123;    depth = max(depth, maxDepth(now, node, ansDepth));    if (ansDepth &lt; depth) &#123;        return depth + 1;    &#125;&#125;\n\n最後回傳深度，只當前節點(1)加上當前節點的深度(depth)。\nreturn 1 + depth;\n\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; dict;    vector&lt;int&gt; dictCnt;    int maxDepth(int last, int now, int ansDepth) &#123;        int depth = 0;        for (auto node : dict[now]) &#123;            if (dictCnt[node] == 1) &#123;                continue;            &#125;            if (node != last) &#123;                depth = max(depth, maxDepth(now, node, ansDepth));                if (ansDepth &lt; depth) &#123;                    return depth + 1;                &#125;            &#125;        &#125;        return 1 + depth;    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if(edges.size()==1)&#123;            return edges[0];        &#125;        dict.resize(n);        dictCnt.resize(n);        for (auto edge : edges) &#123;            dict[edge[0]].push_back(edge[1]);            dict[edge[1]].push_back(edge[0]);            dictCnt[edge[0]]++;            dictCnt[edge[1]]++;        &#125;        int minDepth = INT_MAX, ansDepth = INT_MAX, depth;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; i++) &#123;            depth = 1;            if (dictCnt[i] == 1) &#123;                continue;            &#125;            for (auto now : dict[i]) &#123;                depth = max(depth, maxDepth(i, now, ansDepth));                if (depth &gt; ansDepth) &#123;                    break;                &#125;            &#125;            if (depth == ansDepth) &#123;                ans.push_back(i);            &#125; else if (depth &lt; ansDepth) &#123;                ansDepth = depth;                ans = &#123;i&#125;;            &#125;        &#125;        return ans;    &#125;&#125;;\n\nSolution 2Main function上述方法會超時，因為你從根節點出發，你無法得知多久會到子節點，因此另外一個想法為從子節點出發到根節點。\n先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\nfor (auto edge : edges) &#123;    tree[edge[0]].push_back(edge[1]);    tree[edge[1]].push_back(edge[0]);    treeCnt[edge[0]]++;    treeCnt[edge[1]]++;&#125;\n\n透過紀錄節點連接數量的 vector，找尋連接只有 1 的節點，因為這些節點只有與他們的根節點連接，因此連接數只有 1。\n端節點：只連結數只有 1 個末端節點這裡的 leafs 則是用做記錄所有端節點\nvector&lt;int&gt; leafs;for (int i = 0; i &lt; treeCnt.size(); i++) &#123;    if (treeCnt[i] == 1) &#123;        treeCnt[i]--;        leafs.push_back(i);    &#125;&#125;\n\nRecursion遞迴的概念是要將每次的端節點拔除後，如果他的根節點變為端節點，則在下一輪拔除，拔到最後一層節點沒根節點後，則他們都是根節點。參數有一個：當前的端節點\n首先先尋訪與當前端節點有連接的節點，如果當前節點的連接數不為 0，代表還有連接，則需進一步執行。\nfor (auto leaf : leafs) &#123;    for (auto node : tree[leaf]) &#123;        if (treeCnt[node] != 0) &#123;            ...        &#125;    &#125;&#125;\n\n接下來就是要在當前節點的數量減一，把當前節點與端節點拔除。當此時當前節點變為 1 時，代表他又只與一個根節點連接，因此把它作為新的端節點。\nif (treeCnt[node] != 0) &#123;    treeCnt[node]--;    if (treeCnt[node] == 1) &#123;        newLeafs.push_back(node);    &#125;&#125;\n\n最後，如果沒有新的端節點產生，則代表已經到了最後一層了，因此剩餘的都是最後一層根節點，也就是答案。如果還有新的端節點，則需在往下檢查下一層的節點。\nif (newLeafs.size() == 0) &#123;    return leafs;&#125;return maxDepth(newLeafs);\n\nConclusion第二個方法能通，是因為不是去檢查該節點是不是根節點，而是把不是根節點的拔一拔後，剩餘的就是根節點。一次拔除多個端節點，可以有效地降低相同節點被尋訪的次數，讓整體時間降低。\n方法一的遞迴是每個節點到下一個節點，因此遞迴數量很大。\n方法二的遞迴是每層的端節點到下一層，每次遞迴可以檢查多的節點，而且理論上越接近根節點分支就會變少，可以大幅降低遞迴數量。\nFull codeclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; tree;    vector&lt;int&gt; treeCnt;    vector&lt;int&gt; maxDepth(vector&lt;int&gt; leafs) &#123;        vector&lt;int&gt; newLeafs;        for (auto leaf : leafs) &#123;            for (auto node : tree[leaf]) &#123;                if (treeCnt[node] != 0) &#123;                    treeCnt[node]--;                    if (treeCnt[node] == 1) &#123;                        newLeafs.push_back(node);                    &#125;                &#125;            &#125;        &#125;        if (newLeafs.size() == 0) &#123;            return leafs;        &#125;        return maxDepth(newLeafs);    &#125;    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        if (n == 1) &#123;            return &#123;0&#125;;        &#125;        tree.resize(n);        treeCnt.resize(n);        for (auto edge : edges) &#123;            tree[edge[0]].push_back(edge[1]);            tree[edge[1]].push_back(edge[0]);            treeCnt[edge[0]]++;            treeCnt[edge[1]]++;        &#125;        vector&lt;int&gt; leafs;        for (int i = 0; i &lt; treeCnt.size(); i++) &#123;            if (treeCnt[i] == 1) &#123;                treeCnt[i]--;                leafs.push_back(i);            &#125;        &#125;        return maxDepth(leafs);    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 319. Bulb Switcher","url":"/2024/04/23/LeetCode-Writeup/LeetCode-Writeup-319-Bulb-Switcher/","content":"Bulb Switcher這題還蠻有趣的，有三個接續的概念，兩個可過的解法\nIdea 1 TLE換個問題問，是否有辦法知道每個燈泡會在何時開關開關次數是奇數最後會亮，偶數會暗，因此只要知道該燈泡是奇數次就可以知道最後是亮著了。\n那怎麼知道每顆燈在何時會開關？第 6 顆燈泡為例，開關的時間點會在 1, 2, 3, 6 次觸發，偶數次是暗第 10 顆燈泡為例，開關的時間點會在 1, 2, 5, 10 次觸發，偶數次是暗第 36 顆燈泡為例，開關的時間點會在 1, 2, 3, 4, 6, 9, 12, 18, 36 次觸發，奇數次是亮\n數感好的話，應該會發現第 n 顆燈泡會開關的時間點會是在 n 的”因數”時進行開關。換句話說只要知道每個數字是奇數還是偶數就可以知道最後是亮還是暗了。\nFull codebool factorIsOdd(int n)&#123;    int cnt=0;    for(int i=1;i&lt;=n;i++)&#123;        cnt+=(n%i==0);    &#125;    return cnt%2==1;&#125;int bulbSwitch(int n) &#123;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=factorIsOdd(i);    &#125;    return ans;&#125;\n\nSolution 1方法一概念是正確的，但寫完會發現，TLE…，題目給的 n 太大了。回到剛剛的因數分解。6 的因數有 1, 2, 3, 6，4 個8 的因數有 1, 2, 4, 8，4 個36 的因數有 1, 2, 3, 4, 6, 9, 12, 18, 36，9 個\n有沒有辦法取得”奇數個因數”的數，所有的因數分解中，數字一定是成雙成對的，以 48 為例1x48、2x24、3x16、4x12 …etc\n那有沒有數字的因數中有成雙成對，但數量又是奇數的？數感好的話，應該會發現”平方數”的因數數量是奇數，以 16 為例。1x16、2x8、”4x4”因為平方數開根號的數就是自己 x 自己，平方數因數量就會是奇數了（偶數組合與根號數）\nFull codeint bulbSwitch(int n) &#123;    int ans=0,root;    for(int i=1;i&lt;=n;i++)&#123;        root=sqrt(i);        ans+=(i==root*root);    &#125;    return ans;&#125;\n\nSolution 2方法二概念正確，但會發現你的執行速度不是 Beat100%\n想要追求極致的話，是否有方法比 O(n)還快？是否能透過計算取得 n 內的所有平方數數量？\nn&#x3D;16 時，有 1, 4, 9, 16，四個n&#x3D;17 時，有 1, 4, 9, 16，四個…n&#x3D;24 時，有 1, 4, 9, 16，四個n&#x3D;25 時，有 1, 4, 9, 16, 25，五個\n數感好的話，應該會發現，n&#x3D;16~24 都是四個，n&#x3D;25 才是五個，如果用開根號來計算的話：n&#x3D;16 時，sqrt(n) &#x3D; 4n&#x3D;17 時，sqrt(n) &#x3D; 4.12…n&#x3D;24 時，sqrt(n) &#x3D; 4.89n&#x3D;25 時，sqrt(n) &#x3D; 5\n因此只要對 n 直接開根號的話，就可以取得該數內的平方數了，又因為 funtion 的回傳型態是整數，更不用擔心被小數影響結果。\nFull codeint bulbSwitch(int n) &#123;    return sqrt(n);&#125;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode-Writeup 2370. Longest Ideal Subsequence","url":"/2024/04/26/LeetCode-Writeup/LeetCode-Writeup-2370-Longest-Ideal-Subsequence/","content":"Longest Ideal Subsequence這題是個基礎的 DP 題，很值得練習。\nIdea 1 TLE第一種方法，就是當前的字往前檢查可以接的字有哪些，選最高的。\nMain function第 n 個字時，會檢查 n-1 到 1 的字字串的長度\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    for(int j=i-1;j&gt;=0;j--)&#123;        ...    &#125;&#125;\n\n先檢查當前的字和前面的字距離有沒有小於等於 k，如果有才符合題目條件。\n有的話再檢查是否大於目前記錄到的長度。\nif(abs(s[i]-s[j])&lt;=k)&#123;    if(seq[j]&gt;temp)&#123;        temp=seq[j];    &#125;&#125;\n\n找到前面可以接續的最長長度後，加上自己把值存進自己位置的陣列，讓下一個字往前檢查時可以讀到。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\nseq[i]=temp+1;ans=max(ans,seq[i]);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0;        vector&lt;int&gt; seq(n);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            for(int j=i-1;j&gt;=0;j--)&#123;                if(abs(s[i]-s[j])&lt;=k)&#123;                    if(seq[j]&gt;temp)&#123;                        temp=seq[j];                    &#125;                &#125;            &#125;            seq[i]=temp+1;            ans=max(ans,seq[i]);        &#125;        return ans;    &#125;&#125;;\n\nSolution 1第一個方法好理解，但問題是每次往前檢查不知道要檢查到第幾個，因此都檢查到第一個，執行時間是 O(n^2)，雖然有用到 DP 的概念，但不怎麼有效率。\n如何有效的紀錄每個字的狀態？\n第二種方法，不同於紀錄字串每個位置的長度，而是用每個字母紀錄最長的長度。\n因為字元差需要在 k 之間，因此只需檢查當前字母+-k 的字母就可以，\n舉例像是字母 c，k=1，那只需檢查 abcdefgh 就行。\n檢查後將新的值放到 c 的位置，讓下一個字可以繼續更新。\nMain function每個字都還是要跑一遍，用nowWordIdx將當前的字轉換成數字 0 ~ 25\nfor(int i=0;i&lt;n;i++)&#123;    temp=0;    nowWordIdx=s[i]-&#x27;a&#x27;;    ...&#125;\n\n透過nowWordIdx，我僅需檢查 +-k 的字，但要注意nowWordIdx-k需大於 0，nowWordIdx+k需小於 25，避免超出範圍。\nfor(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;    if(cnt[j]&gt;temp)&#123;        temp=cnt[j];    &#125;&#125;\n\n當前的字找到最長的值後，加上自己後存在自己字母索引的地方，讓下一個字檢查時可以更新。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\ncnt[nowWordIdx]=temp+1;ans=max(ans,temp+1);\n\nFull codeclass Solution &#123;public:    int longestIdealString(string s, int k) &#123;        int n=s.size(),ans=0,temp=0,nowWordIdx;        vector&lt;int&gt; cnt(26,0);        for(int i=0;i&lt;n;i++)&#123;            temp=0;            nowWordIdx=s[i]-&#x27;a&#x27;;            for(int j=max(nowWordIdx-k,0);j&lt;=min(nowWordIdx+k,25);j++)&#123;                if(cnt[j]&gt;temp)&#123;                    temp=cnt[j];                &#125;            &#125;            cnt[nowWordIdx]=temp+1;            ans=max(ans,temp+1);        &#125;        return ans;    &#125;&#125;;\n","categories":["LeetCode","LeetCode-Writeup"]},{"title":"LeetCode 2023/09","url":"/2023/09/12/LeetCode/LeetCode-2023-09/","content":"2023&#x2F;09&#x2F;03\n2341. Maximum Number of Pairs in Array\n\nclass Solution &#123;public:    vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) &#123;        int pair=0,left=0,temp=0,now=nums[0];        sort(nums.begin(),nums.end());        for(auto num:nums)&#123;            if(now==num)&#123;                temp++;            &#125;else&#123;                pair+=temp/2;                left+=temp%2;                temp=1;                now=num;            &#125;        &#125;        pair+=temp/2;        left+=temp%2;        return &#123;pair,left&#125;;    &#125;&#125;;\n\n\n2331. Evaluate Boolean Binary Tree\n\nclass Solution &#123;public:    bool eval(TreeNode* root)&#123;        if(root-&gt;val==0)&#123;            return false;        &#125;        else if(root-&gt;val==1)&#123;            return true;        &#125;        else if(root-&gt;val==2)&#123;            return eval(root-&gt;left)||eval(root-&gt;right);        &#125;        else if(root-&gt;val==3)&#123;            return eval(root-&gt;left)&amp;&amp;eval(root-&gt;right);        &#125;        return false;    &#125;    bool evaluateTree(TreeNode* root) &#123;        return eval(root);    &#125;&#125;;\n\n\n2500. Delete Greatest Value in Each Row\n\nclass Solution &#123;public:    int deleteGreatestValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans=0,temp=0;        int m=grid.size(),n=grid[0].size();        for(int i=0;i&lt;n;i++)&#123;            temp=0;            for(int j=0;j&lt;m;j++)&#123;                sort(grid[j].begin(),grid[j].end(),greater&lt;int&gt;());                temp=max(temp,grid[j][0]);                grid[j][0]=-1;            &#125;            ans+=temp;        &#125;        return ans;    &#125;&#125;;\n\n\n2744. Find Maximum Number of String Pairs\n\nclass Solution &#123;public:    int maximumNumberOfStringPairs(vector&lt;string&gt;&amp; words) &#123;        int pair=0,n=words.size();        for(int i=0;i&lt;n-1;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                if(words[i][0]==words[j][1]&amp;&amp;words[i][1]==words[j][0])&#123;                    pair++;                    break;                &#125;            &#125;        &#125;        return pair;    &#125;&#125;;\n\n\n2833. Furthest Point From Origin\n\nclass Solution &#123;public:    int furthestDistanceFromOrigin(string moves) &#123;        int space=0,pos=0;        for(auto c:moves)&#123;            if(c==&#x27;_&#x27;)&#123;                space++;            &#125;else if(c==&#x27;L&#x27;)&#123;                pos--;            &#125;else&#123;                pos++;            &#125;        &#125;        return pos&gt;=0?pos+space:-1*(pos-space);    &#125;&#125;;\n\n\n2834. Find the Minimum Possible Sum of a Beautiful Array\n\nclass Solution &#123;public:    long long minimumPossibleSum(int n, int target) &#123;        long long ans=0;        int cnt=0;        unordered_map&lt;int,int&gt; temp;        for(int i=1;cnt&lt;n;i++)&#123;            if(temp[min(i,target-i)]==0)&#123;                ans+=i;                temp[min(i,target-i)]=1;                cnt++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n2023&#x2F;09&#x2F;17\n_404. Sum of Left Leaves\n\nclass Solution &#123;public:    int calcLeft(TreeNode* root)&#123;        int val=0;        if(root-&gt;left!=NULL)&#123;            if(root-&gt;left-&gt;left==NULL&amp;&amp;root-&gt;left-&gt;right==NULL)&#123;                val+=root-&gt;left-&gt;val;            &#125;else&#123;                val+=calcLeft(root-&gt;left);            &#125;        &#125;        if(root-&gt;right!=NULL)&#123;            val+=calcLeft(root-&gt;right);        &#125;        return val;    &#125;    int sumOfLeftLeaves(TreeNode* root) &#123;        return calcLeft(root);    &#125;&#125;;\n\n\n_263. Ugly Number\n\nclass Solution &#123;public:    bool isUgly(int n) &#123;        if(n==0)&#123;            return false;        &#125;        while(n%2==0)&#123;            n/=2;        &#125;        while(n%3==0)&#123;            n/=3;        &#125;        while(n%5==0)&#123;            n/=5;        &#125;        return n==1;    &#125;&#125;;\n\n\n_448. Find All Numbers Disappeared in an Array\n\nclass Solution &#123;public:    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        vector&lt;int&gt; val(n);        vector&lt;int&gt; ans;        for(auto num:nums)&#123;            val[num-1]++;        &#125;        for(int i=0;i&lt;n;i++)&#123;            if(val[i]==0)&#123;                ans.push_back(i+1);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n_653. Two Sum IV - Input is a BST\n\nclass Solution &#123;public:    void remake(vector&lt;int&gt;&amp; val,TreeNode* root)&#123;        if(root!=NULL)&#123;            val.push_back(root-&gt;val);            remake(val,root-&gt;left);            remake(val,root-&gt;right);        &#125;        return;    &#125;    bool findTarget(TreeNode* root, int k) &#123;        vector&lt;int&gt; val;        remake(val,root);        sort(val.begin(),val.end());        for(auto num:val)&#123;            if(k-num!=num)&#123;                for(auto chk:val)&#123;                    if(chk==k-num)&#123;                        return true;                    &#125;                &#125;            &#125;else&#123;                int cnt=0;                for(auto chk:val)&#123;                    if(chk==num)&#123;                        cnt++;                        if(cnt&gt;1)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n1010. Pairs of Songs With Total Durations Divisible by 60\n\nclass Solution &#123;public:    int C(long long x)&#123;        if(x&lt;2)&#123;            return 0;        &#125;        long long ans=x*(x-1)/2;        return ans;    &#125;    int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) &#123;        vector&lt;int&gt; minute(60);        for(auto t:time)&#123;            minute[t%60]++;        &#125;        int ans=C(minute[0]);        for(int i=1;i&lt;30;i++)&#123;            ans+=minute[i]*minute[60-i];        &#125;        ans+=C(minute[30]);        return ans;    &#125;&#125;;\n\n\n2848. Points That Intersect With Cars\n\nclass Solution &#123;public:    int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;        vector&lt;int&gt; map(100,0);        for(auto num:nums)&#123;            for(int i=num[0];i&lt;=num[1];i++)&#123;                map[i-1]=1;            &#125;        &#125;        int cnt=0;        for(auto m:map)&#123;            cnt+=(m==1);        &#125;        return cnt;    &#125;&#125;;\n\n\n2849. Determine if a Cell Is Reachable at a Given Time\n\nclass Solution &#123;public:    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) &#123;        int dis=max(abs(fx-sx),abs(fy-sy));        if(dis==0&amp;&amp;t==1)&#123;            return false;        &#125;        return t&gt;=dis;    &#125;&#125;;\n\n2023&#x2F;09&#x2F;24\n1078. Occurrences After Bigram\n\nclass Solution &#123;public:    vector&lt;string&gt; findOcurrences(string text, string first, string second) &#123;        vector&lt;string&gt; words;        string word=&quot;&quot;;        for(auto c:text)&#123;            if(c==&#x27; &#x27;)&#123;                words.push_back(word);                word=&quot;&quot;;            &#125;else&#123;                word=word+c;            &#125;        &#125;        if(word!=&quot;&quot;)&#123;            words.push_back(word);        &#125;        vector&lt;string&gt; ans;        int n=words.size();        for(int i=2;i&lt;n;i++)&#123;            if(words[i-2]==first&amp;&amp;words[i-1]==second)&#123;                ans.push_back(words[i]);            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2582. Pass the Pillow\n\nclass Solution &#123;public:    int passThePillow(int n, int time) &#123;        int pass=time%((n-1)*2);        if(pass&gt;n-1)&#123;            return n-(pass-(n-1));        &#125;        return 1+pass;    &#125;&#125;;\n\n\n2586. Count the Number of Vowel Strings in Range\n\nclass Solution &#123;public:    bool isVowel(char temp)&#123;        return temp==&#x27;a&#x27;||temp==&#x27;e&#x27;||temp==&#x27;i&#x27;||temp==&#x27;o&#x27;||temp==&#x27;u&#x27;;    &#125;    int vowelStrings(vector&lt;string&gt;&amp; words, int left, int right) &#123;        int cnt=0;        for(int i=left;i&lt;=right;i++)&#123;            if(isVowel(words[i].front())&amp;&amp;isVowel(words[i].back()))&#123;                cnt++;            &#125;        &#125;        return cnt;    &#125;&#125;;\n\n\n2855. Minimum Right Shifts to Sort the Array\n\nclass Solution &#123;public:    int minimumRightShifts(vector&lt;int&gt;&amp; nums) &#123;        int idx=0,n=nums.size();        while(idx+1&lt;n&amp;&amp;nums[idx]&lt;nums[idx+1])&#123;            idx++;        &#125;        if(idx==n-1)&#123;            return 0;        &#125;        idx++;        int temp=idx;        while(idx+1&lt;n&amp;&amp;nums[idx]&lt;nums[idx+1])&#123;            idx++;        &#125;        if(idx!=n-1)&#123;            return -1;        &#125;        if(nums[temp]&lt;nums[0]&amp;&amp;nums[n-1]&lt;nums[0])&#123;            return n-temp;        &#125;        return -1;    &#125;&#125;;\n\n\n_240. Search a 2D Matrix II\n\nclass Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int m=matrix.size(),n=matrix[0].size();        int i=0,j=n-1;        while(i&lt;m&amp;&amp;j&gt;=0)&#123;            if(matrix[i][j]==target)&#123;                return true;            &#125;else if(matrix[i][j]&gt;target)&#123;                j--;            &#125;else&#123;                i++;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n2859. Sum of Values at Indices With K Set Bits\n\nclass Solution &#123;public:    int binaryONES(int i)&#123;        int ones=0;        while(i&gt;0)&#123;            ones+=i%2;            i/=2;        &#125;        return ones;    &#125;    int sumIndicesWithKSetBits(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans=0,n=nums.size();        for(int i=0;i&lt;n;i++)&#123;            if(binaryONES(i)==k)&#123;                ans+=nums[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n\n\n2860. Happy Students\n\nclass Solution &#123;public:    int countWays(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        sort(nums.begin(),nums.end());        nums.push_back(1e5+1);        int cnt=0;        for(int i=0;i&lt;n;i++)&#123;            if(nums[i]&lt;i+1&amp;&amp;i+1&lt;nums[i+1])&#123;                cnt++;            &#125;        &#125;        if(nums[0]!=0)&#123;            cnt++;        &#125;        return cnt;    &#125;&#125;;\n","categories":["LeetCode"]}]