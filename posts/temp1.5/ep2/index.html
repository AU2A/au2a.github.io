<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術 | Aura's Space</title><meta name=keywords content="LangChain,Python"><meta name=description content='

本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。


零、 前言
接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。
一、 從「通靈」到「規格化」：為什麼需要結構化輸出？
在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。
LangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if "Name:" in response 這種令人崩潰的邏輯。

二、 雙路徑策略：Provider vs. Tool Calling
LangChain 根據模型的能力，自動切換兩種不同的達成策略：
1. ProviderStrategy (原生支援)
當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。

優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。
新特性： 在 langchain>=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。
自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。

2. ToolCallingStrategy (工具調用)
對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。'><meta name=author content="Aura"><link rel=canonical href=https://aura.codex.tw/posts/temp1.5/ep2/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://aura.codex.tw/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aura.codex.tw/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://aura.codex.tw/images/favicon.ico><link rel=apple-touch-icon href=https://aura.codex.tw/images/favicon.ico><link rel=mask-icon href=https://aura.codex.tw/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aura.codex.tw/posts/temp1.5/ep2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://aura.codex.tw/posts/temp1.5/ep2/"><meta property="og:site_name" content="Aura's Space"><meta property="og:title" content="【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術"><meta property="og:description" content=' 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。
零、 前言 接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。
一、 從「通靈」到「規格化」：為什麼需要結構化輸出？ 在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。
LangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if "Name:" in response 這種令人崩潰的邏輯。
二、 雙路徑策略：Provider vs. Tool Calling LangChain 根據模型的能力，自動切換兩種不同的達成策略：
1. ProviderStrategy (原生支援) 當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。
優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。 新特性： 在 langchain>=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。 自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。 2. ToolCallingStrategy (工具調用) 對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-14T00:00:00+00:00"><meta property="article:tag" content="LangChain"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術"><meta name=twitter:description content='

本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。


零、 前言
接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。
一、 從「通靈」到「規格化」：為什麼需要結構化輸出？
在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。
LangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if "Name:" in response 這種令人崩潰的邏輯。

二、 雙路徑策略：Provider vs. Tool Calling
LangChain 根據模型的能力，自動切換兩種不同的達成策略：
1. ProviderStrategy (原生支援)
當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。

優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。
新特性： 在 langchain>=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。
自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。

2. ToolCallingStrategy (工具調用)
對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aura.codex.tw/posts/"},{"@type":"ListItem","position":2,"name":"【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術","item":"https://aura.codex.tw/posts/temp1.5/ep2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術","name":"【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術","description":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。\n一、 從「通靈」到「規格化」：為什麼需要結構化輸出？ 在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。\nLangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if \u0026quot;Name:\u0026quot; in response 這種令人崩潰的邏輯。\n二、 雙路徑策略：Provider vs. Tool Calling LangChain 根據模型的能力，自動切換兩種不同的達成策略：\n1. ProviderStrategy (原生支援) 當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。\n優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。 新特性： 在 langchain\u0026gt;=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。 自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。 2. ToolCallingStrategy (工具調用) 對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。\n","keywords":["LangChain","Python"],"articleBody":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。\n一、 從「通靈」到「規格化」：為什麼需要結構化輸出？ 在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。\nLangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if \"Name:\" in response 這種令人崩潰的邏輯。\n二、 雙路徑策略：Provider vs. Tool Calling LangChain 根據模型的能力，自動切換兩種不同的達成策略：\n1. ProviderStrategy (原生支援) 當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。\n優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。 新特性： 在 langchain\u003e=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。 自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。 2. ToolCallingStrategy (工具調用) 對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。\n原理： 告訴模型：「如果你完成了任務，請呼叫這個工具並傳入結果」。 彈性： 支援 Union 類型（例如：Agent 可以根據情況選擇回傳「客戶評論」或「投訴單」）。 三、 多樣化的 Schema 支援 無論你習慣哪種定義資料的方式，LangChain v1.0 幾乎全包了：\n支援類型 描述 適用場景 Pydantic 繼承 BaseModel 需要強類型驗證與複雜 Field 描述時（最推薦）。 Dataclass Python 標準庫 輕量化、不需額外依賴時。 TypedDict 字典型別標記 習慣使用純 Dictionary 操作時。 JSON Schema 純 JSON 結構定義 跨語言或動態生成 Schema 時。 四、 容錯處理：Agent 的「自我修復」機制 這是 ToolStrategy 最強大的地方。當模型生成了錯誤格式的資料時，Agent 不會直接崩潰，而是會啟動 自動重試機制。\n1. 多重輸出錯誤 (Multiple Outputs) 有時候模型太熱心，一次呼叫了兩個工具。Agent 會在 Tool Message 中回覆：\n「錯誤：模型錯誤地回傳了多個結構化回應，請修正你的錯誤。」\n2. Schema 驗證失敗 (Validation Error) 如果模型把評分（1-5 分）填成了 10 分，Agent 會將 Pydantic 的報錯資訊直接回傳給模型，讓模型知道哪裡錯了：\n「1 validation error: Input should be less than or equal to 5 [input_value=10]」\n3. 自定義錯誤策略 (handle_errors) 開發者可以根據需求控制重試行為：\nTrue: 自動重試（預設）。 str: 使用自定義的提示詞命令模型重試。 Callable: 根據 Exception 類型動態決定回傳給模型的指令。 五、 進階技巧：自定義工具訊息內容 在 Agent 的對話歷史中，結構化輸出通常表現為一次 Tool Call。透過 tool_message_content，你可以自定義這條紀錄的顯示方式，讓對話紀錄更具可讀性：\n1 2 3 4 5 # 範例邏輯 ToolStrategy( schema=MeetingAction, tool_message_content=\"行動項目已擷取並存入會議記錄中！\" ) 這樣在除錯或檢視歷史紀錄時，你看到的不再是冗長的 JSON，而是人類可讀的確認語句。\n六、 技術總結 結構化輸出標誌著 LangChain Agent 從「聊天機器人」轉向「可靠組件」的關鍵轉折。透過 langchain\u003e=1.1 的動態 Profile 讀取機制，系統能自動判別模型的 structured_output 支援度，開發者只需定義好數據模型，剩下的驗證、重試與封裝都由框架處理。\n在 1.5 度的視角下，這不僅是技術更新，更是一種開發規範的建立：讓不確定的 LLM 產出，對接到確定的軟體邏輯中。\n七、 結語 「如果不能轉化為數據，AI 就只能是玩具。」\nStructured Output 將 AI 從一個「會說話的鸚鵡」變成了一個「能產出標準格式數據的組件」。這不僅簡化了後端的 Regex 代碼，更重要的是，它讓 AI 真正具備了與現有軟體世界通訊的能力。\n下次當你發現自己還在寫 if \"JSON\" in response.content: 時，請記得 LangChain 已經為你準備好了更優雅的工具。\n","wordCount":"236","inLanguage":"en","datePublished":"2025-10-14T00:00:00Z","dateModified":"2025-10-14T00:00:00Z","author":{"@type":"Person","name":"Aura"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aura.codex.tw/posts/temp1.5/ep2/"},"publisher":{"@type":"Organization","name":"Aura's Space","logo":{"@type":"ImageObject","url":"https://aura.codex.tw/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://aura.codex.tw/ accesskey=h title="Aura's Space (Alt + H)"><img src=https://aura.codex.tw/images/favicon.ico alt aria-label=logo height=35>Aura's Space</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aura.codex.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://aura.codex.tw/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aura.codex.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://aura.codex.tw/about/ title=About><span>About</span></a></li><li><a href=https://aura.codex.tw/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aura.codex.tw/>Home</a>&nbsp;»&nbsp;<a href=https://aura.codex.tw/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術</h1><div class=post-meta><span title='2025-10-14 00:00:00 +0000 UTC'>October 14, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Aura</span></div></header><ul class=post-tags><li><a href=https://aura.codex.tw/tags/langchain/>LangChain</a></li><li><a href=https://aura.codex.tw/tags/python/>Python</a></li></ul><div class=post-content><hr><blockquote><p>本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。</p></blockquote><hr><h3 id=零-前言>零、 前言<a hidden class=anchor aria-hidden=true href=#零-前言>#</a></h3><p>接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：<strong>結構化輸出 (Structured Output)</strong>。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。</p><h3 id=一-從通靈到規格化為什麼需要結構化輸出>一、 從「通靈」到「規格化」：為什麼需要結構化輸出？<a hidden class=anchor aria-hidden=true href=#一-從通靈到規格化為什麼需要結構化輸出>#</a></h3><p>在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。</p><p>LangChain v1.0 透過 <code>create_agent</code> 的 <code>response_format</code> 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 <strong>JSON 物件</strong>、<strong>Pydantic 模型</strong> 或 <strong>Python Dataclasses</strong>。這意味著你的程式碼可以直接存取屬性（如 <code>result.name</code>），而不需要再寫 <code>if "Name:" in response</code> 這種令人崩潰的邏輯。</p><hr><h3 id=二-雙路徑策略provider-vs-tool-calling>二、 雙路徑策略：Provider vs. Tool Calling<a hidden class=anchor aria-hidden=true href=#二-雙路徑策略provider-vs-tool-calling>#</a></h3><p>LangChain 根據模型的能力，自動切換兩種不同的達成策略：</p><h4 id=1-providerstrategy-原生支援>1. ProviderStrategy (原生支援)<a hidden class=anchor aria-hidden=true href=#1-providerstrategy-原生支援>#</a></h4><p>當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。</p><ul><li><strong>優勢：</strong> 供應商在 API 層級強制執行 Schema，幻覺率最低。</li><li><strong>新特性：</strong> 在 <code>langchain>=1.2</code> 中支援 <code>strict</code> 參數，強制模型 100% 遵守 Schema。</li><li><strong>自動觸發：</strong> 只要模型支援，直接傳入 Pydantic 類別給 <code>response_format</code> 即可。</li></ul><h4 id=2-toolcallingstrategy-工具調用>2. ToolCallingStrategy (工具調用)<a hidden class=anchor aria-hidden=true href=#2-toolcallingstrategy-工具調用>#</a></h4><p>對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。</p><ul><li><strong>原理：</strong> 告訴模型：「如果你完成了任務，請呼叫這個工具並傳入結果」。</li><li><strong>彈性：</strong> 支援 <code>Union</code> 類型（例如：Agent 可以根據情況選擇回傳「客戶評論」或「投訴單」）。</li></ul><hr><h3 id=三-多樣化的-schema-支援>三、 多樣化的 Schema 支援<a hidden class=anchor aria-hidden=true href=#三-多樣化的-schema-支援>#</a></h3><p>無論你習慣哪種定義資料的方式，LangChain v1.0 幾乎全包了：</p><table><thead><tr><th>支援類型</th><th>描述</th><th>適用場景</th></tr></thead><tbody><tr><td><strong>Pydantic</strong></td><td>繼承 <code>BaseModel</code></td><td>需要強類型驗證與複雜 Field 描述時（最推薦）。</td></tr><tr><td><strong>Dataclass</strong></td><td>Python 標準庫</td><td>輕量化、不需額外依賴時。</td></tr><tr><td><strong>TypedDict</strong></td><td>字典型別標記</td><td>習慣使用純 Dictionary 操作時。</td></tr><tr><td><strong>JSON Schema</strong></td><td>純 JSON 結構定義</td><td>跨語言或動態生成 Schema 時。</td></tr></tbody></table><hr><h3 id=四-容錯處理agent-的自我修復機制>四、 容錯處理：Agent 的「自我修復」機制<a hidden class=anchor aria-hidden=true href=#四-容錯處理agent-的自我修復機制>#</a></h3><p>這是 <code>ToolStrategy</code> 最強大的地方。當模型生成了錯誤格式的資料時，Agent 不會直接崩潰，而是會啟動 <strong>自動重試機制</strong>。</p><h4 id=1-多重輸出錯誤-multiple-outputs>1. 多重輸出錯誤 (Multiple Outputs)<a hidden class=anchor aria-hidden=true href=#1-多重輸出錯誤-multiple-outputs>#</a></h4><p>有時候模型太熱心，一次呼叫了兩個工具。Agent 會在 Tool Message 中回覆：</p><blockquote><p>「錯誤：模型錯誤地回傳了多個結構化回應，請修正你的錯誤。」</p></blockquote><h4 id=2-schema-驗證失敗-validation-error>2. Schema 驗證失敗 (Validation Error)<a hidden class=anchor aria-hidden=true href=#2-schema-驗證失敗-validation-error>#</a></h4><p>如果模型把評分（1-5 分）填成了 10 分，Agent 會將 Pydantic 的報錯資訊直接回傳給模型，讓模型知道哪裡錯了：</p><blockquote><p>「1 validation error: Input should be less than or equal to 5 [input_value=10]」</p></blockquote><h4 id=3-自定義錯誤策略-handle_errors>3. 自定義錯誤策略 (<code>handle_errors</code>)<a hidden class=anchor aria-hidden=true href=#3-自定義錯誤策略-handle_errors>#</a></h4><p>開發者可以根據需求控制重試行為：</p><ul><li><code>True</code>: 自動重試（預設）。</li><li><code>str</code>: 使用自定義的提示詞命令模型重試。</li><li><code>Callable</code>: 根據 Exception 類型動態決定回傳給模型的指令。</li></ul><hr><h3 id=五-進階技巧自定義工具訊息內容>五、 進階技巧：自定義工具訊息內容<a hidden class=anchor aria-hidden=true href=#五-進階技巧自定義工具訊息內容>#</a></h3><p>在 Agent 的對話歷史中，結構化輸出通常表現為一次 Tool Call。透過 <code>tool_message_content</code>，你可以自定義這條紀錄的顯示方式，讓對話紀錄更具可讀性：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 範例邏輯</span>
</span></span><span class=line><span class=cl><span class=n>ToolStrategy</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>schema</span><span class=o>=</span><span class=n>MeetingAction</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>tool_message_content</span><span class=o>=</span><span class=s2>&#34;行動項目已擷取並存入會議記錄中！&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>這樣在除錯或檢視歷史紀錄時，你看到的不再是冗長的 JSON，而是人類可讀的確認語句。</p><hr><h3 id=六-技術總結>六、 技術總結<a hidden class=anchor aria-hidden=true href=#六-技術總結>#</a></h3><p>結構化輸出標誌著 LangChain Agent 從「聊天機器人」轉向「可靠組件」的關鍵轉折。透過 <code>langchain>=1.1</code> 的動態 Profile 讀取機制，系統能自動判別模型的 <code>structured_output</code> 支援度，開發者只需定義好數據模型，剩下的驗證、重試與封裝都由框架處理。</p><p>在 1.5 度的視角下，這不僅是技術更新，更是一種開發規範的建立：<strong>讓不確定的 LLM 產出，對接到確定的軟體邏輯中。</strong></p><hr><h3 id=七-結語>七、 結語<a hidden class=anchor aria-hidden=true href=#七-結語>#</a></h3><p><strong>「如果不能轉化為數據，AI 就只能是玩具。」</strong></p><p>Structured Output 將 AI 從一個「會說話的鸚鵡」變成了一個「能產出標準格式數據的組件」。這不僅簡化了後端的 Regex 代碼，更重要的是，它讓 AI 真正具備了與現有軟體世界通訊的能力。</p><p>下次當你發現自己還在寫 <code>if "JSON" in response.content:</code> 時，請記得 LangChain 已經為你準備好了更優雅的工具。</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022~2025 <a href=https://aura.codex.tw/>Aura's Space</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>