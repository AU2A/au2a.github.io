<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0 | Aura's Space</title><meta name=keywords content="LangChain,Python"><meta name=description content="

本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。


一、 核心背景：解決「生產力鴻溝」
LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：

依賴臃腫： 解決了過去單體式結構導致的依賴衝突。
API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。
黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。
文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。


二、 架構層級的全面重構
v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：
1. 新的 Agent 範式：create_agent

底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。
中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。
情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。

2. 標準化通訊結構：.content_blocks

供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。
多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。
類型安全： 提供完整的 Type Hints，減少執行時錯誤。

3. 解耦的生態系統

langchain-core: 穩定的基礎抽象（Runnable 接口）。
langchain-community: 獨立的版本控制，處理第三方整合。
langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。


三、 組合範式的轉移：從 Chains 到 LCEL
這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」："><meta name=author content="Aura"><link rel=canonical href=http://localhost:1313/posts/temp1.5/ep1/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/favicon.ico><link rel=apple-touch-icon href=http://localhost:1313/images/favicon.ico><link rel=mask-icon href=http://localhost:1313/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/temp1.5/ep1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/temp1.5/ep1/"><meta property="og:site_name" content="Aura's Space"><meta property="og:title" content="【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0"><meta property="og:description" content=" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。
一、 核心背景：解決「生產力鴻溝」 LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：
依賴臃腫： 解決了過去單體式結構導致的依賴衝突。 API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。 黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。 文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。 二、 架構層級的全面重構 v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：
1. 新的 Agent 範式：create_agent 底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。 中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。 情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。 2. 標準化通訊結構：.content_blocks 供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。 多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。 類型安全： 提供完整的 Type Hints，減少執行時錯誤。 3. 解耦的生態系統 langchain-core: 穩定的基礎抽象（Runnable 接口）。 langchain-community: 獨立的版本控制，處理第三方整合。 langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。 三、 組合範式的轉移：從 Chains 到 LCEL 這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-13T00:00:00+00:00"><meta property="article:tag" content="LangChain"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0"><meta name=twitter:description content="

本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。


一、 核心背景：解決「生產力鴻溝」
LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：

依賴臃腫： 解決了過去單體式結構導致的依賴衝突。
API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。
黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。
文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。


二、 架構層級的全面重構
v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：
1. 新的 Agent 範式：create_agent

底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。
中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。
情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。

2. 標準化通訊結構：.content_blocks

供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。
多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。
類型安全： 提供完整的 Type Hints，減少執行時錯誤。

3. 解耦的生態系統

langchain-core: 穩定的基礎抽象（Runnable 接口）。
langchain-community: 獨立的版本控制，處理第三方整合。
langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。


三、 組合範式的轉移：從 Chains 到 LCEL
這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0","item":"http://localhost:1313/posts/temp1.5/ep1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0","name":"【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0","description":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n一、 核心背景：解決「生產力鴻溝」 LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：\n依賴臃腫： 解決了過去單體式結構導致的依賴衝突。 API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。 黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。 文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。 二、 架構層級的全面重構 v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：\n1. 新的 Agent 範式：create_agent 底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。 中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。 情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。 2. 標準化通訊結構：.content_blocks 供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。 多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。 類型安全： 提供完整的 Type Hints，減少執行時錯誤。 3. 解耦的生態系統 langchain-core: 穩定的基礎抽象（Runnable 接口）。 langchain-community: 獨立的版本控制，處理第三方整合。 langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。 三、 組合範式的轉移：從 Chains 到 LCEL 這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」：\n","keywords":["LangChain","Python"],"articleBody":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n一、 核心背景：解決「生產力鴻溝」 LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：\n依賴臃腫： 解決了過去單體式結構導致的依賴衝突。 API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。 黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。 文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。 二、 架構層級的全面重構 v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：\n1. 新的 Agent 範式：create_agent 底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。 中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。 情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。 2. 標準化通訊結構：.content_blocks 供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。 多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。 類型安全： 提供完整的 Type Hints，減少執行時錯誤。 3. 解耦的生態系統 langchain-core: 穩定的基礎抽象（Runnable 接口）。 langchain-community: 獨立的版本控制，處理第三方整合。 langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。 三、 組合範式的轉移：從 Chains 到 LCEL 這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」：\nLCEL (LangChain Expression Language)： 利用管道運算子 | 組合組件，結構如 prompt | model | parser。 透明度： 鏈條的每一步都清晰可見，不再是隱藏邏輯。 內建優勢： 自動獲得原生串流 (Streaming)、非同步支援 (Async) 以及並行執行能力。 可觀測性： 每一個步驟都會自動記錄到 LangSmith，極大簡化了除錯流程。 四、 完整技術堆疊：三位一體 v1.0 時代的 LangChain 不再只是一個 library，而是一個垂直整合的技術平台：\n層級 組件 角色 應用層 langchain 提供高階入口，快速構建 Agent。 編排層 langgraph 處理複雜的循環邏輯、狀態管理與人機互動。 運營層 langsmith 負責全生命週期的追蹤、評估、監控與部署。 五、 遷移與實踐策略 針對現有專案與未來開發的建議：\n環境要求： 需升級至 Python 3.10+，並注意 Pydantic v2 的兼容性。 遷移路徑： 先安裝 langchain-classic 修正導入語句以維持運行。 逐步將核心邏輯重構為 LCEL 語法，以獲取性能優勢。 開發心態： 簡單任務：使用 create_agent 快速開發。 複雜任務：深入 langgraph 進行精細控制。 品質保障：全程掛載 langsmith 進行觀測。 六、 結語 LangChain v1.0 代表了 AI 應用開發進入了「工程化」階段。透過 解耦架構、宣告式語法 以及 垂直整合的運營工具，它為開發者提供了一個從原型設計到生產部署的可靠路徑。\n","wordCount":"162","inLanguage":"en","datePublished":"2025-10-13T00:00:00Z","dateModified":"2025-10-13T00:00:00Z","author":{"@type":"Person","name":"Aura"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/temp1.5/ep1/"},"publisher":{"@type":"Organization","name":"Aura's Space","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Aura's Space (Alt + H)"><img src=http://localhost:1313/images/favicon.ico alt aria-label=logo height=35>Aura's Space</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0</h1><div class=post-meta><span title='2025-10-13 00:00:00 +0000 UTC'>October 13, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Aura</span></div></header><ul class=post-tags><li><a href=http://localhost:1313/tags/langchain/>LangChain</a></li><li><a href=http://localhost:1313/tags/python/>Python</a></li></ul><div class=post-content><hr><blockquote><p>本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。</p></blockquote><hr><h3 id=一-核心背景解決生產力鴻溝>一、 核心背景：解決「生產力鴻溝」<a hidden class=anchor aria-hidden=true href=#一-核心背景解決生產力鴻溝>#</a></h3><p>LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：</p><ul><li><strong>依賴臃腫：</strong> 解決了過去單體式結構導致的依賴衝突。</li><li><strong>API 不穩定：</strong> 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。</li><li><strong>黑盒子抽象：</strong> 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。</li><li><strong>文件滯後：</strong> 透過架構標準化，大幅改善了開發文件的指導意義。</li></ul><hr><h3 id=二-架構層級的全面重構>二、 架構層級的全面重構<a hidden class=anchor aria-hidden=true href=#二-架構層級的全面重構>#</a></h3><p>v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：</p><h4 id=1-新的-agent-範式create_agent>1. 新的 Agent 範式：<code>create_agent</code><a hidden class=anchor aria-hidden=true href=#1-新的-agent-範式create_agent>#</a></h4><ul><li><strong>底層支撐：</strong> 全面改由 <strong>LangGraph</strong> 驅動，原生支援持久化與人機協作。</li><li><strong>中介軟體 (Middleware)：</strong> 引入類似 Web 開發的 Hook 機制（如 <code>beforeModel</code>, <code>wrapToolCall</code>）。</li><li><strong>情境工程：</strong> 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。</li></ul><h4 id=2-標準化通訊結構content_blocks>2. 標準化通訊結構：<code>.content_blocks</code><a hidden class=anchor aria-hidden=true href=#2-標準化通訊結構content_blocks>#</a></h4><ul><li><strong>供應商無關：</strong> 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。</li><li><strong>多模態支援：</strong> 為未來視覺與檔案內容的處理提供了標準接口。</li><li><strong>類型安全：</strong> 提供完整的 Type Hints，減少執行時錯誤。</li></ul><h4 id=3-解耦的生態系統>3. 解耦的生態系統<a hidden class=anchor aria-hidden=true href=#3-解耦的生態系統>#</a></h4><ul><li><code>langchain-core</code>: 穩定的基礎抽象（Runnable 接口）。</li><li><code>langchain-community</code>: 獨立的版本控制，處理第三方整合。</li><li><code>langchain-classic</code>: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。</li></ul><hr><h3 id=三-組合範式的轉移從-chains-到-lcel>三、 組合範式的轉移：從 Chains 到 LCEL<a hidden class=anchor aria-hidden=true href=#三-組合範式的轉移從-chains-到-lcel>#</a></h3><p>這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」：</p><ul><li><strong>LCEL (LangChain Expression Language)：</strong></li><li>利用管道運算子 <code>|</code> 組合組件，結構如 <code>prompt | model | parser</code>。</li><li><strong>透明度：</strong> 鏈條的每一步都清晰可見，不再是隱藏邏輯。</li><li><strong>內建優勢：</strong> 自動獲得原生串流 (Streaming)、非同步支援 (Async) 以及並行執行能力。</li><li><strong>可觀測性：</strong> 每一個步驟都會自動記錄到 LangSmith，極大簡化了除錯流程。</li></ul><hr><h3 id=四-完整技術堆疊三位一體>四、 完整技術堆疊：三位一體<a hidden class=anchor aria-hidden=true href=#四-完整技術堆疊三位一體>#</a></h3><p>v1.0 時代的 LangChain 不再只是一個 library，而是一個垂直整合的技術平台：</p><table><thead><tr><th>層級</th><th>組件</th><th>角色</th></tr></thead><tbody><tr><td><strong>應用層</strong></td><td><code>langchain</code></td><td>提供高階入口，快速構建 Agent。</td></tr><tr><td><strong>編排層</strong></td><td><code>langgraph</code></td><td>處理複雜的循環邏輯、狀態管理與人機互動。</td></tr><tr><td><strong>運營層</strong></td><td><code>langsmith</code></td><td>負責全生命週期的追蹤、評估、監控與部署。</td></tr></tbody></table><hr><h3 id=五-遷移與實踐策略>五、 遷移與實踐策略<a hidden class=anchor aria-hidden=true href=#五-遷移與實踐策略>#</a></h3><p>針對現有專案與未來開發的建議：</p><ol><li><strong>環境要求：</strong> 需升級至 Python 3.10+，並注意 Pydantic v2 的兼容性。</li><li><strong>遷移路徑：</strong> 先安裝 <code>langchain-classic</code> 修正導入語句以維持運行。</li></ol><ul><li>逐步將核心邏輯重構為 LCEL 語法，以獲取性能優勢。</li></ul><ol start=3><li><strong>開發心態：</strong></li></ol><ul><li>簡單任務：使用 <code>create_agent</code> 快速開發。</li><li>複雜任務：深入 <code>langgraph</code> 進行精細控制。</li><li>品質保障：全程掛載 <code>langsmith</code> 進行觀測。</li></ul><hr><h3 id=六-結語>六、 結語<a hidden class=anchor aria-hidden=true href=#六-結語>#</a></h3><p>LangChain v1.0 代表了 AI 應用開發進入了「工程化」階段。透過 <strong>解耦架構</strong>、<strong>宣告式語法</strong> 以及 <strong>垂直整合的運營工具</strong>，它為開發者提供了一個從原型設計到生產部署的可靠路徑。</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022~2025 <a href=http://localhost:1313/>Aura's Space</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>