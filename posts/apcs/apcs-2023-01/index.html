<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>APCS-2023-01 | Aura's Space</title><meta name=keywords content="C++"><meta name=description content="1. 程式考試
解題步驟

讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。
迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。
讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。

如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。
否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。
如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。
如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。


計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。
處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。
輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。

分段步驟程式碼
讀取提交次數與初始化變數


1
2


int n,t,s,maxtime=0,maxScore=-1,errors=0;
cin >> n;


這段程式碼讀取總提交次數 n。並初始化四個重要變數："><meta name=author content="Aura"><link rel=canonical href=https://aura.codex.tw/posts/apcs/apcs-2023-01/><link crossorigin=anonymous href=/assets/css/stylesheet.0a190288459736d4d10e13cb6ee8068b9aa282b3f8938264b3b2d6a98bf701b7.css integrity="sha256-ChkCiEWXNtTRDhPLbugGi5qigrP4k4Jks7LWqYv3Abc=" rel="preload stylesheet" as=style><link rel=icon href=https://aura.codex.tw/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aura.codex.tw/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://aura.codex.tw/images/favicon.ico><link rel=apple-touch-icon href=https://aura.codex.tw/images/favicon.ico><link rel=mask-icon href=https://aura.codex.tw/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aura.codex.tw/posts/apcs/apcs-2023-01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://aura.codex.tw/posts/apcs/apcs-2023-01/"><meta property="og:site_name" content="Aura's Space"><meta property="og:title" content="APCS-2023-01"><meta property="og:description" content="1. 程式考試 解題步驟 讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。 迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。 讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。 如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。 否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。 如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。 如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。 計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。 處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。 輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。 分段步驟程式碼 讀取提交次數與初始化變數 1 2 int n,t,s,maxtime=0,maxScore=-1,errors=0; cin >> n; 這段程式碼讀取總提交次數 n。並初始化四個重要變數："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-10T20:16:58+00:00"><meta property="article:modified_time" content="2025-08-10T20:16:58+00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="APCS-2023-01"><meta name=twitter:description content="1. 程式考試
解題步驟

讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。
迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。
讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。

如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。
否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。
如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。
如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。


計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。
處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。
輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。

分段步驟程式碼
讀取提交次數與初始化變數


1
2


int n,t,s,maxtime=0,maxScore=-1,errors=0;
cin >> n;


這段程式碼讀取總提交次數 n。並初始化四個重要變數："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aura.codex.tw/posts/"},{"@type":"ListItem","position":2,"name":"APCS-2023-01","item":"https://aura.codex.tw/posts/apcs/apcs-2023-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"APCS-2023-01","name":"APCS-2023-01","description":"1. 程式考試 解題步驟 讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。 迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。 讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。 如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。 否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。 如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。 如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。 計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。 處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。 輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。 分段步驟程式碼 讀取提交次數與初始化變數 1 2 int n,t,s,maxtime=0,maxScore=-1,errors=0; cin \u0026gt;\u0026gt; n; 這段程式碼讀取總提交次數 n。並初始化四個重要變數：\n","keywords":["C++"],"articleBody":"1. 程式考試 解題步驟 讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。 迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。 讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。 如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。 否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。 如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。 如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。 計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。 處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。 輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。 分段步驟程式碼 讀取提交次數與初始化變數 1 2 int n,t,s,maxtime=0,maxScore=-1,errors=0; cin \u003e\u003e n; 這段程式碼讀取總提交次數 n。並初始化四個重要變數：\nt 和 s 用於在迴圈中儲存每次讀取的時間和分數。 maxtime 用於儲存第一次獲得最高分的時間。 maxScore 儲存目前為止的最高分，初始化為 -1，因為 0 是一個有效的最低分。 errors 用於計算嚴重錯誤 (-1) 的次數。 迴圈處理每次提交 1 2 3 4 5 6 7 8 9 for(int i=0;i\u003cn;i++){ cin \u003e\u003e t \u003e\u003e s; if(s == -1){ errors++; }else if(maxScore \u003c s){ maxtime = t; maxScore = s; } } 這段程式碼使用 for 迴圈遍歷 n 筆提交紀錄。\n每次讀入時間 t 和分數 s。 使用 if-else if 結構來判斷： 如果 s == -1，errors 計數器加 1。 否則，如果 s \u003e maxScore ( else if(maxScore \u003c s) )，表示這是一個新的最高分，此時更新 maxScore 和 maxtime。 注意：如果 s == maxScore，這個條件不會觸發，maxtime 不會被更新，這就保證了 maxtime 儲存的是第一次達到最高分的時間。 計算總分並輸出結果 1 2 3 4 5 6 7 int score = maxScore - n - errors * 2; if(score \u003c 0){ cout \u003c\u003c \"0\"; }else{ cout \u003c\u003c score; } cout \u003c\u003c \" \" \u003c\u003c maxtime; 這段程式碼在迴圈結束後執行。\n首先根據題目公式 最高分 - 總提交次數 - 總嚴重錯誤次數 * 2 計算總分 score。 接著，判斷 score 是否小於 0。如果是，則按題目要求輸出 0；否則輸出計算出的 score。 最後，輸出一個空格和儲存的 maxtime。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include using namespace std; int main(){ int n,t,s,maxtime=0,maxScore=-1,errors=0; cin \u003e\u003e n; for(int i=0;i\u003cn;i++){ cin \u003e\u003e t \u003e\u003e s; if(s == -1){ errors++; }else if(maxScore \u003c s){ maxtime = t; maxScore = s; } } int score = maxScore - n - errors * 2; if(score \u003c 0){ cout \u003c\u003c \"0\"; }else{ cout \u003c\u003c score; } cout \u003c\u003c \" \" \u003c\u003c maxtime; } 2. 造字程式 解題步驟 讀取基本資訊: 讀取字串長度 k、修改次數 q、輸出行數 r，以及初始字串 s。 宣告儲存陣列: 宣告一個 2D 字元陣列 c[q][k]，用來儲存 q 次修改後的所有字串結果。同時宣告一個 1D 陣列 p[k] 用於暫存每次讀取的排列。 模擬 Q 次修改: 使用一個 for 迴圈，從 i = 0 到 q-1，模擬每一次修改操作。 執行單次修改: 在迴圈內部，首先讀取當次的排列 p。 建立一個暫存字串 tmp 並使其等於當前的字串 s（即舊字串）。 再用一個 for 迴圈，根據排列 p 的規則，將 tmp 的字元複製到 s 中對應的位置，產生新字串。 (核心邏輯：s[p[j]-1] = tmp[j]) 儲存結果: 將本次修改產生的新字串 s 存入 2D 陣列 c 的第 i 列 (row) 中。 依格式輸出: 所有修改完成後，使用巢狀迴圈來輸出。 外層迴圈 i 從 0 到 r-1（代表要輸出的第 i 個字元，共 r 行）。 內層迴圈 j 從 0 到 q-1（代表第 j 次修改的結果）。 在內層迴圈中輸出 c[j][i]，即第 j 次修改結果的第 i 個字元。 外層迴圈每跑完一次，就輸出一行換行符。 分段步驟程式碼 讀取基本資訊與宣告陣列 1 2 3 4 5 int k, q, r; string s; cin \u003e\u003e k \u003e\u003e q \u003e\u003e r \u003e\u003e s; int p[k]; char c[q][k]; 這段程式碼讀取 k, q, r 和初始字串 s。並宣告 p 陣列用來儲存每次讀入的排列，c 陣列用來儲存 q 次修改的全部結果。\n模擬修改過程並儲存結果 1 2 3 4 5 6 7 8 9 10 11 12 for(int i=0;i\u003cq;i++){ for(int j=0;j\u003ck;j++){ cin \u003e\u003e p[j]; } string tmp = s; for(int j=0;j\u003ck;j++){ s[p[j]-1] = tmp[j]; } for(int j=0;j\u003ck;j++){ c[i][j] = s[j]; } } 這段程式碼是解題的核心。\n外層迴圈 for(int i=0;i","wordCount":"687","inLanguage":"en","datePublished":"2025-08-10T20:16:58Z","dateModified":"2025-08-10T20:16:58Z","author":{"@type":"Person","name":"Aura"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aura.codex.tw/posts/apcs/apcs-2023-01/"},"publisher":{"@type":"Organization","name":"Aura's Space","logo":{"@type":"ImageObject","url":"https://aura.codex.tw/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://aura.codex.tw/ accesskey=h title="Aura's Space (Alt + H)"><img src=https://aura.codex.tw/images/favicon.ico alt aria-label=logo height=35>Aura's Space</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aura.codex.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://aura.codex.tw/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aura.codex.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://aura.codex.tw/about/ title=About><span>About</span></a></li><li><a href=https://aura.codex.tw/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aura.codex.tw/>Home</a>&nbsp;»&nbsp;<a href=https://aura.codex.tw/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">APCS-2023-01</h1><div class=post-meta><span title='2025-08-10 20:16:58 +0000 UTC'>August 10, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Aura</span></div></header><ul class=post-tags><li><a href=https://aura.codex.tw/tags/c++/>C++</a></li></ul><div class=post-content><h1 id=1-程式考試>1. 程式考試<a hidden class=anchor aria-hidden=true href=#1-程式考試>#</a></h1><h2 id=解題步驟>解題步驟<a hidden class=anchor aria-hidden=true href=#解題步驟>#</a></h2><ol><li><strong>讀取提交次數與初始化變數</strong>: 讀取總提交次數 <code>n</code>。初始化 <code>maxScore</code> (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，<code>maxtime</code> (第一次達最高分的時間) 為 0，以及 <code>errors</code> (嚴重錯誤次數) 為 0。</li><li><strong>迴圈處理提交紀錄</strong>: 使用 <code>for</code> 迴圈，執行 <code>n</code> 次，代表 <code>n</code> 筆提交紀錄。</li><li><strong>讀取單筆紀錄並更新狀態</strong>: 在迴圈中，每次讀取時間 <code>t</code> 和分數 <code>s</code>。<ul><li>如果 <code>s</code> 為 -1，表示這是一次嚴重錯誤，將 <code>errors</code> 計數加 1。</li><li><strong>否則</strong> (<code>s</code> 不是 -1)，檢查 <code>s</code> 是否<strong>嚴格大於</strong>目前的 <code>maxScore</code>。</li><li>如果是，表示找到了新的最高分，更新 <code>maxScore = s</code> 和 <code>maxtime = t</code>。</li><li>如果 <code>s</code> 等於 <code>maxScore</code>，則不執行任何操作，以保留<strong>第一次</strong>獲得最高分的時間。</li></ul></li><li><strong>計算總分</strong>: 迴圈結束後，根據公式 <code>maxScore - n - errors * 2</code> 計算總分 <code>score</code>。</li><li><strong>處理負分狀況</strong>: 檢查 <code>score</code> 是否小於 0。如果是，則將 <code>score</code> 設為 0 (或直接輸出 0)。</li><li><strong>輸出結果</strong>: 輸出最終分數 <code>score</code>，接著輸出一個空格，最後輸出 <code>maxtime</code>。</li></ol><h2 id=分段步驟程式碼>分段步驟程式碼<a hidden class=anchor aria-hidden=true href=#分段步驟程式碼>#</a></h2><h3 id=讀取提交次數與初始化變數>讀取提交次數與初始化變數<a hidden class=anchor aria-hidden=true href=#讀取提交次數與初始化變數>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=n>t</span><span class=p>,</span><span class=n>s</span><span class=p>,</span><span class=n>maxtime</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>maxScore</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span><span class=n>errors</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼讀取總提交次數 <code>n</code>。並初始化四個重要變數：</p><ul><li><code>t</code> 和 <code>s</code> 用於在迴圈中儲存每次讀取的時間和分數。</li><li><code>maxtime</code> 用於儲存第一次獲得最高分的時間。</li><li><code>maxScore</code> 儲存目前為止的最高分，初始化為 -1，因為 0 是一個有效的最低分。</li><li><code>errors</code> 用於計算嚴重錯誤 (-1) 的次數。</li></ul><h3 id=迴圈處理每次提交>迴圈處理每次提交<a hidden class=anchor aria-hidden=true href=#迴圈處理每次提交>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>t</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>errors</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>maxScore</span> <span class=o>&lt;</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>maxtime</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>maxScore</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼使用 <code>for</code> 迴圈遍歷 <code>n</code> 筆提交紀錄。</p><ul><li>每次讀入時間 <code>t</code> 和分數 <code>s</code>。</li><li>使用 <code>if-else if</code> 結構來判斷：<ul><li>如果 <code>s == -1</code>，<code>errors</code> 計數器加 1。</li><li>否則，如果 <code>s > maxScore</code> ( <code>else if(maxScore &lt; s)</code> )，表示這是一個新的最高分，此時更新 <code>maxScore</code> 和 <code>maxtime</code>。</li></ul></li><li>注意：如果 <code>s == maxScore</code>，這個條件不會觸發，<code>maxtime</code> 不會被更新，這就保證了 <code>maxtime</code> 儲存的是<strong>第一次</strong>達到最高分的時間。</li></ul><h3 id=計算總分並輸出結果>計算總分並輸出結果<a hidden class=anchor aria-hidden=true href=#計算總分並輸出結果>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>score</span> <span class=o>=</span> <span class=n>maxScore</span> <span class=o>-</span> <span class=n>n</span> <span class=o>-</span> <span class=n>errors</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>score</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;0&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>maxtime</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼在迴圈結束後執行。</p><ul><li>首先根據題目公式 <code>最高分 - 總提交次數 - 總嚴重錯誤次數 * 2</code> 計算總分 <code>score</code>。</li><li>接著，判斷 <code>score</code> 是否小於 0。如果是，則按題目要求輸出 0；否則輸出計算出的 <code>score</code>。</li><li>最後，輸出一個空格和儲存的 <code>maxtime</code>。</li></ul><h2 id=完整程式碼>完整程式碼<a hidden class=anchor aria-hidden=true href=#完整程式碼>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=n>t</span><span class=p>,</span><span class=n>s</span><span class=p>,</span><span class=n>maxtime</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>maxScore</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span><span class=n>errors</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>t</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>errors</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>maxScore</span> <span class=o>&lt;</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>maxtime</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>maxScore</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>score</span> <span class=o>=</span> <span class=n>maxScore</span> <span class=o>-</span> <span class=n>n</span> <span class=o>-</span> <span class=n>errors</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>score</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;0&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>maxtime</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=2-造字程式>2. 造字程式<a hidden class=anchor aria-hidden=true href=#2-造字程式>#</a></h1><h2 id=解題步驟-1>解題步驟<a hidden class=anchor aria-hidden=true href=#解題步驟-1>#</a></h2><ol><li><strong>讀取基本資訊</strong>: 讀取字串長度 <code>k</code>、修改次數 <code>q</code>、輸出行數 <code>r</code>，以及初始字串 <code>s</code>。</li><li><strong>宣告儲存陣列</strong>: 宣告一個 2D 字元陣列 <code>c[q][k]</code>，用來儲存 <code>q</code> 次修改後的所有字串結果。同時宣告一個 1D 陣列 <code>p[k]</code> 用於暫存每次讀取的排列。</li><li><strong>模擬 Q 次修改</strong>: 使用一個 for 迴圈，從 <code>i = 0</code> 到 <code>q-1</code>，模擬每一次修改操作。</li><li><strong>執行單次修改</strong>:<ul><li>在迴圈內部，首先讀取當次的排列 <code>p</code>。</li><li>建立一個暫存字串 <code>tmp</code> 並使其等於當前的字串 <code>s</code>（即<em>舊字串</em>）。</li><li>再用一個 for 迴圈，根據排列 <code>p</code> 的規則，將 <code>tmp</code> 的字元複製到 <code>s</code> 中對應的位置，產生<em>新字串</em>。 (核心邏輯：<code>s[p[j]-1] = tmp[j]</code>)</li></ul></li><li><strong>儲存結果</strong>: 將本次修改產生的新字串 <code>s</code> 存入 2D 陣列 <code>c</code> 的第 <code>i</code> 列 (row) 中。</li><li><strong>依格式輸出</strong>: 所有修改完成後，使用巢狀迴圈來輸出。<ul><li>外層迴圈 <code>i</code> 從 <code>0</code> 到 <code>r-1</code>（代表要輸出的第 <code>i</code> 個字元，共 <code>r</code> 行）。</li><li>內層迴圈 <code>j</code> 從 <code>0</code> 到 <code>q-1</code>（代表第 <code>j</code> 次修改的結果）。</li><li>在內層迴圈中輸出 <code>c[j][i]</code>，即第 <code>j</code> 次修改結果的第 <code>i</code> 個字元。</li><li>外層迴圈每跑完一次，就輸出一行換行符。</li></ul></li></ol><h2 id=分段步驟程式碼-1>分段步驟程式碼<a hidden class=anchor aria-hidden=true href=#分段步驟程式碼-1>#</a></h2><h3 id=讀取基本資訊與宣告陣列>讀取基本資訊與宣告陣列<a hidden class=anchor aria-hidden=true href=#讀取基本資訊與宣告陣列>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>k</span> <span class=o>&gt;&gt;</span> <span class=n>q</span> <span class=o>&gt;&gt;</span> <span class=n>r</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>p</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>c</span><span class=p>[</span><span class=n>q</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼讀取 <code>k</code>, <code>q</code>, <code>r</code> 和初始字串 <code>s</code>。並宣告 <code>p</code> 陣列用來儲存每次讀入的排列，<code>c</code> 陣列用來儲存 <code>q</code> 次修改的全部結果。</p><h3 id=模擬修改過程並儲存結果>模擬修改過程並儲存結果<a hidden class=anchor aria-hidden=true href=#模擬修改過程並儲存結果>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>q</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼是解題的核心。</p><ol><li>外層迴圈 <code>for(int i=0;i&lt;q;i++)</code> 執行 <code>q</code> 次修改。</li><li><code>cin >> p[j];</code> 讀取該次的排列。</li><li><code>string tmp = s;</code> 將當前的字串 <code>s</code> (舊字串) 複製到 <code>tmp</code>。</li><li><code>s[p[j]-1] = tmp[j];</code> 根據排列 <code>p</code>，將 <code>tmp</code> (舊字串) 的第 <code>j</code> 個字元，放到 <code>s</code> (新字串) 的第 <code>p[j]-1</code> 個位置上。</li><li><code>c[i][j] = s[j];</code> 將剛產生出來的新字串 <code>s</code>，完整複製到 <code>c[i]</code> 這一列，以便後續輸出。</li></ol><h3 id=依格式輸出>依格式輸出<a hidden class=anchor aria-hidden=true href=#依格式輸出>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>r</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>q</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼負責最後的輸出。</p><ul><li>外層迴圈 <code>i</code> 跑 <code>r</code> 次，代表要輸出 <code>r</code> 行。</li><li>內層迴圈 <code>j</code> 跑 <code>q</code> 次，代表 <code>q</code> 次修改的結果。</li><li><code>cout &lt;&lt; c[j][i];</code> 輸出的順序是：<ul><li>第 1 行 (<code>i=0</code>)：輸出 <code>c[0][0]</code>, <code>c[1][0]</code>, <code>c[2][0]</code>&mldr; (所有結果的第 1 個字元)</li><li>第 2 行 (<code>i=1</code>)：輸出 <code>c[0][1]</code>, <code>c[1][1]</code>, <code>c[2][1]</code>&mldr; (所有結果的第 2 個字元)</li><li>&mldr;</li><li>第 r 行 (<code>i=r-1</code>)：輸出 <code>c[0][r-1]</code>, <code>c[1][r-1]</code>, <code>c[2][r-1]</code>&mldr; (所有結果的第 r 個字元)</li></ul></li><li>這恰好符合題目要求的「轉置」輸出格式。</li></ul><h2 id=完整程式碼-1>完整程式碼<a hidden class=anchor aria-hidden=true href=#完整程式碼-1>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>k</span> <span class=o>&gt;&gt;</span> <span class=n>q</span> <span class=o>&gt;&gt;</span> <span class=n>r</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>p</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>[</span><span class=n>q</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>q</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>string</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>[</span><span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>r</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>q</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022~2025 <a href=https://aura.codex.tw/>Aura's Space</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>