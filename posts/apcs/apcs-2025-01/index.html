<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>APCS-2025-01 | Aura's Space</title><meta name=keywords content="C++"><meta name=description content="1. 等紅綠燈
解題步驟

讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。
計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。
遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。
讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。
判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。
累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。
輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。

分段步驟程式碼
讀取輸入與初始化


1
2
3


int green, red, n, t, delay = 0;
cin >> green >> red >> n;
int loop = green + red;


這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。"><meta name=author content="Aura"><link rel=canonical href=http://localhost:1313/posts/apcs/apcs-2025-01/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/favicon.ico><link rel=apple-touch-icon href=http://localhost:1313/images/favicon.ico><link rel=mask-icon href=http://localhost:1313/images/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/apcs/apcs-2025-01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/apcs/apcs-2025-01/"><meta property="og:site_name" content="Aura's Space"><meta property="og:title" content="APCS-2025-01"><meta property="og:description" content="1. 等紅綠燈 解題步驟 讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。 計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。 遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。 讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。 判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。 累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。 輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。 分段步驟程式碼 讀取輸入與初始化 1 2 3 int green, red, n, t, delay = 0; cin >> green >> red >> n; int loop = green + red; 這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-11T22:17:41+00:00"><meta property="article:modified_time" content="2025-05-11T22:17:41+00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="APCS-2025-01"><meta name=twitter:description content="1. 等紅綠燈
解題步驟

讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。
計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。
遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。
讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。
判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。
累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。
輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。

分段步驟程式碼
讀取輸入與初始化


1
2
3


int green, red, n, t, delay = 0;
cin >> green >> red >> n;
int loop = green + red;


這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"APCS-2025-01","item":"http://localhost:1313/posts/apcs/apcs-2025-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"APCS-2025-01","name":"APCS-2025-01","description":"1. 等紅綠燈 解題步驟 讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。 計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。 遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。 讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。 判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。 累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。 輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。 分段步驟程式碼 讀取輸入與初始化 1 2 3 int green, red, n, t, delay = 0; cin \u0026gt;\u0026gt; green \u0026gt;\u0026gt; red \u0026gt;\u0026gt; n; int loop = green + red; 這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。\n","keywords":["C++"],"articleBody":"1. 等紅綠燈 解題步驟 讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。 計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。 遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。 讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。 判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。 累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。 輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。 分段步驟程式碼 讀取輸入與初始化 1 2 3 int green, red, n, t, delay = 0; cin \u003e\u003e green \u003e\u003e red \u003e\u003e n; int loop = green + red; 這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。\n遍歷小朋友並計算等待時間 1 2 3 4 5 6 7 for(int i=0;i\u003cn;i++){ cin \u003e\u003e t; t %= loop; if(t \u003e= green){ delay += loop - t; } } 這段程式碼使用 for 迴圈處理 n 個小朋友。\ncin \u003e\u003e t;：讀取當前小朋友騎完一圈的時間 t。 t %= loop;：這是解題的關鍵。我們只關心小朋友在紅綠燈週期的 哪個時間點 抵達，而不在乎他繞了幾圈。取 t 對 loop 的餘數，可以得到他在週期中的抵達時間（範圍會是 0 到 loop-1）。 if(t \u003e= green)：判斷這個抵達時間是否在紅燈時段。綠燈時段是 [0, green-1]，紅燈時段是 [green, loop-1]。 delay += loop - t;：如果是在紅燈時段（t）抵達，他需要等到週期結束（loop），因此等待時間為 loop - t。將這段時間累加到 delay。 輸出總等待時間 1 cout \u003c\u003c delay ; 迴圈結束後，delay 已經累計了所有小朋友的等待時間，將其輸出。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include using namespace std; int main(){ int green, red, n, t, delay = 0; cin \u003e\u003e green \u003e\u003e red \u003e\u003e n; int loop = green + red; for(int i=0;i\u003cn;i++){ cin \u003e\u003e t; t %= loop; if(t \u003e= green){ delay += loop - t; } } cout \u003c\u003c delay ; return 0; } 2. 字串操作 解題步驟 讀取輸入與初始化: 讀取初始字串 s 和操作次數 k。並儲存字串的長度 s_len 以方便後續使用。 迴圈處理 K 次操作: 使用一個 for 迴圈，從 i=0 到 k-1，執行 k 次操作。 讀取並判斷操作類型: 在 for 迴圈中，首先讀取當次的操作類型 op。 執行操作: 如果 op == 0 (兩兩交換): 寫一個 for 迴圈，j 從 0 開始，每次遞增 2 (即 0, 2, 4, …)。在迴圈中，使用一個 temp 變數來交換 s[j] 和 s[j+1]。 如果 op == 1 (兩兩排序): 同樣使用一個 j 迴圈 (步長為 2)。在迴圈中，檢查 if(s[j] \u003e s[j+1])，如果條件成立（即順序錯誤），則交換 s[j] 和 s[j+1]。 如果 op == 2 (完美重排): 宣告一個暫存字串 s_temp 並將 s 複製過去。接著，寫一個 for 迴圈，i 從 0 跑到 s_len/2 - 1。在迴圈中，將 s_temp 的前半段 s_temp[i] 放到 s 的偶數索引 s[2*i]，並將 s_temp 的後半段 s_temp[i + s_len/2] 放到 s 的奇數索引 s[2*i+1]。 輸出最終字串: 在 k 次操作的 for 迴圈結束後，輸出最終的字串 s。 分段步驟程式碼 讀取輸入與初始化 1 2 3 4 string s; int k, op; cin \u003e\u003e s \u003e\u003e k; int s_len = s.length(); 這段程式碼讀取初始字串 s 和操作次數 k，並將 s 的長度儲存在 s_len 變數中。\n迴圈處理 K 次操作 1 2 3 4 for(int i=0;i\u003ck;i++){ cin \u003e\u003e op; // ... 根據 op 執行對應操作 ... } 這段程式碼建立一個迴圈，會執行 k 次。在每次迴圈開始時，讀取使用者輸入的操作類型 op。\n操作 0: 兩兩交換 1 2 3 4 5 6 7 if(op == 0){ for(int j=0;j\u003cs_len;j+=2){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } 如果 op 為 0，此迴圈會遍歷字串的索引 0, 2, 4, …，並將 s[j] 和 s[j+1] 進行交換。\n操作 1: 兩兩排序 1 2 3 4 5 6 7 8 9 else if(op == 1){ for(int j=0;j\u003cs_len;j+=2){ if(s[j] \u003e s[j+1]){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } } 如果 op 為 1，此迴圈同樣遍歷索引 0, 2, 4, …。但只在 s[j] 的字典序大於 s[j+1] 時才進行交換，確保每對字元都按字典序排列。\n操作 2: 完美重排 1 2 3 4 5 6 7 else{ string s_temp = s; for(int i=0;i\u003cs_len/2;i++){ s[2*i] = s_temp[i]; s[2*i+1] = s_temp[i+s_len/2]; } } 如果 op 為 2，首先建立一個 s_temp 來保存 s 的原始狀態。然後迴圈 i 從 0 執行到 s_len/2 - 1，將 s_temp 的前半段 s_temp[i] 和後半段 s_temp[i + s_len/2] 交錯放入 s 的 s[2*i] 和 s[2*i+1] 位置。\n輸出最終結果 1 cout \u003c\u003c s; 在 k 次操作全部執行完畢後，輸出字串 s 的最終內容。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include using namespace std; int main(){ string s; int k, op; cin \u003e\u003e s \u003e\u003e k; int s_len = s.length(); for(int i=0;i\u003ck;i++){ cin \u003e\u003e op; if(op == 0){ for(int j=0;j\u003cs_len;j+=2){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } else if(op == 1){ for(int j=0;j\u003cs_len;j+=2){ if(s[j] \u003e s[j+1]){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } } else{ string s_temp = s; for(int i=0;i\u003cs_len/2;i++){ s[2*i] = s_temp[i]; s[2*i+1] = s_temp[i+s_len/2]; } } } cout \u003c\u003c s; return 0; } ","wordCount":"660","inLanguage":"en","datePublished":"2025-05-11T22:17:41Z","dateModified":"2025-05-11T22:17:41Z","author":{"@type":"Person","name":"Aura"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/apcs/apcs-2025-01/"},"publisher":{"@type":"Organization","name":"Aura's Space","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Aura's Space (Alt + H)"><img src=http://localhost:1313/images/favicon.ico alt aria-label=logo height=35>Aura's Space</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">APCS-2025-01</h1><div class=post-meta><span title='2025-05-11 22:17:41 +0000 UTC'>May 11, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Aura</span></div></header><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><div class=post-content><h1 id=1-等紅綠燈>1. 等紅綠燈<a hidden class=anchor aria-hidden=true href=#1-等紅綠燈>#</a></h1><h2 id=解題步驟>解題步驟<a hidden class=anchor aria-hidden=true href=#解題步驟>#</a></h2><ol><li><strong>讀取輸入</strong>: 讀取綠燈秒數 <code>green</code>、紅燈秒數 <code>red</code>，以及小朋友的人數 <code>n</code>。</li><li><strong>計算週期與初始化</strong>: 計算一個完整的紅綠燈週期 <code>loop = green + red</code>。初始化總等待時間 <code>delay</code> 為 0。</li><li><strong>遍歷小朋友</strong>: 使用 <code>for</code> 迴圈，依序處理 <code>n</code> 個小朋友。</li><li><strong>讀取騎車時間並計算抵達時刻</strong>: 在迴圈中，讀取每個小朋友的騎車時間 <code>t</code>。使用模數運算 (<code>%</code>) 計算 <code>t % loop</code>，這代表小朋友在一個週期中的哪個時間點抵達終點。</li><li><strong>判斷是否遇到紅燈</strong>: 檢查抵達時間 <code>t % loop</code> 是否大於等於綠燈時間 <code>green</code>。如果是，表示小朋友在紅燈時段抵達。</li><li><strong>累計等待時間</strong>: 如果在紅燈時段抵達，計算需要等待的時間（<code>loop - (t % loop)</code>），並將其累加到總等待時間 <code>delay</code>。</li><li><strong>輸出總和</strong>: 迴圈結束後，<code>delay</code> 變數中儲存了所有小朋友的總等待時間，將其輸出。</li></ol><h2 id=分段步驟程式碼>分段步驟程式碼<a hidden class=anchor aria-hidden=true href=#分段步驟程式碼>#</a></h2><h3 id=讀取輸入與初始化>讀取輸入與初始化<a hidden class=anchor aria-hidden=true href=#讀取輸入與初始化>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>green</span><span class=p>,</span> <span class=n>red</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>delay</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>green</span> <span class=o>&gt;&gt;</span> <span class=n>red</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>loop</span> <span class=o>=</span> <span class=n>green</span> <span class=o>+</span> <span class=n>red</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼宣告所有需要的變數。<code>green</code> 和 <code>red</code> 分別儲存綠燈和紅燈的秒數，<code>n</code> 為小朋友人數，<code>t</code> 用於暫存每個小朋友的時間，<code>delay</code> 用於累計總等待時間並初始化為 0。接著讀取 <code>green</code>、<code>red</code> 和 <code>n</code>，並計算出完整的紅綠燈週期 <code>loop</code>。</p><h3 id=遍歷小朋友並計算等待時間>遍歷小朋友並計算等待時間<a hidden class=anchor aria-hidden=true href=#遍歷小朋友並計算等待時間>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>%=</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>t</span> <span class=o>&gt;=</span> <span class=n>green</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>delay</span> <span class=o>+=</span> <span class=n>loop</span> <span class=o>-</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼使用 <code>for</code> 迴圈處理 <code>n</code> 個小朋友。</p><ul><li><code>cin >> t;</code>：讀取當前小朋友騎完一圈的時間 <code>t</code>。</li><li><code>t %= loop;</code>：這是解題的關鍵。我們只關心小朋友在紅綠燈週期的 <em>哪個時間點</em> 抵達，而不在乎他繞了幾圈。取 <code>t</code> 對 <code>loop</code> 的餘數，可以得到他在週期中的抵達時間（範圍會是 0 到 <code>loop-1</code>）。</li><li><code>if(t >= green)</code>：判斷這個抵達時間是否在紅燈時段。綠燈時段是 <code>[0, green-1]</code>，紅燈時段是 <code>[green, loop-1]</code>。</li><li><code>delay += loop - t;</code>：如果是在紅燈時段（<code>t</code>）抵達，他需要等到週期結束（<code>loop</code>），因此等待時間為 <code>loop - t</code>。將這段時間累加到 <code>delay</code>。</li></ul><h3 id=輸出總等待時間>輸出總等待時間<a hidden class=anchor aria-hidden=true href=#輸出總等待時間>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>delay</span> <span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>迴圈結束後，<code>delay</code> 已經累計了所有小朋友的等待時間，將其輸出。</p><h2 id=完整程式碼>完整程式碼<a hidden class=anchor aria-hidden=true href=#完整程式碼>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>green</span><span class=p>,</span> <span class=n>red</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>delay</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>green</span> <span class=o>&gt;&gt;</span> <span class=n>red</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>loop</span> <span class=o>=</span> <span class=n>green</span> <span class=o>+</span> <span class=n>red</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>%=</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>t</span> <span class=o>&gt;=</span> <span class=n>green</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>delay</span> <span class=o>+=</span> <span class=n>loop</span> <span class=o>-</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>delay</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=2-字串操作>2. 字串操作<a hidden class=anchor aria-hidden=true href=#2-字串操作>#</a></h1><h2 id=解題步驟-1>解題步驟<a hidden class=anchor aria-hidden=true href=#解題步驟-1>#</a></h2><ol><li><strong>讀取輸入與初始化</strong>: 讀取初始字串 <code>s</code> 和操作次數 <code>k</code>。並儲存字串的長度 <code>s_len</code> 以方便後續使用。</li><li><strong>迴圈處理 K 次操作</strong>: 使用一個 <code>for</code> 迴圈，從 <code>i=0</code> 到 <code>k-1</code>，執行 <code>k</code> 次操作。</li><li><strong>讀取並判斷操作類型</strong>: 在 <code>for</code> 迴圈中，首先讀取當次的操作類型 <code>op</code>。</li><li><strong>執行操作</strong>:<ul><li><strong>如果 <code>op == 0</code> (兩兩交換)</strong>: 寫一個 <code>for</code> 迴圈，<code>j</code> 從 0 開始，每次遞增 2 (即 0, 2, 4, &mldr;)。在迴圈中，使用一個 <code>temp</code> 變數來交換 <code>s[j]</code> 和 <code>s[j+1]</code>。</li><li><strong>如果 <code>op == 1</code> (兩兩排序)</strong>: 同樣使用一個 <code>j</code> 迴圈 (步長為 2)。在迴圈中，檢查 <code>if(s[j] > s[j+1])</code>，如果條件成立（即順序錯誤），則交換 <code>s[j]</code> 和 <code>s[j+1]</code>。</li><li><strong>如果 <code>op == 2</code> (完美重排)</strong>: 宣告一個暫存字串 <code>s_temp</code> 並將 <code>s</code> 複製過去。接著，寫一個 <code>for</code> 迴圈，<code>i</code> 從 <code>0</code> 跑到 <code>s_len/2 - 1</code>。在迴圈中，將 <code>s_temp</code> 的前半段 <code>s_temp[i]</code> 放到 <code>s</code> 的偶數索引 <code>s[2*i]</code>，並將 <code>s_temp</code> 的後半段 <code>s_temp[i + s_len/2]</code> 放到 <code>s</code> 的奇數索引 <code>s[2*i+1]</code>。</li></ul></li><li><strong>輸出最終字串</strong>: 在 <code>k</code> 次操作的 <code>for</code> 迴圈結束後，輸出最終的字串 <code>s</code>。</li></ol><h2 id=分段步驟程式碼-1>分段步驟程式碼<a hidden class=anchor aria-hidden=true href=#分段步驟程式碼-1>#</a></h2><h3 id=讀取輸入與初始化-1>讀取輸入與初始化<a hidden class=anchor aria-hidden=true href=#讀取輸入與初始化-1>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>s</span> <span class=o>&gt;&gt;</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>s_len</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼讀取初始字串 <code>s</code> 和操作次數 <code>k</code>，並將 <code>s</code> 的長度儲存在 <code>s_len</code> 變數中。</p><h3 id=迴圈處理-k-次操作>迴圈處理 K 次操作<a hidden class=anchor aria-hidden=true href=#迴圈處理-k-次操作>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 根據 op 執行對應操作 ...
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>這段程式碼建立一個迴圈，會執行 <code>k</code> 次。在每次迴圈開始時，讀取使用者輸入的操作類型 <code>op</code>。</p><h3 id=操作-0-兩兩交換>操作 0: 兩兩交換<a hidden class=anchor aria-hidden=true href=#操作-0-兩兩交換>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>s_len</span><span class=p>;</span><span class=n>j</span><span class=o>+=</span><span class=mi>2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>   <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果 <code>op</code> 為 0，此迴圈會遍歷字串的索引 0, 2, 4, &mldr;，並將 <code>s[j]</code> 和 <code>s[j+1]</code> 進行交換。</p><h3 id=操作-1-兩兩排序>操作 1: 兩兩排序<a hidden class=anchor aria-hidden=true href=#操作-1-兩兩排序>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>s_len</span><span class=p>;</span><span class=n>j</span><span class=o>+=</span><span class=mi>2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>   <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果 <code>op</code> 為 1，此迴圈同樣遍歷索引 0, 2, 4, &mldr;。但只在 <code>s[j]</code> 的字典序大於 <code>s[j+1]</code> 時才進行交換，確保每對字元都按字典序排列。</p><h3 id=操作-2-完美重排>操作 2: 完美重排<a hidden class=anchor aria-hidden=true href=#操作-2-完美重排>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s_temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>s_len</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>s_temp</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>s_temp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>s_len</span><span class=o>/</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果 <code>op</code> 為 2，首先建立一個 <code>s_temp</code> 來保存 <code>s</code> 的原始狀態。然後迴圈 <code>i</code> 從 <code>0</code> 執行到 <code>s_len/2 - 1</code>，將 <code>s_temp</code> 的前半段 <code>s_temp[i]</code> 和後半段 <code>s_temp[i + s_len/2]</code> 交錯放入 <code>s</code> 的 <code>s[2*i]</code> 和 <code>s[2*i+1]</code> 位置。</p><h3 id=輸出最終結果>輸出最終結果<a hidden class=anchor aria-hidden=true href=#輸出最終結果>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>在 <code>k</code> 次操作全部執行完畢後，輸出字串 <code>s</code> 的最終內容。</p><h2 id=完整程式碼-1>完整程式碼<a hidden class=anchor aria-hidden=true href=#完整程式碼-1>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include&lt;iostream&gt;
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>s</span> <span class=o>&gt;&gt;</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s_len</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>s_len</span><span class=p>;</span><span class=n>j</span><span class=o>+=</span><span class=mi>2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=kt>char</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>   <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>op</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>s_len</span><span class=p>;</span><span class=n>j</span><span class=o>+=</span><span class=mi>2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=kt>char</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                    <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>   <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                    <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>string</span> <span class=n>s_temp</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>s_len</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>s_temp</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span><span class=p>[</span><span class=mi>2</span><span class=o>*</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>s_temp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>s_len</span><span class=o>/</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022~2025 <a href=http://localhost:1313/>Aura's Space</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>