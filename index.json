[{"content":"1. 七言對聯 解題步驟 讀取資料: 首先讀取對聯的組數 n，接著進入迴圈處理每一組對聯。在迴圈中，讀取第一句（存入陣列 a）與第二句（存入陣列 b）的平仄數據。 建立違規紀錄變數: 宣告一個空字串 ans，用來串接違反的規則代號（A、B、C）。 檢查規則 A (二四不同二六同): 檢查每一句的第 2、4 字平仄是否相同（違規），以及第 2、6 字平仄是否不同（違規）。只要有一句違反，就將 \u0026lsquo;A\u0026rsquo; 加入 ans。 檢查規則 B (仄起平收): 檢查第一句結尾是否為平聲（0，違規），或第二句結尾是否為仄聲（1，違規）。若違反，將 \u0026lsquo;B\u0026rsquo; 加入 ans。 檢查規則 C (上下相對): 檢查上下兩句在第 2、4、6 位置的平仄是否相同（違規）。若有任一位置相同，將 \u0026lsquo;C\u0026rsquo; 加入 ans。 輸出結果: 檢查 ans 字串。若為空，代表完全符合規則，輸出 \u0026ldquo;None\u0026rdquo;；否則輸出累積的違規代號字串 ans。 分段步驟程式碼說明 1. 讀取輸入與陣列初始化 1 2 3 4 5 6 7 8 9 int n, a[8], b[8]; // 宣告大小為 8 的陣列，以便使用 1-7 的直觀索引 cin \u0026gt;\u0026gt; n; while(n--){ // 讀取第一句的 7 個平仄值 for(int i=1; i\u0026lt;=7; i++) cin \u0026gt;\u0026gt; a[i]; // 讀取第二句的 7 個平仄值 for(int i=1; i\u0026lt;=7; i++) cin \u0026gt;\u0026gt; b[i]; string ans = \u0026#34;\u0026#34;; // 用來儲存錯誤代碼的字串 說明： 這裡使用 a[8] 和 b[8] 是為了讓陣列索引值（index）能直接對應題目的第 1 到第 7 個字（忽略索引 0），這樣寫起來比較直觀，不容易搞混位置。\n2. 檢查規則 A：二四不同二六同 1 2 3 4 5 6 7 8 9 10 // 規則 A：每一句第二、四字必須不同，二、六字必須相同 // 這裡判斷「違規」的情況： // a[2]==a[4] (第一句 2,4 相同，違規) 或 a[2]!=a[6] (第一句 2,6 不同，違規) // b[2]==b[4] (第二句 2,4 相同，違規) 或 b[2]!=b[6] (第二句 2,6 不同，違規) if(a[2]==a[4] || a[2]!=a[6] || b[2]==b[4] || b[2]!=b[6]){ ans += \u0026#34;A\u0026#34;; } 說明： 題目要求「二四不同」且「二六相同」。 程式碼使用邏輯運算子 || (OR) 來檢查**反面（違規）**的情況。只要第一句或第二句有任何一點不符合，就視為違反規則 A。\n3. 檢查規則 B：仄起平收 1 2 3 4 5 6 7 8 // 規則 B：第一句結尾(a[7])須為仄(1)，第二句結尾(b[7])須為平(0) // 這裡判斷「違規」的情況： // a[7] 為 0 (第一句結尾是平聲，違規) // b[7] 為 1 (第二句結尾是仄聲，違規) if(a[7]==0 || b[7]==1){ ans += \u0026#34;B\u0026#34;; } 說明： 根據題目定義：平聲是 0，仄聲是 1。 正確應該是 a[7]==1 且 b[7]==0。 所以如果 a[7] 是 0 或者 b[7] 是 1，代表違反了規則 B。\n4. 檢查規則 C：上下相對 1 2 3 4 5 6 7 8 9 10 // 規則 C：第一、二句的第二、四、六個字平仄必須不同 // 這裡判斷「違規」的情況： // 上下句的第 2 字相同 (a[2]==b[2]) // 上下句的第 4 字相同 (a[4]==b[4]) // 上下句的第 6 字相同 (a[6]==b[6]) if(a[2]==b[2] || a[4]==b[4] || a[6]==b[6]){ ans += \u0026#34;C\u0026#34;; } 說明： 題目要求相對位置的平仄要「不同」。 因此，如果發現任何一個關鍵位置（2, 4, 6）的平仄是「相同」的，就代表違反了規則 C。\n5. 輸出結果 1 2 3 if(ans == \u0026#34;\u0026#34;) cout \u0026lt;\u0026lt; \u0026#34;None\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 說明： 若 ans 仍為空字串，表示三個 if 判斷皆未成立，即沒有違反任何規則，輸出 \u0026ldquo;None\u0026rdquo;。否則輸出累積的違規字串（例如 \u0026ldquo;AB\u0026rdquo; 或 \u0026ldquo;C\u0026rdquo;）。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; // 雖非必要(iostream通常包含string)，但加上較嚴謹 using namespace std; int main(){ int n, a[8], b[8]; cin \u0026gt;\u0026gt; n; while(n--){ // 1. 讀取輸入 for(int i=1; i\u0026lt;=7; i++) cin \u0026gt;\u0026gt; a[i]; for(int i=1; i\u0026lt;=7; i++) cin \u0026gt;\u0026gt; b[i]; string ans = \u0026#34;\u0026#34;; // 2. 檢查規則 A (單句內的邏輯) // 違規條件：(第2字等於第4字) 或 (第2字不等於第6字) if(a[2]==a[4] || a[2]!=a[6] || b[2]==b[4] || b[2]!=b[6]){ ans += \u0026#34;A\u0026#34;; } // 3. 檢查規則 B (句尾邏輯) // 違規條件：(第一句尾為平聲 0) 或 (第二句尾為仄聲 1) if(a[7]==0 || b[7]==1){ ans += \u0026#34;B\u0026#34;; } // 4. 檢查規則 C (兩句間的相對邏輯) // 違規條件：(第2,4,6位置的上下字平仄相同) if(a[2]==b[2] || a[4]==b[4] || a[6]==b[6]){ ans += \u0026#34;C\u0026#34;; } // 5. 輸出結果 if(ans == \u0026#34;\u0026#34;) cout \u0026lt;\u0026lt; \u0026#34;None\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 2. 魔王迷宮 解題步驟 讀取輸入與初始化: 讀取棋盤大小 $N \\times M$ 與魔王數量 $K$。建立一個二維陣列（地圖）來記錄炸彈數量，並使用陣列或向量儲存每一位魔王的位置 $(r, c)$、移動向量 $(s, t)$ 以及存活狀態。 模擬回合流程 (Loop): 只要場上還有存活的魔王，就持續進行回合循環。 放置炸彈與移動: 對於每一位存活的魔王，先在當前位置放置一顆炸彈（地圖數值 +1），然後依照其移動向量更新座標位置。 檢查邊界與碰撞: 檢查移動後的魔王是否超出棋盤邊界（消失），或是否踩到有炸彈的格子（引爆）。 若超出邊界：魔王標記為死亡。 若踩到炸彈：魔王標記為死亡，並將該格子標記為「待清除狀態」（例如設為 -1），以便處理多個魔王同時踩到同一格的情況。 清除爆炸現場: 掃描整個地圖，將所有標記為「待清除狀態」（-1）的格子歸零（炸彈與魔王皆消失）。 檢查遊戲是否繼續: 檢查是否還有魔王存活，若無則結束迴圈。 計算剩餘炸彈: 掃描整個棋盤，統計地圖上數值大於 0 的格子數量。 輸出結果: 輸出最終的炸彈總數。 分段步驟程式碼 1. 讀取輸入與初始化 首先讀取 $N, M, K$，並初始化地圖 map 與魔王的相關資訊。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int n, m, k, r, c, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; // map 初始化為 n x m 的二維向量，預設值為 0 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; map(n, vector\u0026lt;int\u0026gt;(m, 0)); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; king_pos, king_move; vector\u0026lt;bool\u0026gt; king_exist; // 記錄魔王是否存活 for (int i = 0; i \u0026lt; k; i++) { cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; king_pos.push_back({r, c}); king_move.push_back({s, t}); king_exist.push_back(true); // 一開始所有魔王都是活著的 } 2. 模擬遊戲過程：放置炸彈與移動 在每個回合中，活著的魔王先在腳下放炸彈（map 對應位置 +1），然後才進行移動。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool keep_playing = true; // 控制遊戲迴圈 while (keep_playing) { // 第一階段：放炸彈與移動 for (int i = 0; i \u0026lt; k; i++) { if (!king_exist[i]) continue; // 死掉的魔王跳過 // 在當前位置放炸彈 map[king_pos[i].first][king_pos[i].second]++; // 移動到新位置 king_pos[i].first += king_move[i].first; king_pos[i].second += king_move[i].second; } // ... (接續下一階段) 3. 模擬遊戲過程：判定出界與引爆 移動後，檢查魔王的新位置。如果出界，魔王消失。如果新位置有炸彈（數值 \u0026gt; 0），魔王與炸彈同歸於盡。 注意技巧：程式碼中使用 -1 來標記剛剛發生爆炸的格子，這樣即使同一回合有多個魔王踩進同一格，也能正確判斷死亡。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 第二階段：檢查狀態 for (int i = 0; i \u0026lt; k; i++) { if (!king_exist[i]) continue; // 檢查是否出界 if (king_pos[i].first \u0026gt;= n || king_pos[i].second \u0026gt;= m || king_pos[i].first \u0026lt; 0 || king_pos[i].second \u0026lt; 0) { king_exist[i] = false; } // 檢查是否踩到炸彈 (\u0026gt;0) 或是踩到正在爆炸的格子 (==-1) else if (map[king_pos[i].first][king_pos[i].second] \u0026gt; 0 || map[king_pos[i].first][king_pos[i].second] == -1) { king_exist[i] = false; // 標記該位置發生爆炸，稍後統一清除 map[king_pos[i].first][king_pos[i].second] = -1; } } // 第三階段：清除爆炸痕跡 // 將所有標記為 -1 的格子歸零（炸彈消失） for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (map[j][i] == -1) { map[j][i] = 0; } } } 4. 檢查終止條件 掃描所有魔王狀態，如果全體陣亡，則將 keep_playing 設為 false 結束遊戲。\n1 2 3 4 5 6 7 8 keep_playing = false; for (int i = 0; i \u0026lt; k; i++) { if (king_exist[i] == true) { // 只要還有一個人活著 keep_playing = true; break; // 提早結束檢查 } } } // while 迴圈結束 5. 計算總分與輸出 最後掃描地圖，計算剩下多少格有炸彈（數值大於 0）。\n1 2 3 4 5 6 7 8 9 int cnt = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (map[j][i] \u0026gt; 0) { cnt++; } } } cout \u0026lt;\u0026lt; cnt; 完整程式碼 以下是整理過後包含註解的完整程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { // 1. 讀取輸入 int n, m, k, r, c, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; // 初始化地圖與魔王資訊 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; map(n, vector\u0026lt;int\u0026gt;(m, 0)); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; king_pos, king_move; vector\u0026lt;bool\u0026gt; king_exist; for (int i = 0; i \u0026lt; k; i++) { cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; king_pos.push_back({r, c}); king_move.push_back({s, t}); king_exist.push_back(true); } bool keep_playing = true; // 是否有人活著 // 2. 模擬遊戲迴圈 while (keep_playing) { // --- 階段 A: 放置炸彈並移動 --- for (int i = 0; i \u0026lt; k; i++) { if (!king_exist[i]) { continue; } // 先在原地放炸彈 map[king_pos[i].first][king_pos[i].second]++; // 更新座標 (移動) king_pos[i].first += king_move[i].first; king_pos[i].second += king_move[i].second; } // --- 階段 B: 檢查新位置狀態 (出界或引爆) --- for (int i = 0; i \u0026lt; k; i++) { if (!king_exist[i]) { continue; } // 檢查是否超出邊界 if (king_pos[i].first \u0026gt;= n || king_pos[i].second \u0026gt;= m || king_pos[i].first \u0026lt; 0 || king_pos[i].second \u0026lt; 0) { king_exist[i] = false; // 出界即消失 } // 檢查新位置是否有炸彈 (\u0026gt;0) 或剛被引爆 (-1) else if (map[king_pos[i].first][king_pos[i].second] \u0026gt; 0 || map[king_pos[i].first][king_pos[i].second] == -1) { king_exist[i] = false; // 被炸死 map[king_pos[i].first][king_pos[i].second] = -1; // 標記此處發生爆炸 } } // --- 階段 C: 清除爆炸現場 --- for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (map[j][i] == -1) { map[j][i] = 0; // 炸彈與魔王皆消失，歸零 } } } // --- 階段 D: 檢查是否繼續遊戲 --- keep_playing = false; for (int i = 0; i \u0026lt; k; i++) { if (king_exist[i] == true) { // 只要還有人活著 keep_playing = true; break; } } } // 3. 計算剩餘炸彈並輸出 int cnt = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (map[j][i] \u0026gt; 0) { cnt++; } } } cout \u0026lt;\u0026lt; cnt; return 0; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2021-09/","summary":"\u003ch1 id=\"1-七言對聯\"\u003e1. 七言對聯\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取資料\u003c/strong\u003e: 首先讀取對聯的組數 \u003ccode\u003en\u003c/code\u003e，接著進入迴圈處理每一組對聯。在迴圈中，讀取第一句（存入陣列 \u003ccode\u003ea\u003c/code\u003e）與第二句（存入陣列 \u003ccode\u003eb\u003c/code\u003e）的平仄數據。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e建立違規紀錄變數\u003c/strong\u003e: 宣告一個空字串 \u003ccode\u003eans\u003c/code\u003e，用來串接違反的規則代號（A、B、C）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e檢查規則 A (二四不同二六同)\u003c/strong\u003e: 檢查每一句的第 2、4 字平仄是否\u003cstrong\u003e相同\u003c/strong\u003e（違規），以及第 2、6 字平仄是否\u003cstrong\u003e不同\u003c/strong\u003e（違規）。只要有一句違反，就將 \u0026lsquo;A\u0026rsquo; 加入 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e檢查規則 B (仄起平收)\u003c/strong\u003e: 檢查第一句結尾是否為平聲（0，違規），或第二句結尾是否為仄聲（1，違規）。若違反，將 \u0026lsquo;B\u0026rsquo; 加入 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e檢查規則 C (上下相對)\u003c/strong\u003e: 檢查上下兩句在第 2、4、6 位置的平仄是否\u003cstrong\u003e相同\u003c/strong\u003e（違規）。若有任一位置相同，將 \u0026lsquo;C\u0026rsquo; 加入 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 檢查 \u003ccode\u003eans\u003c/code\u003e 字串。若為空，代表完全符合規則，輸出 \u0026ldquo;None\u0026rdquo;；否則輸出累積的違規代號字串 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"分段步驟程式碼說明\"\u003e分段步驟程式碼說明\u003c/h2\u003e\n\u003ch3 id=\"1-讀取輸入與陣列初始化\"\u003e1. 讀取輸入與陣列初始化\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 宣告大小為 8 的陣列，以便使用 1-7 的直觀索引\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 讀取第一句的 7 個平仄值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 讀取第二句的 7 個平仄值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 用來儲存錯誤代碼的字串\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e說明\u003c/strong\u003e：\n這裡使用 \u003ccode\u003ea[8]\u003c/code\u003e 和 \u003ccode\u003eb[8]\u003c/code\u003e 是為了讓陣列索引值（index）能直接對應題目的第 1 到第 7 個字（忽略索引 0），這樣寫起來比較直觀，不容易搞混位置。\u003c/p\u003e","title":"APCS-2021-09"},{"content":"1. 修補圍籬 解題步驟 讀取圍籬數量和高度：讀取圍籬的總數量 n，接著使用迴圈讀取 n 個圍籬各自的高度，並存入一個 vector（或陣列）fence 中。 初始化成本變數：宣告一個整數變數 ans 並將其初始化為 0，用來累計修補圍籬所需的總成本。 遍歷圍籬並判斷：使用 for 迴圈從頭到尾檢查每一個圍籬（索引 i 從 0 到 n-1）。 檢查是否損壞：在迴圈中，判斷 fence[i] 是否等於 0。如果等於 0，表示這個位置的圍籬斷了，需要修補。 處理邊界與中間情況： 左邊界：如果 i == 0（第一個圍籬），則成本增加其右側鄰居 fence[1] 的高度。 右邊界：如果 i == n-1（最後一個圍籬），則成本增加其左側鄰居 fence[n-2] 的高度。 中間：如果不是邊界，則比較其左側 fence[i-1] 和右側 fence[i+1] 的高度，取較小的那個高度加入總成本 ans。 輸出最終成本：迴圈結束後，ans 中儲存的就是修補所有斷掉圍籬的總成本，將其輸出。 分段步驟程式碼 讀取圍籬數量和高度 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int n; //圍籬數量 cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; fence(n); //圍籬高度 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; fence[i]; } 這段程式碼首先引入必要的函式庫，然後讀取圍籬數量 n，並宣告一個大小為 n 的 vector 叫 fence。接著，它使用一個 for 迴圈來讀取 n 次，將每個圍籬的高度存入 vector 中。\n初始化成本並遍歷計算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int ans=0; for(int i=0;i\u0026lt;n;i++){ if(fence[i]==0){ // 判斷圍籬是否為 0 (斷掉) if(i == 0){ // 情況 1: 斷在最左邊 ans += fence[1]; } else if(i == n-1){ // 情況 2: 斷在最右邊 ans += fence[n-2]; } else{ // 情況 3: 斷在中間 // ans += 判斷式?成立程式碼:否定程式碼 // 使用三元運算子取左右兩邊較小的高度 ans += fence[i-1] \u0026gt; fence[i+1] ? fence[i+1] : fence[i-1]; } } } 這段程式碼是解題的核心。\n初始化 ans = 0 來計算總成本。 for(int i=0; i\u0026lt;n; i++)：遍歷所有圍籬。 if(fence[i]==0)：檢查當前圍籬是否斷掉。 接著的三個 if-else if-else 區塊分別處理了題目中提到的三種情況：斷在最左邊、斷在最右邊、以及斷在中間。 對於中間情況，ans += fence[i-1] \u0026gt; fence[i+1] ? fence[i+1] : fence[i-1]; 是一個三元運算子，它等同於 ans += min(fence[i-1], fence[i+1])，即取左右兩側較小的值加入成本。 輸出最終成本 1 2 cout \u0026lt;\u0026lt; ans; } 在所有計算完成後，這行程式碼會印出累計的總成本 ans，並結束 main 函式。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int n; //圍籬數量 cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; fence(n); //圍籬高度 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; fence[i]; } int ans=0; for(int i=0;i\u0026lt;n;i++){ if(fence[i]==0){ if(i == 0){ ans += fence[1]; } else if(i == n-1){ ans += fence[n-2]; } else{ // ans += 判斷式?成立程式碼:否定程式碼 ans += fence[i-1] \u0026gt; fence[i+1] ? fence[i+1] : fence[i-1]; } } } cout \u0026lt;\u0026lt; ans; } 2. 動線安排 解題步驟 讀取輸入與初始化: 讀取展場大小 $m, n$ 和操作次數 $h$。宣告一個 $m \\times n$ 的二維陣列 arr 來模擬展場狀態。我們使用 -1 代表木樁，0 代表空地，正數代表該格被線經過的次數。同時初始化最大面積 mx 為 0。 定義輔助函數: nowArea(): 遍歷整個 arr 陣列，計算值不為 0 (即有木樁或有線) 的格子總數，並返回該總數作為當前面積。 haveStake(r, c, dir): 檢查從 $(r, c)$ 往 dir (0=右, 1=左, 2=上, 3=下) 方向搜尋，路徑上是否會遇到木樁 (-1)。 add(r, c, dir): 從 $(r, c)$ 往 dir 方向，將路徑上所有格子的計數值 ++，直到遇到木樁 (-1) 或碰到邊界為止。 rmv(r, c, dir): 從 $(r, c)$ 往 dir 方向，將路徑上所有格子的計數值 --，直到遇到木樁 (-1)、空地 (0) 或碰到邊界為止。 模擬 $h$ 次操作: 使用 for 迴圈執行 $h$ 次操作。在每次迴圈中： 讀取操作位置 $(r, c)$ 和操作類型 $t$。 若 $t == 0$ (加入木樁): 首先檢查 arr[r][c] 是否大於 0 (即有線經過)。如果是，表示需要先拆除舊線。透過 haveStake 檢查四個方向，若有木樁，則呼叫 rmv 移除該方向的連線。 將 arr[r][c] 設為 -1，表示放置木樁。 透過 haveStake 檢查四個方向，若有木樁，則呼叫 add 建立該方向的新連線。 若 $t == 1$ (移除木樁): 將 arr[r][c] 設為 0，表示移除木樁。 透過 haveStake 檢查四個方向，若有木樁，則呼叫 rmv 移除該方向的連線。 更新最大面積: 在每次操作（加入或移除）完成後，呼叫 nowArea() 計算當前面積，並使用 mx = max(mx, nowArea()) 來更新過程中的最大面積。 輸出結果: $h$ 次操作全部完成後，輸出 mx (過程最大面積) 和最後一次呼叫 nowArea() (最終面積) 的結果。 分段步驟程式碼 讀取輸入與全域變數 1 2 3 4 5 #include\u0026lt;iostream\u0026gt; using namespace std; int m, n, h, r, c, t, arr[100][100] = {}, mx = 0; 這段程式碼包含必要的標頭檔，並宣告所有需要的全域變數，包括 $m, n, h$，當前操作的 $r, c, t$，以及 $100 \\times 100$ 的展場陣列 arr 和最大面積 mx。\n移除連線 (rmv) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void rmv(int r,int c,int dir){ if(dir == 0){ // 向右 for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1||arr[r][i]==0) return; if(arr[r][i]\u0026gt;0) arr[r][i]--; } } else if(dir == 1){ // 向左 for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1||arr[r][i]==0) return; if(arr[r][i]\u0026gt;0) arr[r][i]--; } } else if(dir == 2){ // 向上 for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1||arr[i][c]==0) return; if(arr[i][c]\u0026gt;0) arr[i][c]--; } } else if(dir == 3){ // 向下 for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1||arr[i][c]==0) return; if(arr[i][c]\u0026gt;0) arr[i][c]--; } } } 此函數根據指定方向 dir，將 $(r, c)$ 到下一個木樁 (-1) 或空地 (0) 之間的線 (\u0026gt;0) 計數減 1。\n加入連線 (add) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void add(int r,int c,int dir){ if(dir == 0){ // 向右 for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1) return; arr[r][i]++; } } else if(dir == 1){ // 向左 for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1) return; arr[r][i]++; } } else if(dir == 2){ // 向上 for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1) return; arr[i][c]++; } } else if(dir == 3){ // 向下 for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1) return; arr[i][c]++; } } } 此函數根據指定方向 dir，將 $(r, c)$ 到下一個木樁 (-1) 之間的線計數加 1。\n檢查木樁 (haveStake) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 bool haveStake(int r, int c, int dir){ if(dir == 0){ // 向右 for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1) return true; } return false; } else if(dir == 1){ // 向左 for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1) return true; } return false; } else if(dir == 2){ // 向上 for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1) return true; } return false; } else if(dir == 3){ // 向下 for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1) return true; } return false; } return false; } 此函數檢查從 $(r, c)$ 沿指定方向 dir 是否存在木樁 (-1)。\n計算面積 (nowArea) 1 2 3 4 5 6 7 8 9 int nowArea(){ int cnt=0; for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(arr[i][j]!=0) cnt++; } } return cnt; } 此函數遍歷 $m \\times n$ 展場，計算所有非 0 (有木樁或線) 的格子數量。\n主程式：處理操作與輸出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; for(int hh=0;hh\u0026lt;h;hh++){ // 陣列值: 0=沒東西,-1是木樁,正數是線的數量 cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt;t; if(t==0){ // 加入木樁 if(arr[r][c]!=0){ // 如果有線經過，先拆線 if(haveStake(r,c,0))rmv(r,c,0); if(haveStake(r,c,1))rmv(r,c,1); if(haveStake(r,c,2))rmv(r,c,2); if(haveStake(r,c,3))rmv(r,c,3); } arr[r][c]=-1; // 放置木樁 // 建立新連線 if(haveStake(r,c,0))add(r,c,0); if(haveStake(r,c,1))add(r,c,1); if(haveStake(r,c,2))add(r,c,2); if(haveStake(r,c,3))add(r,c,3); } else{ // 移除木樁 arr[r][c]=0; // 移除木樁 // 移除相關連線 if(haveStake(r,c,0))rmv(r,c,0); if(haveStake(r,c,1))rmv(r,c,1); if(haveStake(r,c,2))rmv(r,c,2); if(haveStake(r,c,3))rmv(r,c,3); _ } mx = max(mx,nowArea()); // 更新最大面積 } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; nowArea(); // 輸出最大面積與最終面積 } 這是程式的主體。它首先讀取 $m, n, h$，然後進入 $h$ 次迴圈，根據 $t$ 的值執行加入或移除木樁的邏輯，並在每次操作後更新最大面積 mx。最後輸出 mx 和 $h$ 次操作後的最終面積。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 #include\u0026lt;iostream\u0026gt; using namespace std; int m, n, h, r, c, t, arr[100][100] = {}, mx = 0; void rmv(int r,int c,int dir){ if(dir == 0){ for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1||arr[r][i]==0) return; if(arr[r][i]\u0026gt;0) arr[r][i]--; } } else if(dir == 1){ for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1||arr[r][i]==0) return; if(arr[r][i]\u0026gt;0) arr[r][i]--; } } else if(dir == 2){ for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1||arr[i][c]==0) return; if(arr[i][c]\u0026gt;0) arr[i][c]--; } } else if(dir == 3){ for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1||arr[i][c]==0) return; if(arr[i][c]\u0026gt;0) arr[i][c]--; } } } void add(int r,int c,int dir){ if(dir == 0){ for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1) return; arr[r][i]++; } } else if(dir == 1){ for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1) return; arr[r][i]++; } } else if(dir == 2){ for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1) return; arr[i][c]++; } } else if(dir == 3){ for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1) return; arr[i][c]++; } } } bool haveStake(int r, int c, int dir){ if(dir == 0){ for(int i=c+1;i\u0026lt;n;i++){ if(arr[r][i]==-1) return true; } return false; } else if(dir == 1){ for(int i=c-1;i\u0026gt;=0;i--){ if(arr[r][i]==-1) return true; } return false; } else if(dir == 2){ for(int i=r-1;i\u0026gt;=0;i--){ if(arr[i][c]==-1) return true; } return false; } else if(dir == 3){ for(int i=r+1;i\u0026lt;m;i++){ if(arr[i][c]==-1) return true; } return false; } return false; } int nowArea(){ int cnt=0; for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(arr[i][j]!=0) cnt++; } } return cnt; } int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; for(int hh=0;hh\u0026lt;h;hh++){ // 陣列值: 0=沒東西,-1是木樁,正數是線的數量 cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt;t; if(t==0){ // 加入木樁 if(arr[r][c]!=0){ if(haveStake(r,c,0))rmv(r,c,0); if(haveStake(r,c,1))rmv(r,c,1); if(haveStake(r,c,2))rmv(r,c,2); if(haveStake(r,c,3))rmv(r,c,3); } arr[r][c]=-1; if(haveStake(r,c,0))add(r,c,0); if(haveStake(r,c,1))add(r,c,1); if(haveStake(r,c,2))add(r,c,2); if(haveStake(r,c,3))add(r,c,3); } else{ // 移除木樁 arr[r][c]=0; if(haveStake(r,c,0))rmv(r,c,0); if(haveStake(r,c,1))rmv(r,c,1); if(haveStake(r,c,2))rmv(r,c,2); if(haveStake(r,c,3))rmv(r,c,3); } mx = max(mx,nowArea()); } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; nowArea(); } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2021-11/","summary":"\u003ch1 id=\"1-修補圍籬\"\u003e1. 修補圍籬\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取圍籬數量和高度\u003c/strong\u003e：讀取圍籬的總數量 \u003ccode\u003en\u003c/code\u003e，接著使用迴圈讀取 \u003ccode\u003en\u003c/code\u003e 個圍籬各自的高度，並存入一個 \u003ccode\u003evector\u003c/code\u003e（或陣列）\u003ccode\u003efence\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化成本變數\u003c/strong\u003e：宣告一個整數變數 \u003ccode\u003eans\u003c/code\u003e 並將其初始化為 0，用來累計修補圍籬所需的總成本。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e遍歷圍籬並判斷\u003c/strong\u003e：使用 \u003ccode\u003efor\u003c/code\u003e 迴圈從頭到尾檢查每一個圍籬（索引 \u003ccode\u003ei\u003c/code\u003e 從 \u003ccode\u003e0\u003c/code\u003e 到 \u003ccode\u003en-1\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e檢查是否損壞\u003c/strong\u003e：在迴圈中，判斷 \u003ccode\u003efence[i]\u003c/code\u003e 是否等於 0。如果等於 0，表示這個位置的圍籬斷了，需要修補。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e處理邊界與中間情況\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e左邊界\u003c/strong\u003e：如果 \u003ccode\u003ei == 0\u003c/code\u003e（第一個圍籬），則成本增加其右側鄰居 \u003ccode\u003efence[1]\u003c/code\u003e 的高度。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e右邊界\u003c/strong\u003e：如果 \u003ccode\u003ei == n-1\u003c/code\u003e（最後一個圍籬），則成本增加其左側鄰居 \u003ccode\u003efence[n-2]\u003c/code\u003e 的高度。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e中間\u003c/strong\u003e：如果不是邊界，則比較其左側 \u003ccode\u003efence[i-1]\u003c/code\u003e 和右側 \u003ccode\u003efence[i+1]\u003c/code\u003e 的高度，取\u003cstrong\u003e較小\u003c/strong\u003e的那個高度加入總成本 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出最終成本\u003c/strong\u003e：迴圈結束後，\u003ccode\u003eans\u003c/code\u003e 中儲存的就是修補所有斷掉圍籬的總成本，將其輸出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取圍籬數量和高度\"\u003e讀取圍籬數量和高度\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;iostream\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;vector\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e//圍籬數量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003efence\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e//圍籬高度\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003efence\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼首先引入必要的函式庫，然後讀取圍籬數量 \u003ccode\u003en\u003c/code\u003e，並宣告一個大小為 \u003ccode\u003en\u003c/code\u003e 的 \u003ccode\u003evector\u003c/code\u003e 叫 \u003ccode\u003efence\u003c/code\u003e。接著，它使用一個 \u003ccode\u003efor\u003c/code\u003e 迴圈來讀取 \u003ccode\u003en\u003c/code\u003e 次，將每個圍籬的高度存入 \u003ccode\u003evector\u003c/code\u003e 中。\u003c/p\u003e","title":"APCS-2021-11"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次我們聊到的 Human-in-the-Loop，我們學會了如何在 AI 衝過頭時踩煞車。但有個問題一直縈繞在心頭：如果我的資料超級敏感（比如公司的財務報表或是阿嬤的傳家食譜），我真的放心把這些東西往雲端送嗎？\n這時候，我們需要一個能把 AI 「關在家裡」跑的方案。今天的主角就是 Ollama。它讓你在本機環境就能跑起強大的開源模型，再搭配 LangChain 的整合，簡直是隱私控的福音。\n一、 為什麼是 Ollama？ Ollama 是一個能讓你輕鬆在個人電腦（Windows, macOS, Linux）執行開源大型語言模型（LLM）的工具。它的核心概念是：\n打包（Bundling）：它將模型權重、配置、資料全部打包成一個稱為 Modelfile 的格式。 最佳化（Optimization）：它會幫你處理好 GPU 使用率等底層設定，你不需要自己去跟 CUDA 驅動程式搏鬥。 在地化（Local）：所有的計算都在你的硬體上完成，資料不出門。 二、 快速上手：把模型「拖」進來 在開始寫程式碼之前，我們得先讓 Ollama 在電腦裡跑起來。\n1. 安裝 Ollama macOS: 直接用 brew install ollama 搞定。 Linux/WSL: 官方有提供安裝指令。 Windows: 至官網下載安裝檔。 2. 下載模型 你可以在終端機輸入指令來下載你想要玩的模型：\n1 2 3 4 5 # 抓取最新的 Llama 3.1 ollama pull llama3.1 # 如果想試試具備工具調用能力的 gpt-oss ollama pull gpt-oss:20b 筆記：模型預設會存在 ~/.ollama/models (Mac) 或 /usr/share/ollama/.ollama/models (Linux)。\n三、 LangChain 與 Ollama 的強強聯手 要讓 LangChain 控制 Ollama，我們需要安裝專用的整合套件：\n1 pip install -qU langchain-ollama 實作：基本調用（Invocation） 我們來寫一個簡單的翻譯助手。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from langchain_ollama import ChatOllama # 建立模型物件 llm = ChatOllama( model=\u0026#34;llama3.1\u0026#34;, temperature=0, ) # 準備訊息 messages = [ (\u0026#34;system\u0026#34;, \u0026#34;你是一個專業的翻譯官，負責把英文翻譯成繁體中文。\u0026#34;), (\u0026#34;human\u0026#34;, \u0026#34;I love programming with LangChain.\u0026#34;), ] # 呼叫模型 ai_msg = llm.invoke(messages) print(ai_msg.content) 四、 進階功能：AI 不只是會聊天 Ollama 透過 ChatOllama 類別，其實支援了很多現代模型才有的特異功能：\n1. 工具調用（Tool Calling） 有些模型（如 gpt-oss）經過微調，可以精準地決定何時該「去查資料」或「呼叫函數」。\n功能 支援情況 備註 JSON Mode ✅ 強制輸出 JSON 格式 Token 流式輸出 ✅ 即問即答，不用乾等 原生非同步 ✅ 提升程式執行效率 多模態輸入 ✅ 支援圖片理解（如 bakllava） 2. 多模態範例（看圖說故事） 如果你使用的模型支援視覺（例如 bakllava 或 gemma3），你可以把圖片轉成 Base64 編碼塞進去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 示意代碼：傳送圖片給模型 from langchain_ollama import ChatOllama from langchain.messages import HumanMessage llm = ChatOllama(model=\u0026#34;bakllava\u0026#34;) # 構建包含圖片與文字的訊息 content = [ {\u0026#34;type\u0026#34;: \u0026#34;image_url\u0026#34;, \u0026#34;image_url\u0026#34;: f\u0026#34;data:image/jpeg;base64,{image_b64}\u0026#34;}, {\u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;這張圖表中的成長率是多少？\u0026#34;} ] response = llm.invoke([HumanMessage(content=content)]) print(response.content) 五、 推理模型與自定義角色 最近很紅的「推理模型」（Reasoning Models），例如 IBM 的 Granite 3.2，支援一種特別的模式來展示它的「心路歷程」。\n在 ChatOllama 中，我們可以透過非標準的 ChatMessage 來啟動這個機制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from langchain_core.messages import ChatMessage from langchain_ollama import ChatOllama llm = ChatOllama(model=\u0026#34;granite3.2:8b\u0026#34;) messages = [ # 設定控制角色為 \u0026#39;thinking\u0026#39; ChatMessage(role=\u0026#34;control\u0026#34;, content=\u0026#34;thinking\u0026#34;), HumanMessage(\u0026#34;為什麼 3^3 等於 27？\u0026#34;), ] response = llm.invoke(messages) print(response.content) 這時候，你會發現模型輸出的內容會包含 Thought Process，讓你知道它是怎麼一步步算出來的，而不只是給一個冷冰冰的答案。\n六、 注意事項與踩坑筆記 版本更新：Ollama 進化非常快，建議時不時跑一下 pip install -U ollama 確保驅動層是最新的。 模型標籤：下載時若不指定 tag，預設通常是該模型最小、最精簡的版本。如果你的記憶體夠大，可以試著抓 70b 之類的巨獸。 效能瓶頸：在地化跑模型，電腦風扇狂轉是正常的，那是「AI 的心跳聲」。 七、 結語 Ollama 讓「私有化 AI」這件事從實驗室走向了每個人的桌面。當我們把 ChatOllama 放入 LangChain 的工作流中，我們就擁有了一個既安全、又強大，且完全由自己主宰的智慧大腦。\n下次如果你在深夜寫扣，不想讓雲端服務知道你在幹嘛，就把 Ollama 叫起來陪你吧！\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep6/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"零-前言\"\u003e零、 前言\u003c/h3\u003e\n\u003cp\u003e接續上次我們聊到的 \u003cstrong\u003eHuman-in-the-Loop\u003c/strong\u003e，我們學會了如何在 AI 衝過頭時踩煞車。但有個問題一直縈繞在心頭：如果我的資料超級敏感（比如公司的財務報表或是阿嬤的傳家食譜），我真的放心把這些東西往雲端送嗎？\u003c/p\u003e\n\u003cp\u003e這時候，我們需要一個能把 AI 「關在家裡」跑的方案。今天的主角就是 \u003cstrong\u003eOllama\u003c/strong\u003e。它讓你在本機環境就能跑起強大的開源模型，再搭配 \u003cstrong\u003eLangChain\u003c/strong\u003e 的整合，簡直是隱私控的福音。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"一-為什麼是-ollama\"\u003e一、 為什麼是 Ollama？\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eOllama\u003c/strong\u003e 是一個能讓你輕鬆在個人電腦（Windows, macOS, Linux）執行開源大型語言模型（LLM）的工具。它的核心概念是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e打包（Bundling）\u003c/strong\u003e：它將模型權重、配置、資料全部打包成一個稱為 \u003ccode\u003eModelfile\u003c/code\u003e 的格式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e最佳化（Optimization）\u003c/strong\u003e：它會幫你處理好 GPU 使用率等底層設定，你不需要自己去跟 CUDA 驅動程式搏鬥。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e在地化（Local）\u003c/strong\u003e：所有的計算都在你的硬體上完成，資料不出門。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-快速上手把模型拖進來\"\u003e二、 快速上手：把模型「拖」進來\u003c/h3\u003e\n\u003cp\u003e在開始寫程式碼之前，我們得先讓 Ollama 在電腦裡跑起來。\u003c/p\u003e\n\u003ch4 id=\"1-安裝-ollama\"\u003e1. 安裝 Ollama\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003emacOS\u003c/strong\u003e: 直接用 \u003ccode\u003ebrew install ollama\u003c/code\u003e 搞定。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLinux/WSL\u003c/strong\u003e: 官方有提供安裝指令。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWindows\u003c/strong\u003e: 至官網下載安裝檔。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-下載模型\"\u003e2. 下載模型\u003c/h4\u003e\n\u003cp\u003e你可以在終端機輸入指令來下載你想要玩的模型：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 抓取最新的 Llama 3.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eollama pull llama3.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果想試試具備工具調用能力的 gpt-oss\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eollama pull gpt-oss:20b\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e筆記\u003c/strong\u003e：模型預設會存在 \u003ccode\u003e~/.ollama/models\u003c/code\u003e (Mac) 或 \u003ccode\u003e/usr/share/ollama/.ollama/models\u003c/code\u003e (Linux)。\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP6: Ollama - 讓 LLM 在家裡「乖乖坐好」的在地化秘訣"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次我們聊到的 Streaming，串流讓 AI 有了「呼吸感」，但當 AI 的「手」（Tools）伸向一些敏感區域時，光有呼吸是不夠的。\n想像一下：如果你讓 AI 幫你管理資料庫，它突然決定執行一條 DELETE FROM records 刪掉你過去 30 天的資料；或者它寫了一封語氣奇怪的信準備寄給你的大老闆。這時候，你需要的不是看著它「順暢地」把錯事做完，而是一個能讓它停下來、等你點頭的機制。這就是我們今天要聊的 Human-in-the-Loop (HITL)。\n一、 什麼是 Human-in-the-Loop？ Human-in-the-Loop (HITL) 是一種中介軟體（Middleware）機制。它在模型「提案」執行某個工具（Tool Call）與「實際執行」之間加了一道關卡。\n當模型提出一些可能有風險的操作（例如：寫入檔案、執行 SQL）時，中介軟體會根據預設的策略（Policy）攔截這個動作，將執行狀態「暫停」並保存起來，等待人類的最終決定。\n二、 HITL 的核心三要素 要實作這套「人工審核」機制，LangChain 依賴以下三個核心組件：\nInterrupt (中斷)：當符合攔截條件時，系統發出信號停止執行。 Persistence (持久層)：使用 LangGraph 的檢查點（Checkpointer）來保存當前的圖形狀態（Graph State）。這確保了程序可以在暫停後，即使重啟也能從原點恢復。 Configurable Policy (配置策略)：定義哪些工具需要被監督。 三、 三種人類抉擇：Approve, Edit, Reject 當 AI 被攔截後，身為「主管」的你有三種處理方式：\n決策類型 說明 範例 ✅ approve 原封不動核准執行。 郵件草稿沒問題，直接寄出。 ✏️ edit 修改工具參數後再執行。 將郵件的收件人從 A 改成 B 再寄出。 ❌ reject 拒絕執行，並給予 AI 反饋。 拒絕刪除指令，並告訴 AI：「這太危險了，請改用查詢。」 注意：在使用 edit 修改參數時，建議進行保守的改動。劇烈的修改可能會導致模型重新評估其策略，進而引發非預期的後續行為。\n四、 如何配置 HITL 中介軟體？ 在建立 Agent 時，我們可以透過 HumanInTheLoopMiddleware 來指定哪些工具需要被監視。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from langchain.agents import create_agent from langchain.agents.middleware import HumanInTheLoopMiddleware from langgraph.checkpoint.memory import InMemorySaver agent = create_agent( model=\u0026#34;gpt-4o\u0026#34;, tools=[write_file_tool, execute_sql_tool, read_data_tool], middleware=[ HumanInTheLoopMiddleware( interrupt_on={ \u0026#34;write_file\u0026#34;: True, # 攔截並允許所有決策 \u0026#34;execute_sql\u0026#34;: { # 攔截但禁止編輯 \u0026#34;allowed_decisions\u0026#34;: [\u0026#34;approve\u0026#34;, \u0026#34;reject\u0026#34;] }, \u0026#34;read_data\u0026#34;: False, # 安全操作，不攔截 }, description_prefix=\u0026#34;工具執行待審核\u0026#34;, ), ], # 必須配置檢查點以處理中斷與恢復 checkpointer=InMemorySaver(), ) 五、 回應中斷：Command 的藝術 當 agent.invoke() 觸發中斷時，回傳結果會包含一個 __interrupt__ 欄位，裡面詳列了待審核的動作清單。要恢復執行，我們需要使用 Command(resume=...)。\n範例：批准執行 1 2 3 4 5 6 7 from langgraph.types import Command # 使用相同的 thread_id 恢復對話 agent.invoke( Command(resume={\u0026#34;decisions\u0026#34;: [{\u0026#34;type\u0026#34;: \u0026#34;approve\u0026#34;}]}), config={\u0026#34;configurable\u0026#34;: {\u0026#34;thread_id\u0026#34;: \u0026#34;user_001\u0026#34;}} ) 範例：拒絕並給予反饋 1 2 3 4 5 6 7 8 9 agent.invoke( Command(resume={ \u0026#34;decisions\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;reject\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;我不允許刪除這份檔案，請先備份。\u0026#34; }] }), config=config ) 六、 串流與 HITL 的結合 如果你同時使用了 Streaming 與 HITL，你可以在 stream() 的循環中監控 __interrupt__：\n1 2 3 4 5 # 使用 stream_mode=[\u0026#39;updates\u0026#39;, \u0026#39;messages\u0026#39;] for mode, chunk in agent.stream(input_data, config=config, stream_mode=[\u0026#34;updates\u0026#34;, \u0026#34;messages\u0026#34;]): if mode == \u0026#34;updates\u0026#34; and \u0026#34;__interrupt__\u0026#34; in chunk: print(f\u0026#34;\\n🛑 觸發人工審核：{chunk[\u0026#39;__interrupt__\u0026#39;]}\u0026#34;) # 在此處等待使用者輸入... 七、 結語 Human-in-the-Loop 為 AI Agent 補上了最後一塊「安全性」拼圖。它讓 AI 不再是一個不可控的黑盒，而是一個會適時停下來徵詢意見的助手。\n當 AI 具備了 Tools（手）、Streaming（呼吸）以及 HITL（安全剎車）後，它才能真正走進生產環境，處理那些具備法律、財務或資料風險的真實任務。\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep5/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"零-前言\"\u003e零、 前言\u003c/h3\u003e\n\u003cp\u003e接續上次我們聊到的 \u003cstrong\u003eStreaming\u003c/strong\u003e，串流讓 AI 有了「呼吸感」，但當 AI 的「手」（Tools）伸向一些敏感區域時，光有呼吸是不夠的。\u003c/p\u003e\n\u003cp\u003e想像一下：如果你讓 AI 幫你管理資料庫，它突然決定執行一條 \u003ccode\u003eDELETE FROM records\u003c/code\u003e 刪掉你過去 30 天的資料；或者它寫了一封語氣奇怪的信準備寄給你的大老闆。這時候，你需要的不是看著它「順暢地」把錯事做完，而是一個能讓它停下來、等你點頭的機制。這就是我們今天要聊的 \u003cstrong\u003eHuman-in-the-Loop (HITL)\u003c/strong\u003e。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"一-什麼是-human-in-the-loop\"\u003e一、 什麼是 Human-in-the-Loop？\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eHuman-in-the-Loop (HITL)\u003c/strong\u003e 是一種中介軟體（Middleware）機制。它在模型「提案」執行某個工具（Tool Call）與「實際執行」之間加了一道關卡。\u003c/p\u003e\n\u003cp\u003e當模型提出一些可能有風險的操作（例如：寫入檔案、執行 SQL）時，中介軟體會根據預設的策略（Policy）攔截這個動作，將執行狀態「暫停」並保存起來，等待人類的最終決定。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-hitl-的核心三要素\"\u003e二、 HITL 的核心三要素\u003c/h3\u003e\n\u003cp\u003e要實作這套「人工審核」機制，LangChain 依賴以下三個核心組件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eInterrupt (中斷)\u003c/strong\u003e：當符合攔截條件時，系統發出信號停止執行。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePersistence (持久層)\u003c/strong\u003e：使用 LangGraph 的檢查點（Checkpointer）來保存當前的圖形狀態（Graph State）。這確保了程序可以在暫停後，即使重啟也能從原點恢復。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConfigurable Policy (配置策略)\u003c/strong\u003e：定義哪些工具需要被監督。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"三-三種人類抉擇approve-edit-reject\"\u003e三、 三種人類抉擇：Approve, Edit, Reject\u003c/h3\u003e\n\u003cp\u003e當 AI 被攔截後，身為「主管」的你有三種處理方式：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e決策類型\u003c/th\u003e\n          \u003cth\u003e說明\u003c/th\u003e\n          \u003cth\u003e範例\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e✅ \u003cstrong\u003e\u003ccode\u003eapprove\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e原封不動核准執行。\u003c/td\u003e\n          \u003ctd\u003e郵件草稿沒問題，直接寄出。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e✏️ \u003cstrong\u003e\u003ccode\u003eedit\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e修改工具參數後再執行。\u003c/td\u003e\n          \u003ctd\u003e將郵件的收件人從 A 改成 B 再寄出。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e❌ \u003cstrong\u003e\u003ccode\u003ereject\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e拒絕執行，並給予 AI 反饋。\u003c/td\u003e\n          \u003ctd\u003e拒絕刪除指令，並告訴 AI：「這太危險了，請改用查詢。」\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e：在使用 \u003ccode\u003eedit\u003c/code\u003e 修改參數時，建議進行保守的改動。劇烈的修改可能會導致模型重新評估其策略，進而引發非預期的後續行為。\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP5: LangChain - Human-in-the-Loop, 給 AI 的「緊急煞車」"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次關於 Tools 的討論，當我們賦予了 Agent 雙手去執行任務後，下一個面臨的問題就是「等待」。LLM 生成回應需要時間，尤其是當任務涉及多個工具調用時，漫長的空白等待會毀掉使用者體驗。因此，本篇要來聊聊 LangChain 的 Streaming (串流) 系統，這是提升應用程式響應速度與使用者體驗 (UX) 的核心技術。\n一、 為什麼需要串流？ 在 LLM 的應用中，延遲 (Latency) 是不可避免的。串流技術允許我們在完整回應準備好之前，就先將中間過程與部分內容「流」回前端。這不僅能讓使用者感覺系統在即時運作，也能即時顯示 Agent 的思考過程，讓整體互動更加透明、流暢。\n二、 LangChain 串流的三大核心模式 LangChain 提供了一個靈活的串流系統，主要透過 stream 或 astream 方法並配合 stream_mode 參數來實現：\n模式 (mode) 描述 應用場景 updates 每個 Agent 步驟結束後串流狀態更新。 顯示 Agent 目前跑到了哪個節點（如：模型、工具）。 messages 串流 LLM 生成的每一個 Token 與其元數據。 實現「打字機」效果或串流工具調用參數。 custom 透過 stream_writer 從節點內部發送自定義訊號。 顯示「正在查詢資料庫 (10/100)\u0026hellip;」等進度訊息。 三、 監控任務進度：updates 模式 如果你想監控 Agent 的整體執行流程，updates 是最直觀的模式。它會在每個節點（Node）執行完畢後，噴出該步驟產生的狀態變化。\n一個典型的工具調用流程在 updates 模式下會長這樣：\nModel Node: 噴出 AIMessage，內含工具調用請求 (Tool Calls)。 Tool Node: 噴出 ToolMessage，包含工具執行結果。 Model Node: 根據結果產生最終的 AI 回應。 1 2 3 4 5 6 7 8 # 使用 updates 模式監控步驟 for chunk in agent.stream( {\u0026#34;messages\u0026#34;: [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;台北天氣如何？\u0026#34;}]}, stream_mode=\u0026#34;updates\u0026#34;, ): for step, data in chunk.items(): print(f\u0026#34;目前步驟: {step}\u0026#34;) # data 內包含該步驟更新的訊息 四、 極致體驗：messages 模式與 Token 串流 這是我們最熟悉的場景：AI 一個字一個字吐出來。在 LangChain 中，這不僅限於最終文字，連 工具調用的參數 (Arguments) 也可以被串流。\n在 messages 模式下，你會收到 (token, metadata)。如果是工具調用，你會看到 tool_call_chunk 裡面逐漸拼湊出 JSON 格式的參數：\n優點：即使 AI 在思考複雜的工具參數，使用者也能即時看到進度。 技術細節：可以透過 chunk_position == \u0026quot;last\u0026quot; 來判斷訊息是否生成完畢。 1 2 3 4 5 6 # 串流 Token 與工具調用參數 for token, metadata in agent.stream( input_data, stream_mode=\u0026#34;messages\u0026#34; ): print(f\u0026#34;來自節點: {metadata[\u0026#39;langgraph_node\u0026#39;]}\u0026#34;) print(f\u0026#34;內容片段: {token.content_blocks}\u0026#34;) 五、 自定義串流：get_stream_writer 有時候，內建的模式不夠用。例如你在一個耗時的工具內部，想要每秒更新一次進度，這時就可以用 get_stream_writer：\n1 2 3 4 5 6 7 8 from langgraph.config import get_stream_writer def long_task_tool(param: str): writer = get_stream_writer() writer(\u0026#34;正在連線到遠端伺服器...\u0026#34;) # ... 執行任務 ... writer(\u0026#34;連線成功，正在抓取數據...\u0026#34;) return \u0026#34;任務完成\u0026#34; 注意：如果在工具內使用了 get_stream_writer，該工具就必須在 LangGraph 的執行環境下才能運作。\n六、 進階模式：多模式並行與多 Agent 協作 LangChain 支援同時傳入多個模式，例如 stream_mode=[\u0026quot;updates\u0026quot;, \u0026quot;custom\u0026quot;]。回傳的資料會變成 (mode, chunk) 的元組，讓你根據不同的模式進行不同的 UI 處理。\n1. 處理子 Agent (Sub-agents) 在多 Agent 系統中，訊息來源會變得很混亂。為了分辨是誰在說話，我們可以：\n在初始化模型時加入 tags=[\u0026quot;supervisor\u0026quot;] 或 tags=[\u0026quot;worker\u0026quot;]。 在串流時設置 subgraphs=True 以獲取子圖的輸出。 透過 metadata.get(\u0026quot;tags\u0026quot;) 來過濾並標示目前是哪個 Agent 正在發言。 2. 人機互動 (Human-in-the-loop) 當串流過程中遇到需要人工審核的步驟時，串流會噴出一個 __interrupt__ 事件。這時系統會暫停，直到接收到 Command(resume=...) 才會繼續。\n七、 停用串流的時機 雖然串流很酷，但並非所有情況都適合。在以下場景，你可能需要設置 streaming=False：\n多 Agent 路由：某些負責決策的內部 Agent 不需要對外展示。 LangSmith 佈署：防止特定的模型輸出被洩露到用戶端。 模型限制：某些舊型號或特定的 Chat Model 介面不支援串流參數（此時需改用 disable_streaming=True）。 八、 技術總結 串流不是選配，而是現代 AI 應用的標配。透過 updates 掌握骨幹流程，透過 messages 呈現細節質感，再配合 custom 補充業務進度。\n在 1.5 度的崩潰視角下，串流就像是 AI 的「生命徵象圖」。我們不僅是在看它給出的答案，更是在看它如何思考、如何掙扎、如何呼叫工具，最後才把結果呈現給我們。掌握了這套系統，你的 Agent 才算真正地活在即時的世界裡。\n九、 結語 「回應的快慢是效能問題，但回應的即時感是設計問題。」\n串流不只是技術上的實現，更是一種 UX 哲學。在 AI 回應緩慢的現實下，透過逐字顯示，我們給予了使用者一種「AI 正在努力思考並與你對話」的臨場感。\n下次當你看到 AI 停在那邊思考太久時，別忘了把串流開起來，給使用者一點「它還活著」的證據吧！\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep4/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"零-前言\"\u003e零、 前言\u003c/h3\u003e\n\u003cp\u003e接續上次關於 \u003cstrong\u003eTools\u003c/strong\u003e 的討論，當我們賦予了 Agent 雙手去執行任務後，下一個面臨的問題就是「等待」。LLM 生成回應需要時間，尤其是當任務涉及多個工具調用時，漫長的空白等待會毀掉使用者體驗。因此，本篇要來聊聊 LangChain 的 \u003cstrong\u003eStreaming (串流)\u003c/strong\u003e 系統，這是提升應用程式響應速度與使用者體驗 (UX) 的核心技術。\u003c/p\u003e\n\u003ch3 id=\"一-為什麼需要串流\"\u003e一、 為什麼需要串流？\u003c/h3\u003e\n\u003cp\u003e在 LLM 的應用中，延遲 (Latency) 是不可避免的。串流技術允許我們在完整回應準備好之前，就先將中間過程與部分內容「流」回前端。這不僅能讓使用者感覺系統在即時運作，也能即時顯示 Agent 的思考過程，讓整體互動更加透明、流暢。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-langchain-串流的三大核心模式\"\u003e二、 LangChain 串流的三大核心模式\u003c/h3\u003e\n\u003cp\u003eLangChain 提供了一個靈活的串流系統，主要透過 \u003ccode\u003estream\u003c/code\u003e 或 \u003ccode\u003eastream\u003c/code\u003e 方法並配合 \u003ccode\u003estream_mode\u003c/code\u003e 參數來實現：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e模式 (\u003ccode\u003emode\u003c/code\u003e)\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n          \u003cth\u003e應用場景\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003eupdates\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e每個 Agent 步驟結束後串流狀態更新。\u003c/td\u003e\n          \u003ctd\u003e顯示 Agent 目前跑到了哪個節點（如：模型、工具）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003emessages\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e串流 LLM 生成的每一個 Token 與其元數據。\u003c/td\u003e\n          \u003ctd\u003e實現「打字機」效果或串流工具調用參數。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e\u003ccode\u003ecustom\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e透過 \u003ccode\u003estream_writer\u003c/code\u003e 從節點內部發送自定義訊號。\u003c/td\u003e\n          \u003ctd\u003e顯示「正在查詢資料庫 (10/100)\u0026hellip;」等進度訊息。\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"三-監控任務進度updates-模式\"\u003e三、 監控任務進度：\u003ccode\u003eupdates\u003c/code\u003e 模式\u003c/h3\u003e\n\u003cp\u003e如果你想監控 Agent 的整體執行流程，\u003ccode\u003eupdates\u003c/code\u003e 是最直觀的模式。它會在每個節點（Node）執行完畢後，噴出該步驟產生的狀態變化。\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP4: LangChain - Streaming, 打破沈默的呼吸感"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次關於 Structured Output 的討論，當 Agent 能夠穩定輸出結構化數據後，下一步就是讓它具備「行動力」。在 LangChain 的世界裡，這被稱為 Tools (工具)。工具不僅擴展了 Agent 的能力邊界——讓它能抓取即時數據、執行程式碼或查詢資料庫，更重要的是，它定義了模型如何與真實世界互動的標準介面。\n一、 工具的本質：模型與現實的橋樑 在底層邏輯中，Tools 是具備明確 輸入 (Inputs) 與 輸出 (Outputs) 的可調用函數。\n當我們將工具傳遞給 Chat Model 時，模型並不是真的「執行」了程式碼，而是根據對話上下文決定「何時」調用工具以及「提供什麼參數」。這種決策機制讓 Agent 能夠像人類操作儀表板一樣，有目的地選擇工具。\n二、 快速上手：定義工具的三重境界 1. 基礎定義：@tool 裝飾器 這是最簡單的方式。LangChain 會自動將函數的 Docstring 轉換為工具描述，將 Type Hints 轉換為輸入 Schema。\n1 2 3 4 5 6 from langchain.tools import tool @tool def search_database(query: str, limit: int = 10) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;搜尋客戶資料庫中符合查詢條件的紀錄。\u0026#34;\u0026#34;\u0026#34; return f\u0026#34;找到 {limit} 筆關於 \u0026#39;{query}\u0026#39; 的結果\u0026#34; 註：Type Hints 是強制要求的，因為這是模型理解如何傳參的唯一依據。\n2. 自定義屬性 有時函數名稱不夠直觀，你可以手動覆蓋名稱與描述，以引導模型做出更準確的判斷：\nCustom Name: 例如將 calc 改為 calculator。 Custom Description: 提供更詳細的調用時機說明。 3. 進階 Schema：Pydantic 的威力 當工具參數變得複雜（例如需要列舉、布林值或預設值）時，可以使用 args_schema 綁定 Pydantic 模型：\n1 2 3 4 5 6 7 class WeatherInput(BaseModel): location: str = Field(description=\u0026#34;城市名稱或座標\u0026#34;) units: Literal[\u0026#34;celsius\u0026#34;, \u0026#34;fahrenheit\u0026#34;] = Field(default=\u0026#34;celsius\u0026#34;) @tool(args_schema=WeatherInput) def get_weather(location: str, units: str = \u0026#34;celsius\u0026#34;) -\u0026gt; str: ... 三、 關鍵核心：ToolRuntime 的上下文注入 工具最強大的地方在於它能存取 Runtime Context (執行階段上下文)。這讓工具不再是孤立的函數，而是能感知環境的智能組件。\n透過 ToolRuntime 參數，工具可以存取以下四大核心資源：\n資源類型 描述 應用範例 State (狀態) 執行過程中的可變數據。 統計目前對話中 AI 與 User 的訊息比例。 Context (上下文) 不可變的配置訊息。 根據 user_id 從資料庫調取特定帳戶餘額。 Store (儲存) 跨對話的長期記憶。 儲存並讀取使用者的個人偏好（如：喜好語言）。 Stream Writer 執行過程中的自定義串流。 在執行耗時任務時，即時回傳「正在檢索\u0026hellip;」給使用者。 重要提示： runtime 參數對模型是隱藏的。模型在調用工具時看不到這個參數，它由 LangGraph 內部自動注入，確保了安全性與簡潔性。\n四、 命令與控制：使用 Command 更新狀態 工具不只能回傳字串，還能回傳 Command 對象來控制 Agent 的行為。例如：\n清除歷史紀錄： 透過 RemoveMessage 讓 Agent 忘記之前的對話。 更新內部狀態： 工具執行完後，直接修改 Agent State 中的變數（如更新 user_name）。 五、 伺服器端工具 (Server-side Tools) 值得注意的是，並非所有工具都需要自行開發。如 OpenAI、Anthropic 與 Gemini 等模型供應商通常內建了伺服器端工具（如 Web Search 或 Code Interpreter）。這類工具由供應商直接執行，開發者只需通過配置即可調用。\n六、 技術總結 在 LangChain v1.0+ 的架構下，工具的設計 philosophy 是 「參數分離」：模型負責決策業務參數，而系統負責注入環境參數（Runtime）。這種設計讓工具具備了高度的可測試性與重用性。\n在 1.5 度的視角下，工具不再只是 Function Call，它是 Agent 的感官與手腳。當工具能讀取 Store 中的長期記憶，並透過 Command 修改 State 時，Agent 才真正具備了「進化」的可能性。\n七、 結語 「工具是人類能力的延伸，也是 AI 智能的落腳點。」\n掌握了 LangChain Tools，你就握住了通往實用性 AI 的鑰匙。它讓 AI 從「談話型」進化為「行動型」。雖然配置過程中有許多細節需要打磨，但當你看到模型自動查表、計算並發出報告的那一刻，你會發現這一切都是值得的。\n別再讓你的 AI 只是「坐著聊天」了，給它一把扳手，讓它動起來吧！\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep3/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"零-前言\"\u003e零、 前言\u003c/h3\u003e\n\u003cp\u003e接續上次關於 \u003cstrong\u003eStructured Output\u003c/strong\u003e 的討論，當 Agent 能夠穩定輸出結構化數據後，下一步就是讓它具備「行動力」。在 LangChain 的世界裡，這被稱為 \u003cstrong\u003eTools (工具)\u003c/strong\u003e。工具不僅擴展了 Agent 的能力邊界——讓它能抓取即時數據、執行程式碼或查詢資料庫，更重要的是，它定義了模型如何與真實世界互動的標準介面。\u003c/p\u003e\n\u003ch3 id=\"一-工具的本質模型與現實的橋樑\"\u003e一、 工具的本質：模型與現實的橋樑\u003c/h3\u003e\n\u003cp\u003e在底層邏輯中，Tools 是具備明確 \u003cstrong\u003e輸入 (Inputs)\u003c/strong\u003e 與 \u003cstrong\u003e輸出 (Outputs)\u003c/strong\u003e 的可調用函數。\u003c/p\u003e\n\u003cp\u003e當我們將工具傳遞給 Chat Model 時，模型並不是真的「執行」了程式碼，而是根據對話上下文決定「何時」調用工具以及「提供什麼參數」。這種決策機制讓 Agent 能夠像人類操作儀表板一樣，有目的地選擇工具。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-快速上手定義工具的三重境界\"\u003e二、 快速上手：定義工具的三重境界\u003c/h3\u003e\n\u003ch4 id=\"1-基礎定義tool-裝飾器\"\u003e1. 基礎定義：\u003ccode\u003e@tool\u003c/code\u003e 裝飾器\u003c/h4\u003e\n\u003cp\u003e這是最簡單的方式。LangChain 會自動將函數的 \u003cstrong\u003eDocstring\u003c/strong\u003e 轉換為工具描述，將 \u003cstrong\u003eType Hints\u003c/strong\u003e 轉換為輸入 Schema。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003elangchain.tools\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003etool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nd\"\u003e@tool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003esearch_database\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003equery\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elimit\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nb\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u0026#34;搜尋客戶資料庫中符合查詢條件的紀錄。\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"sa\"\u003ef\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;找到 \u003c/span\u003e\u003cspan class=\"si\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003elimit\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e 筆關於 \u0026#39;\u003c/span\u003e\u003cspan class=\"si\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003equery\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#39; 的結果\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cem\u003e註：Type Hints 是強制要求的，因為這是模型理解如何傳參的唯一依據。\u003c/em\u003e\u003c/p\u003e\n\u003ch4 id=\"2-自定義屬性\"\u003e2. 自定義屬性\u003c/h4\u003e\n\u003cp\u003e有時函數名稱不夠直觀，你可以手動覆蓋名稱與描述，以引導模型做出更準確的判斷：\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP3: LangChain - Tools, 賦予 AI 雙手的魔法"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n零、 前言 接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：結構化輸出 (Structured Output)。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。\n一、 從「通靈」到「規格化」：為什麼需要結構化輸出？ 在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。\nLangChain v1.0 透過 create_agent 的 response_format 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 JSON 物件、Pydantic 模型 或 Python Dataclasses。這意味著你的程式碼可以直接存取屬性（如 result.name），而不需要再寫 if \u0026quot;Name:\u0026quot; in response 這種令人崩潰的邏輯。\n二、 雙路徑策略：Provider vs. Tool Calling LangChain 根據模型的能力，自動切換兩種不同的達成策略：\n1. ProviderStrategy (原生支援) 當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。\n優勢： 供應商在 API 層級強制執行 Schema，幻覺率最低。 新特性： 在 langchain\u0026gt;=1.2 中支援 strict 參數，強制模型 100% 遵守 Schema。 自動觸發： 只要模型支援，直接傳入 Pydantic 類別給 response_format 即可。 2. ToolCallingStrategy (工具調用) 對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。\n原理： 告訴模型：「如果你完成了任務，請呼叫這個工具並傳入結果」。 彈性： 支援 Union 類型（例如：Agent 可以根據情況選擇回傳「客戶評論」或「投訴單」）。 三、 多樣化的 Schema 支援 無論你習慣哪種定義資料的方式，LangChain v1.0 幾乎全包了：\n支援類型 描述 適用場景 Pydantic 繼承 BaseModel 需要強類型驗證與複雜 Field 描述時（最推薦）。 Dataclass Python 標準庫 輕量化、不需額外依賴時。 TypedDict 字典型別標記 習慣使用純 Dictionary 操作時。 JSON Schema 純 JSON 結構定義 跨語言或動態生成 Schema 時。 四、 容錯處理：Agent 的「自我修復」機制 這是 ToolStrategy 最強大的地方。當模型生成了錯誤格式的資料時，Agent 不會直接崩潰，而是會啟動 自動重試機制。\n1. 多重輸出錯誤 (Multiple Outputs) 有時候模型太熱心，一次呼叫了兩個工具。Agent 會在 Tool Message 中回覆：\n「錯誤：模型錯誤地回傳了多個結構化回應，請修正你的錯誤。」\n2. Schema 驗證失敗 (Validation Error) 如果模型把評分（1-5 分）填成了 10 分，Agent 會將 Pydantic 的報錯資訊直接回傳給模型，讓模型知道哪裡錯了：\n「1 validation error: Input should be less than or equal to 5 [input_value=10]」\n3. 自定義錯誤策略 (handle_errors) 開發者可以根據需求控制重試行為：\nTrue: 自動重試（預設）。 str: 使用自定義的提示詞命令模型重試。 Callable: 根據 Exception 類型動態決定回傳給模型的指令。 五、 進階技巧：自定義工具訊息內容 在 Agent 的對話歷史中，結構化輸出通常表現為一次 Tool Call。透過 tool_message_content，你可以自定義這條紀錄的顯示方式，讓對話紀錄更具可讀性：\n1 2 3 4 5 # 範例邏輯 ToolStrategy( schema=MeetingAction, tool_message_content=\u0026#34;行動項目已擷取並存入會議記錄中！\u0026#34; ) 這樣在除錯或檢視歷史紀錄時，你看到的不再是冗長的 JSON，而是人類可讀的確認語句。\n六、 技術總結 結構化輸出標誌著 LangChain Agent 從「聊天機器人」轉向「可靠組件」的關鍵轉折。透過 langchain\u0026gt;=1.1 的動態 Profile 讀取機制，系統能自動判別模型的 structured_output 支援度，開發者只需定義好數據模型，剩下的驗證、重試與封裝都由框架處理。\n在 1.5 度的視角下，這不僅是技術更新，更是一種開發規範的建立：讓不確定的 LLM 產出，對接到確定的軟體邏輯中。\n七、 結語 「如果不能轉化為數據，AI 就只能是玩具。」\nStructured Output 將 AI 從一個「會說話的鸚鵡」變成了一個「能產出標準格式數據的組件」。這不僅簡化了後端的 Regex 代碼，更重要的是，它讓 AI 真正具備了與現有軟體世界通訊的能力。\n下次當你發現自己還在寫 if \u0026quot;JSON\u0026quot; in response.content: 時，請記得 LangChain 已經為你準備好了更優雅的工具。\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep2/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"零-前言\"\u003e零、 前言\u003c/h3\u003e\n\u003cp\u003e接續上次關於 LangChain v1.0 架構重構的討論，本篇將深入探討其核心功能之一：\u003cstrong\u003e結構化輸出 (Structured Output)\u003c/strong\u003e。在 Agent 的演進中，如何讓模型不再只是「吐出一段話」，而是「回傳一個物件」，是邁向自動化整合的關鍵一步。\u003c/p\u003e\n\u003ch3 id=\"一-從通靈到規格化為什麼需要結構化輸出\"\u003e一、 從「通靈」到「規格化」：為什麼需要結構化輸出？\u003c/h3\u003e\n\u003cp\u003e在早期的 LLM 開發中，獲取特定資訊（如從一段文字中提取姓名、電話）通常依賴於「提示詞工程 + 正則表達式」。這種方式在模型版本更迭或語氣變化時極其脆弱。\u003c/p\u003e\n\u003cp\u003eLangChain v1.0 透過 \u003ccode\u003ecreate_agent\u003c/code\u003e 的 \u003ccode\u003eresponse_format\u003c/code\u003e 參數，將此流程標準化。現在，Agent 不再回傳模糊的自然語言，而是直接回傳 \u003cstrong\u003eJSON 物件\u003c/strong\u003e、\u003cstrong\u003ePydantic 模型\u003c/strong\u003e 或 \u003cstrong\u003ePython Dataclasses\u003c/strong\u003e。這意味著你的程式碼可以直接存取屬性（如 \u003ccode\u003eresult.name\u003c/code\u003e），而不需要再寫 \u003ccode\u003eif \u0026quot;Name:\u0026quot; in response\u003c/code\u003e 這種令人崩潰的邏輯。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-雙路徑策略provider-vs-tool-calling\"\u003e二、 雙路徑策略：Provider vs. Tool Calling\u003c/h3\u003e\n\u003cp\u003eLangChain 根據模型的能力，自動切換兩種不同的達成策略：\u003c/p\u003e\n\u003ch4 id=\"1-providerstrategy-原生支援\"\u003e1. ProviderStrategy (原生支援)\u003c/h4\u003e\n\u003cp\u003e當你使用的模型提供商（如 OpenAI, Anthropic, Gemini, Grok）原生支持結構化輸出時，這是最可靠的選擇。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e優勢：\u003c/strong\u003e 供應商在 API 層級強制執行 Schema，幻覺率最低。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e新特性：\u003c/strong\u003e 在 \u003ccode\u003elangchain\u0026gt;=1.2\u003c/code\u003e 中支援 \u003ccode\u003estrict\u003c/code\u003e 參數，強制模型 100% 遵守 Schema。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e自動觸發：\u003c/strong\u003e 只要模型支援，直接傳入 Pydantic 類別給 \u003ccode\u003eresponse_format\u003c/code\u003e 即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-toolcallingstrategy-工具調用\"\u003e2. ToolCallingStrategy (工具調用)\u003c/h4\u003e\n\u003cp\u003e對於不支援原生輸出的模型，LangChain 會將「輸出規格」包裝成一個「虛擬工具」。\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP2: LangChain - Structured Output 結構化輸出的藝術"},{"content":" 本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\n一、 核心背景：解決「生產力鴻溝」 LangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：\n依賴臃腫： 解決了過去單體式結構導致的依賴衝突。 API 不穩定： 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。 黑盒子抽象： 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。 文件滯後： 透過架構標準化，大幅改善了開發文件的指導意義。 二、 架構層級的全面重構 v1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：\n1. 新的 Agent 範式：create_agent 底層支撐： 全面改由 LangGraph 驅動，原生支援持久化與人機協作。 中介軟體 (Middleware)： 引入類似 Web 開發的 Hook 機制（如 beforeModel, wrapToolCall）。 情境工程： 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。 2. 標準化通訊結構：.content_blocks 供應商無關： 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。 多模態支援： 為未來視覺與檔案內容的處理提供了標準接口。 類型安全： 提供完整的 Type Hints，減少執行時錯誤。 3. 解耦的生態系統 langchain-core: 穩定的基礎抽象（Runnable 接口）。 langchain-community: 獨立的版本控制，處理第三方整合。 langchain-classic: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。 三、 組合範式的轉移：從 Chains 到 LCEL 這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」：\nLCEL (LangChain Expression Language)： 利用管道運算子 | 組合組件，結構如 prompt | model | parser。 透明度： 鏈條的每一步都清晰可見，不再是隱藏邏輯。 內建優勢： 自動獲得原生串流 (Streaming)、非同步支援 (Async) 以及並行執行能力。 可觀測性： 每一個步驟都會自動記錄到 LangSmith，極大簡化了除錯流程。 四、 完整技術堆疊：三位一體 v1.0 時代的 LangChain 不再只是一個 library，而是一個垂直整合的技術平台：\n層級 組件 角色 應用層 langchain 提供高階入口，快速構建 Agent。 編排層 langgraph 處理複雜的循環邏輯、狀態管理與人機互動。 運營層 langsmith 負責全生命週期的追蹤、評估、監控與部署。 五、 遷移與實踐策略 針對現有專案與未來開發的建議：\n環境要求： 需升級至 Python 3.10+，並注意 Pydantic v2 的兼容性。 遷移路徑： 先安裝 langchain-classic 修正導入語句以維持運行。 逐步將核心邏輯重構為 LCEL 語法，以獲取性能優勢。 開發心態： 簡單任務：使用 create_agent 快速開發。 複雜任務：深入 langgraph 進行精細控制。 品質保障：全程掛載 langsmith 進行觀測。 六、 結語 LangChain v1.0 代表了 AI 應用開發進入了「工程化」階段。透過 解耦架構、宣告式語法 以及 垂直整合的運營工具，它為開發者提供了一個從原型設計到生產部署的可靠路徑。\n","permalink":"https://aura.codex.tw/posts/temp1.5/ep1/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文為個人學習筆記，記錄了學習過程中的一些知識，可參考，但不可認真，學習的過程可能有理解錯誤，資訊不一定正確，畢竟 Temperature 都 1.5 了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"一-核心背景解決生產力鴻溝\"\u003e一、 核心背景：解決「生產力鴻溝」\u003c/h3\u003e\n\u003cp\u003eLangChain 從 v0.3 邁向 v1.0，本質上是從「實驗性工具」轉型為「企業級平台」。過去開發者常遇到的四大痛點在 v1.0 得到了正面回應：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e依賴臃腫：\u003c/strong\u003e 解決了過去單體式結構導致的依賴衝突。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAPI 不穩定：\u003c/strong\u003e 正式採用「語義化版本控制 (Semantic Versioning)」，承諾重大變更僅在主版本發生。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e黑盒子抽象：\u003c/strong\u003e 淘汰了難以除錯的舊版 Chains，轉向透明的宣告式語法。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文件滯後：\u003c/strong\u003e 透過架構標準化，大幅改善了開發文件的指導意義。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"二-架構層級的全面重構\"\u003e二、 架構層級的全面重構\u003c/h3\u003e\n\u003cp\u003ev1.0 重新定義了開發 Agent 的標準流程，主要體現在以下三個面向：\u003c/p\u003e\n\u003ch4 id=\"1-新的-agent-範式create_agent\"\u003e1. 新的 Agent 範式：\u003ccode\u003ecreate_agent\u003c/code\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e底層支撐：\u003c/strong\u003e 全面改由 \u003cstrong\u003eLangGraph\u003c/strong\u003e 驅動，原生支援持久化與人機協作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e中介軟體 (Middleware)：\u003c/strong\u003e 引入類似 Web 開發的 Hook 機制（如 \u003ccode\u003ebeforeModel\u003c/code\u003e, \u003ccode\u003ewrapToolCall\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e情境工程：\u003c/strong\u003e 允許開發者在不破壞核心邏輯的情況下，靈活插入 PII 脫敏或自動摘要等功能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-標準化通訊結構content_blocks\"\u003e2. 標準化通訊結構：\u003ccode\u003e.content_blocks\u003c/code\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e供應商無關：\u003c/strong\u003e 統一了不同模型（OpenAI, Anthropic 等）的輸出格式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多模態支援：\u003c/strong\u003e 為未來視覺與檔案內容的處理提供了標準接口。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e類型安全：\u003c/strong\u003e 提供完整的 Type Hints，減少執行時錯誤。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-解耦的生態系統\"\u003e3. 解耦的生態系統\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elangchain-core\u003c/code\u003e: 穩定的基礎抽象（Runnable 接口）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elangchain-community\u003c/code\u003e: 獨立的版本控制，處理第三方整合。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elangchain-classic\u003c/code\u003e: 專為舊版功能（如 LLMChain）提供的過渡包，確保升級不中斷。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"三-組合範式的轉移從-chains-到-lcel\"\u003e三、 組合範式的轉移：從 Chains 到 LCEL\u003c/h3\u003e\n\u003cp\u003e這是 v1.0 最具影響力的技術變革，將「指令式」轉向「宣告式」：\u003c/p\u003e","title":"【Temperature 1.5 的日常】EP1: LangChain - 認識 LangChain v1.0"},{"content":"1. 程式交易 解題步驟 讀取輸入資料: 讀取股票天數 n、價差 D，以及 n 天的每日價格。 初始化交易狀態: 設定總利潤 ans 為 0。 根據規則 1，在時間點 1 (索引 0) 買進，設定目前持有股票的成本 x 為 a[0]。 設定一個變數 y 來記錄上一次的賣出價格。 我們將使用一個特殊值（例如 -1）來表示 x，代表當下未持有股票。 模擬交易過程: 使用 for 迴圈從第二天 (索引 1) 開始遍歷到第 n 天。 判斷當前狀態 (持有/未持有): 在迴圈中，檢查 x 是否為 -1。 若持有股票 (x != -1): 檢查是否滿足賣出條件 (規則 2)。如果 a[i] \u0026gt;= x + D，則賣出： 將利潤 a[i] - x 加入 ans。 更新狀態為未持有 (設定 x = -1)。 記錄本次賣出價格 y = a[i]。 若未持有股票 (x == -1): 檢查是否滿足買進條件 (規則 3)。如果 a[i] \u0026lt;= y - D，則買進： 更新狀態為持有，並記錄買進成本 x = a[i]。 輸出總利潤: 迴圈結束後，ans 即為總利潤，將其輸出。 分段步驟程式碼 讀取輸入資料 1 2 3 4 5 6 int n, D; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;D; vector\u0026lt;int\u0026gt; a(n,0); for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a[i]; } 這段程式碼讀取 n 和 D，並使用一個 vector 容器 a 來儲存 n 天的股票價格。\n初始化交易狀態 1 int ans=0,x=a[0],y=0; ans：初始化總利潤為 0。 x：代表目前持有股票的買進價格。根據規則 1，我們在第一天就買進，所以 x 初始為 a[0]。在後續邏輯中，x 若被設為 -1 則代表「未持有」股票。 y：代表上一次的賣出價格，用於判斷下一次的買進時機。 模擬交易過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 for(int i=1;i\u0026lt;n;i++){ if(x!=-1){ if(a[i]\u0026gt;=x+D){ ans += a[i] - x; x = -1; y = a[i]; } } else{ if(a[i]\u0026lt;=y-D){ x = a[i]; } } } 這段程式碼是核心的模擬邏輯，從第二天 (索引 i=1) 開始：\nif(x != -1)：檢查是否持有股票。 if(a[i] \u0026gt;= x + D)：(規則 2) 檢查當前價格是否達到賣出門檻。若是，則計算利潤、將狀態改為未持有 (x = -1)、並記錄賣出價格 y。 else：若未持有股票 (x == -1)。 if(a[i] \u0026lt;= y - D)：(規則 3) 檢查當前價格是否達到買進門檻。若是，則買進股票，將 x 設為當前的買進價格 a[i]。 輸出總利潤 1 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 這段程式碼輸出在整個過程中累計的總利潤 ans。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n, D; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;D; vector\u0026lt;int\u0026gt; a(n,0); for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a[i]; } int ans=0,x=a[0],y=0; for(int i=1;i\u0026lt;n;i++){ if(x!=-1){ if(a[i]\u0026gt;=x+D){ ans += a[i] - x; x = -1; y = a[i]; } } else{ if(a[i]\u0026lt;=y-D){ x = a[i]; } } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 2. 贏家預測 解題步驟 讀取輸入: 讀取人數 n 和淘汰敗場數 m。 儲存初始能力: 分別讀取 n 個人的戰力 $S$ 和應變力 $T$，存入兩個 vector\u0026lt;int\u0026gt; S 和 T。 初始化比賽序列: 建立一個 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; info 來儲存當前所有參賽者的資訊。 info 中的每個元素 info[i] 都是一個 vector\u0026lt;int\u0026gt;，包含 4 個值：[戰力, 應變力, 編號, 目前敗場數]。 依照輸入的「初始排列順序」，讀取每個編號 idx，然後從 S 和 T 陣列中 (使用 idx-1 索引) 查找對應的戰力和應變力，連同編號 idx 和初始敗場 0，一起存入 info 向量。 模擬比賽 (主迴圈): 使用一個 while(info.size() != 1) 迴圈，表示只要參賽人數大於 1，比賽就繼續進行。 執行一輪比賽 (Round): 在 while 迴圈內部，建立兩個新的暫存 vector：win (勝利組) 和 lose (失敗組)。 使用 for 迴圈遍歷 info 向量，兩兩一組 (i, i+1) 進行配對競賽。 勝負判斷: 取出 $a, b, c, d$ 四個值。注意：計算 $a \\times b$ 和 $c \\times d$ 時必須使用 long long int 以避免溢位。 更新數值: 根據 $a \\times b \\ge c \\times d$ 的結果，按照題目規則計算勝者和敗者的新戰力與新應變力。 分組: 將更新後的勝者資訊 (敗場數不變) push_back 到 win 向量；將更新後的敗者資訊 (敗場數 +1) push_back 到 lose 向量。 處理奇數人數: 在 for 迴圈結束後，檢查 info.size() 是否為奇數。 如果是奇數，表示最後一個人 (info[info.size()-1]) 烙單，將他不經修改地 push_back 到 win 向量，直接晉級。 重組下一輪名單: 將 info 向量更新為 win 向量 (即 info = win;)。 接著遍歷 lose 向量。 對於 lose 中的每一個人，檢查其敗場數 (lose[i][3])。如果不等於 m (即未達淘汰標準)，則將他 push_back 到 info 向量的尾端。 輸出贏家: 當 while 迴圈結束時，info 向量中只會剩下一個元素 (即最終贏家)。 輸出這位贏家的編號 info[0][2]。 分段步驟程式碼 讀取 N, M 與 S, T 陣列 1 2 3 4 5 6 7 8 9 10 11 int n,m,idx; cin \u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; S(n), T(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; info(n,vector\u0026lt;int\u0026gt;(4,0)); for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; S[i]; } for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; T[i]; } 這段程式碼讀取 n、m，並初始化 S、T 陣列來儲存所有人的初始戰力與應變力。同時初始化 info 向量準備存放參賽者資訊。\n初始化比賽序列 info 1 2 3 4 5 6 7 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; idx; info[i][0]=S[idx-1]; // 根據編號 (idx-1) 填入 S info[i][1]=T[idx-1]; // 根據編號 (idx-1) 填入 T info[i][2]=idx; // 填入原始編號 // info[i][3] (敗場數) 已被初始化為 0 } 這段程式碼讀取初始的排列順序，並依照順序將每個人的 S, T, 編號, 初始敗場(0) 填入 info 向量中。\n模擬比賽主迴圈 1 2 3 4 5 6 7 8 9 10 11 12 while(info.size()!=1){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; win,lose; // (內部迴圈 - 兩兩配對) // ... // (處理奇數人數) // ... // (重組名單) // ... } 這是比賽的主迴圈，只要參賽人數不為 1，就繼續進行新的一輪。每輪開始時，都會建立新的 win 和 lose 暫存向量。\n兩兩配對競賽與更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for(int i=0;i+1\u0026lt;info.size();i+=2){ // 使用 long long 避免 ab 和 cd 相乘溢位 long long int a=info[i][0],b=info[i][1],c=info[i+1][0],d=info[i+1][1]; if(a*b\u0026gt;=c*d){ // info[i] 獲勝 win.push_back ({a+c*d/(2*b),b+c*d/(2*a),info[i][2],info[i][3]}); // info[i+1] 戰敗 lose.push_back({c+c/2,d+d/2,info[i+1][2],info[i+1][3]+1}); }else{ // info[i+1] 獲勝 win.push_back ({c+a*b/(2*d),d+a*b/(2*c),info[i+1][2],info[i+1][3]}); // info[i] 戰敗 lose.push_back({a+a/2,b+b/2,info[i][2],info[i][3]+1}); } } 這段程式碼遍歷當前的 info 列表，兩兩一組 (i, i+1) 進行比賽。根據 $a \\times b$ 和 $c \\times d$ 的比較結果，計算並更新雙方的數值，勝者放入 win，敗者敗場+1 後放入 lose。\n處理烙單與重組名單 1 2 3 4 5 6 7 8 9 10 11 if(info.size()%2==1){ // 奇數人數，最後一人 (info[info.size()-1]) 直接晉級 win.push_back(info[info.size()-1]); } info = win; // 勝利組成為新名單的前半部 for(int i=0;i\u0026lt;lose.size();i++){ if(lose[i][3]!=m){ // 敗場未達 m 的人，接在勝利組後面 info.push_back(lose[i]); } } 這段程式碼首先檢查是否有烙單的人，有則直接加入 win。然後，將 info 更新為 win（勝利組），接著遍歷 lose 列表，將未被淘汰 (敗場 != m) 的人加回 info 的尾端，形成下一輪的比賽名單。\n輸出最終贏家 1 cout\u0026lt;\u0026lt;info[0][2]; 當 while 迴圈結束時，info 向量中只會剩下一個元素，即 info[0]。我們輸出其編號 info[0][2]。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int n,m,idx; cin \u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; S(n), T(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; info(n,vector\u0026lt;int\u0026gt;(4,0)); for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; S[i]; } for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; T[i]; } for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; idx; info[i][0]=S[idx-1]; info[i][1]=T[idx-1]; info[i][2]=idx; } while(info.size()!=1){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; win,lose; for(int i=0;i+1\u0026lt;info.size();i+=2){ long long int a=info[i][0],b=info[i][1],c=info[i+1][0],d=info[i+1][1]; if(a*b\u0026gt;=c*d){ win.push_back ({a+c*d/(2*b),b+c*d/(2*a),info[i][2],info[i][3]}); lose.push_back({c+c/2,d+d/2,info[i+1][2],info[i+1][3]+1}); }else{ win.push_back ({c+a*b/(2*d),d+a*b/(2*c),info[i+1][2],info[i+1][3]}); lose.push_back({a+a/2,b+b/2,info[i][2],info[i][3]+1}); } } if(info.size()%2==1){ win.push_back(info[info.size()-1]); } info = win; for(int i=0;i\u0026lt;lose.size();i++){ if(lose[i][3]!=m){ info.push_back(lose[i]); } } } cout\u0026lt;\u0026lt;info[0][2]; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2022-01/","summary":"\u003ch1 id=\"1-程式交易\"\u003e1. 程式交易\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入資料\u003c/strong\u003e: 讀取股票天數 \u003ccode\u003en\u003c/code\u003e、價差 \u003ccode\u003eD\u003c/code\u003e，以及 \u003ccode\u003en\u003c/code\u003e 天的每日價格。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化交易狀態\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e設定總利潤 \u003ccode\u003eans\u003c/code\u003e 為 0。\u003c/li\u003e\n\u003cli\u003e根據規則 1，在時間點 1 (索引 0) 買進，設定目前持有股票的成本 \u003ccode\u003ex\u003c/code\u003e 為 \u003ccode\u003ea[0]\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e設定一個變數 \u003ccode\u003ey\u003c/code\u003e 來記錄上一次的賣出價格。\u003c/li\u003e\n\u003cli\u003e我們將使用一個特殊值（例如 \u003ccode\u003e-1\u003c/code\u003e）來表示 \u003ccode\u003ex\u003c/code\u003e，代表當下未持有股票。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模擬交易過程\u003c/strong\u003e: 使用 for 迴圈從第二天 (索引 1) 開始遍歷到第 \u003ccode\u003en\u003c/code\u003e 天。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e判斷當前狀態 (持有/未持有)\u003c/strong\u003e: 在迴圈中，檢查 \u003ccode\u003ex\u003c/code\u003e 是否為 \u003ccode\u003e-1\u003c/code\u003e。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e若持有股票 (\u003ccode\u003ex != -1\u003c/code\u003e)\u003c/strong\u003e: 檢查是否滿足\u003cstrong\u003e賣出條件\u003c/strong\u003e (規則 2)。如果 \u003ccode\u003ea[i] \u0026gt;= x + D\u003c/code\u003e，則賣出：\n\u003cul\u003e\n\u003cli\u003e將利潤 \u003ccode\u003ea[i] - x\u003c/code\u003e 加入 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e更新狀態為未持有 (設定 \u003ccode\u003ex = -1\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e記錄本次賣出價格 \u003ccode\u003ey = a[i]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e若未持有股票 (\u003ccode\u003ex == -1\u003c/code\u003e)\u003c/strong\u003e: 檢查是否滿足\u003cstrong\u003e買進條件\u003c/strong\u003e (規則 3)。如果 \u003ccode\u003ea[i] \u0026lt;= y - D\u003c/code\u003e，則買進：\n\u003cul\u003e\n\u003cli\u003e更新狀態為持有，並記錄買進成本 \u003ccode\u003ex = a[i]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出總利潤\u003c/strong\u003e: 迴圈結束後，\u003ccode\u003eans\u003c/code\u003e 即為總利潤，將其輸出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入資料\"\u003e讀取輸入資料\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eD\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eD\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取 \u003ccode\u003en\u003c/code\u003e 和 \u003ccode\u003eD\u003c/code\u003e，並使用一個 \u003ccode\u003evector\u003c/code\u003e 容器 \u003ccode\u003ea\u003c/code\u003e 來儲存 \u003ccode\u003en\u003c/code\u003e 天的股票價格。\u003c/p\u003e","title":"APCS-2022-01"},{"content":"1. 數字遊戲 解題步驟 初始化變數: 宣告一個大小為 9 的整數陣列 cnt 用於計算 1 到 9 每個數字出現的次數，並將其全部初始化為 0。宣告一個整數 max_cnt 用於儲存「出現最多次的次數」，並初始化為 0。 讀取輸入與統計: 使用 for 迴圈執行 3 次。在迴圈中： 讀取一個整數 P。 將 cnt[P-1] 的值加 1（例如，讀到 6，就增加 cnt[5] 的計數）。 檢查 cnt[P-1] 是否大於 max_cnt，如果是，則更新 max_cnt = cnt[P-1]。 輸出最大次數: 迴圈結束後，max_cnt 儲存的就是出現最多次的數字的次數（即 $P$），將其輸出。 輸出不重複數字: 使用 一個 for 迴圈，從 9 遞減到 1 (變數 i 從 9 到 1)。 在迴圈中，檢查 cnt[i-1] 是否大於 0。 如果大於 0，表示數字 i 在輸入中出現過，將 i 輸出。 分段步驟程式碼 初始化變數與計數陣列 1 2 int P, max_cnt = 0; int cnt[9] = {0}; 這段程式碼宣告了用於讀取輸入的變數 P、儲存最大次數的 max_cnt，以及一個大小為 9 的陣列 cnt 來儲存 1~9 的出現次數，並初始化所有值為 0。\n讀取輸入、統計次數並更新最大次數 1 2 3 4 5 6 7 for(int i=0;i\u0026lt;3;i++){ cin \u0026gt;\u0026gt; P; cnt[P-1]++; if(cnt[P-1]\u0026gt;max_cnt){ max_cnt = cnt[P-1]; } } 這段程式碼使用迴圈讀取 3 個數字。每讀到一個數字 P，就對應增加 cnt[P-1] 的計數。同時，它會不斷檢查並更新 max_cnt，以確保 max_cnt 始終儲存當前為止出現過的最大次數。\n輸出最大次數 1 cout \u0026lt;\u0026lt; max_cnt \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 這段程式碼輸出在前面步驟中計算出來的最大次數，即題目要求的 $P$。\n依序輸出不重複數字 1 2 3 4 5 for(int i=9;i\u0026gt;=1;i--){ if(cnt[i-1]\u0026gt;0){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } 這段程式碼從 9 開始反向遍歷到 1。透過檢查 cnt[i-1] 是否大於 0，來判斷數字 i 是否在輸入中出現過。如果出現過，就將其輸出。由於是從 9 向下檢查，因此能確保輸出是「由大到小」的順序。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int P, max_cnt = 0; int cnt[9] = {0}; for(int i=0;i\u0026lt;3;i++){ cin \u0026gt;\u0026gt; P; cnt[P-1]++; if(cnt[P-1]\u0026gt;max_cnt){ max_cnt = cnt[P-1]; } } cout \u0026lt;\u0026lt; max_cnt \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for(int i=9;i\u0026gt;=1;i--){ if(cnt[i-1]\u0026gt;0){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } } 2. 字串解碼 解題步驟 讀取輸入資料: 讀取加密層數 m、字串長度 n。接著使用 vector\u0026lt;string\u0026gt; 儲存 m 個加密鍵 keys，最後讀取經過 m 層加密後的字串 encode。 建立反向解密迴圈: 加密是從第 0 層進行到第 m-1 層。因此，解密必須反向操作，使用一個 for 迴圈從 i = m-1 迭代到 0。 反向解密 - 步驟 2 (重建字串): 在每一層解密中，我們需要反轉加密的步驟 2。 加密是「從 S 的頭/尾取字元，放到 T 的尾端」。 解密就是「從 encode (即 T) 的尾端取字元，根據 key 放回 decode (即 S) 的頭端或尾端」。 我們從 j = n-1 迭代到 0 來反向讀取 key。 如果 key[j] == '1' (加密時從 S 尾端取)，解密時就將 encode.back() 放到 decode 的 尾端。 如果 key[j] == '0' (加密時從 S 前端取)，解密時就將 encode.back() 放到 decode 的 前端。 計算 \u0026lsquo;1\u0026rsquo; 的數量: 在執行步驟 3 的同時，計算當前 key 中 \u0026lsquo;1\u0026rsquo; 的總數 cnt。 反向解密 - 步驟 1 (交換字串): 檢查 cnt 是否為奇數。如果是，代表加密時曾執行過「交換字串」的操作。因此在解密時，我們需要執行 反向 的交換（將後半部移到前面，前半部移到後面）來還原字串。 更新字串狀態: 將當前層解密完成的 decode 字串，賦值回 encode 變數，作為下一層解密迴圈的輸入。 輸出最終結果: 當 m 層迴圈全部解密完畢後，encode 變數中儲存的即為原始字串，將其輸出。 分段步驟程式碼 讀取輸入資料 1 2 3 4 5 6 7 8 int m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; string encode; vector\u0026lt;string\u0026gt; keys(m); for(int i=0;i\u0026lt;m;i++){ cin \u0026gt;\u0026gt; keys[i]; } cin \u0026gt;\u0026gt; encode; 這段程式碼讀取加密層數 m 和字串長度 n，宣告一個 vector\u0026lt;string\u0026gt; 來儲存 m 個加密鍵，並讀取最終的加密字串 encode。\n反向解密迴圈 1 2 3 4 5 6 7 for(int i=m-1;i\u0026gt;=0;i--){ string key = keys[i]; int cnt = 0; string decode = \u0026#34;\u0026#34;; // ... (步驟 2 和 步驟 1 的反向邏輯) ... encode = decode; // 更新 encode 以進行下一層解密 } 這段程式碼建立一個 for 迴圈，從最後一層密鑰 m-1 開始反向迭代到第 0 層。每次迴圈都會處理一層解密，並將解密結果 decode 存回 encode，供上一個解密層使用。\n反向步驟 2 (重建字串) 1 2 3 4 5 6 7 8 9 10 for(int j=n-1;j\u0026gt;=0;j--){ if(key[j]==\u0026#39;1\u0026#39;){ cnt++; decode = decode + encode.back(); encode.pop_back(); }else{ decode = encode.back() + decode; encode.pop_back(); } } 這段程式碼反向執行加密的步驟 2。它從 n-1 開始迭代 key，並從 encode 的尾端 pop_back() 取出字元。根據 key[j] 是 \u0026lsquo;1\u0026rsquo; 還是 \u0026lsquo;0\u0026rsquo;，將取出的字元加到 decode 的尾端或前端，同時計算 \u0026lsquo;1\u0026rsquo; 的數量 cnt。\n反向步驟 1 (交換字串) 1 2 3 4 5 6 7 8 9 10 if(cnt%2==1){ if(n%2==1){ decode = decode.substr((n-1)/2+1,n) + decode[(n-1)/2] + decode.substr(0,(n-1)/2); }else{ decode = decode.substr(n/2,n) + decode.substr(0,n/2); } } 在重建完 decode 字串後，檢查 cnt 是否為奇數。如果是，則執行反向的交換操作，將 decode 的後半段和前半段對調（並正確處理奇數長度的中間字元），以還原加密步驟 1 的交換。\n輸出最終結果 1 cout \u0026lt;\u0026lt; encode; 在所有 m 層迴圈都執行完畢後，encode 變數中儲存的即是完全解密後的原始字串，將其輸出。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; string encode; vector\u0026lt;string\u0026gt; keys(m); for(int i=0;i\u0026lt;m;i++){ cin \u0026gt;\u0026gt; keys[i]; } cin \u0026gt;\u0026gt; encode; for(int i=m-1;i\u0026gt;=0;i--){ string key = keys[i]; int cnt = 0; string decode = \u0026#34;\u0026#34;; for(int j=n-1;j\u0026gt;=0;j--){ if(key[j]==\u0026#39;1\u0026#39;){ cnt++; decode = decode + encode.back(); encode.pop_back(); }else{ decode = encode.back() + decode; encode.pop_back(); } } if(cnt%2==1){ if(n%2==1){ decode = decode.substr((n-1)/2+1,n) + decode[(n-1)/2] + decode.substr(0,(n-1)/2); }else{ decode = decode.substr(n/2,n) + decode.substr(0,n/2); } } encode = decode; } cout \u0026lt;\u0026lt; encode; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2022-06/","summary":"\u003ch1 id=\"1-數字遊戲\"\u003e1. 數字遊戲\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e初始化變數\u003c/strong\u003e: 宣告一個大小為 9 的整數陣列 \u003ccode\u003ecnt\u003c/code\u003e 用於計算 1 到 9 每個數字出現的次數，並將其全部初始化為 0。宣告一個整數 \u003ccode\u003emax_cnt\u003c/code\u003e 用於儲存「出現最多次的次數」，並初始化為 0。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入與統計\u003c/strong\u003e: 使用 for 迴圈執行 3 次。在迴圈中：\n\u003cul\u003e\n\u003cli\u003e讀取一個整數 \u003ccode\u003eP\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e將 \u003ccode\u003ecnt[P-1]\u003c/code\u003e 的值加 1（例如，讀到 6，就增加 \u003ccode\u003ecnt[5]\u003c/code\u003e 的計數）。\u003c/li\u003e\n\u003cli\u003e檢查 \u003ccode\u003ecnt[P-1]\u003c/code\u003e 是否大於 \u003ccode\u003emax_cnt\u003c/code\u003e，如果是，則更新 \u003ccode\u003emax_cnt = cnt[P-1]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出最大次數\u003c/strong\u003e: 迴圈結束後，\u003ccode\u003emax_cnt\u003c/code\u003e 儲存的就是出現最多次的數字的次數（即 $P$），將其輸出。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出不重複數字\u003c/strong\u003e: 使用\n一個 for 迴圈，從 9 遞減到 1 (變數 \u003ccode\u003ei\u003c/code\u003e 從 9 到 1)。\n\u003cul\u003e\n\u003cli\u003e在迴圈中，檢查 \u003ccode\u003ecnt[i-1]\u003c/code\u003e 是否大於 0。\u003c/li\u003e\n\u003cli\u003e如果大於 0，表示數字 \u003ccode\u003ei\u003c/code\u003e 在輸入中出現過，將 \u003ccode\u003ei\u003c/code\u003e 輸出。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"初始化變數與計數陣列\"\u003e初始化變數與計數陣列\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emax_cnt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼宣告了用於讀取輸入的變數 \u003ccode\u003eP\u003c/code\u003e、儲存最大次數的 \u003ccode\u003emax_cnt\u003c/code\u003e，以及一個大小為 9 的陣列 \u003ccode\u003ecnt\u003c/code\u003e 來儲存 1~9 的出現次數，並初始化所有值為 0。\u003c/p\u003e","title":"APCS-2022-06"},{"content":"1. 巴士站牌 解題步驟 讀取輸入並初始化: 讀取站牌總數 n 和第一個巴士站的座標 (px, py)。 初始化最大/最小值: 初始化最大距離 maxn 為 0（或一個極小值），最小距離 minn 為一個極大值（例如 1000，根據題目範圍 400 已經足夠）。 迴圈處理剩餘站牌: 使用 for 迴圈，從 $i=1$ 迭代到 $n-1$，處理剩下的 $n-1$ 個巴士站（即從第 2 個站到第 $n$ 個站）。 讀取並計算距離: 在迴圈中，讀取下一個巴士站的座標 (x, y)。接著計算目前站 (x, y) 與前一個站 (px, py) 之間的曼哈頓距離 d。 更新最大值和最小值: 比較剛算出的距離 d 與 maxn 和 minn。 如果 d 大於 maxn，則更新 maxn = d。 如果 d 小於 minn，則更新 minn = d。 更新前一站位置: 在迴圈結束前，將目前的座標 (x, y) 存為 \u0026ldquo;前一個\u0026rdquo; 座標 (px, py)，供下次迴圈計算距離時使用。 輸出結果: 迴圈結束後，maxn 和 minn 即為所求的最大值和最小值，將它們依序輸出。 分段步驟程式碼 讀取輸入並初始化 1 2 3 4 5 6 7 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n, x, y, px, py, maxn = 0, minn = 1000, d; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; px \u0026gt;\u0026gt; py; 這段程式碼包含了必要的標頭檔和命名空間。在 main 函式中，宣告所有需要的變數。n 是總站數，x 和 y 用於儲存當前讀取的座標，px 和 py 用於儲存前一個站的座標，maxn 和 minn 初始化為 0 和 1000，d 用於儲存距離。接著，讀取總站數 n 以及第一個站的座標 px 和 py。\n迴圈處理、計算距離並更新最大最小值 1 2 3 4 5 6 7 8 9 10 11 12 for(int i=1;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; d = abs(px - x) + abs(py - y); if(maxn \u0026lt; d){ maxn = d; } if(minn \u0026gt; d){ minn = d; } px = x; py = y; } 這段程式碼是解題的核心。for 迴圈會執行 n-1 次，剛好對應 $n$ 個站之間的 $n-1$ 段路程。 在迴圈內部：\n讀取下一個站的座標 x 和 y。 計算前一站 (px, py) 到這一站 (x, y) 的曼哈頓距離 d。 使用 if 判斷式更新 maxn 和 minn。 最後，將 x 和 y 的值賦給 px 和 py，這樣在下一次迴圈時，px 和 py 就代表了 \u0026ldquo;前一個站\u0026rdquo; 的座標。 輸出最終位置 1 2 cout \u0026lt;\u0026lt; maxn \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; minn; } 迴圈結束後，maxn 和 minn 已經儲存了所有相鄰站之間距離的最大值和最小值。這段程式碼將它們用一個空格隔開並輸出，然後結束程式。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n, x, y, px, py, maxn = 0, minn = 1000, d; // 讀取總站數 n 和第一個站的座標 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; px \u0026gt;\u0026gt; py; // 迴圈處理第 2 個到第 n 個站 for(int i=1;i\u0026lt;n;i++){ // 讀取下一個站的座標 cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; // 計算與前一站的曼哈頓距離 d = abs(px - x) + abs(py - y); // 更新最大距離 if(maxn \u0026lt; d){ maxn = d; } // 更新最小距離 if(minn \u0026gt; d){ minn = d; } // 將目前座標設為 \u0026#39;前一個\u0026#39; 座標，供下次迴圈使用 px = x; py = y; } // 輸出最大值和最小值 cout \u0026lt;\u0026lt; maxn \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; minn; } 1. 跳柵遊戲 解題步驟 讀取初始生命值和陷阱條件: 讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。 初始化位置和生命值: 初始化位置 p 為 0，生命值為 k。 模擬遊戲過程: 使用 while 迴圈模擬遊戲過程，直到生命值小於等於 0。 更新位置和生命值: 在每次迴圈中，根據當前生命值更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失。 輸出最終位置: 當生命值小於等於 0 時，輸出當前位置 p。 分段步驟程式碼 讀取初始生命值和陷阱條件 1 2 3 4 int k, x1, x2, y1, y2; cin \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1; cin \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; 這段程式碼讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值 1 int p = 0; 這段程式碼初始化位置 p 為 0。\n模擬遊戲過程 1 2 3 4 5 6 7 8 9 10 11 while(k \u0026gt; 0){ p += k; int dmg = 0; if(p % x1 == 0){ dmg += y1; } if(p % x2 == 0){ dmg += y2; } k -= dmg; } 這段程式碼模擬遊戲過程。在每次迴圈中，根據當前生命值 k 更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失 dmg。然後，更新生命值 k。\n輸出最終位置 1 cout \u0026lt;\u0026lt; p; 這段程式碼輸出最終位置 p。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int k, x1, x2, y1, y2; cin \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1; cin \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int p = 0; while(k\u0026gt;0){ p += k; int dmg = 0; if(p % x1 == 0){ dmg += y1; } if(p % x2 == 0){ dmg += y2; } k -= dmg; } cout \u0026lt;\u0026lt; p; } 2. 運貨站 解題步驟 讀取地圖資訊與初始化: 讀取倉庫的列數 、行數 以及貨物數量 。建立一個二維陣列 arr[R][C+4] 來模擬倉庫。為了方便判斷「推到不能前進為止」，我們在最左側（第 0 欄）預填「障礙物」作為牆壁。 模擬貨物推入: 依序讀取每個貨物的類型 與離頂部距離 。貨物會從倉庫右側進入，並向左滑動直到碰撞到現有的貨物或左側牆壁。 碰撞偵測與放置: 根據不同形狀（A 到 E），定義其佔用的相對座標。 由右向左（i 從 C+1 遞減到 0）檢查貨物的「左邊緣」是否會碰撞到已存在的貨物。 若找到碰撞點，則嘗試將貨物放在碰撞點的右側一格。 檢查邊界（丟棄機制）: 判斷放置後的貨物右邊緣是否超出了倉庫的寬度 。若超出，則該貨物會被丟棄（out++），且不改變倉庫狀態。 統計結果: 模擬結束後，遍歷倉庫陣列，統計數值仍為 0 的空格數量，並輸出空格數與被丟棄的貨物總數。 貨物形狀說明 根據程式碼邏輯，這五種貨物的佔據方式如下：\nA: 垂直長條 (1x4)。 B: 水平長條 (3x1)。 C: 方塊 (2x2)。 D: L 型貨物。 E: 凸型或 T 型貨物。 分段步驟程式碼 初始化倉庫與牆壁 1 2 3 4 5 6 7 8 9 10 11 12 13 int r, c, n, out = 0; cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; int arr[r][c + 4]; // 給予額外空間防止溢位 // 初始化地圖為 0 (空格) for (int i=0; i\u0026lt;r; i++){ for(int j=0; j\u0026lt;c+4; j++) arr[i][j] = 0; } // 在最左側設一道牆，確保貨物向左推時有終點 for(int i=0; i \u0026lt; r; i++){ arr[i][0] = 1; } 模擬貨物 A 的推入 (垂直 1x4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if(t == \u0026#39;A\u0026#39;){ // 從右向左尋找第一個碰撞點 for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y][i] || arr[y+1][i] || arr[y+2][i] || arr[y+3][i]){ // 判斷放完後是否超出倉庫右邊界 c if(i + 1 \u0026lt;= c){ arr[y][i+1] = arr[y+1][i+1] = arr[y+2][i+1] = arr[y+3][i+1] = 1; } else { out++; // 超出範圍，丟棄 } break; } } } 統計空格數量 1 2 3 4 5 6 7 int blank = 0; for (int i = 0; i \u0026lt; r; i++){ for(int j = 1; j \u0026lt;= c; j++){ // 只統計 1 到 c 的範圍 if(arr[i][j] == 0) blank++; } } cout \u0026lt;\u0026lt; blank \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; out; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int r, c, n, out = 0, y; char t; if (!(cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n)) return 0; // 建立倉庫，多開空間避免邊界檢查溢位 int arr[35][60] = {0}; // 設定左側邊界牆壁 for(int i = 0; i \u0026lt; r; i++){ arr[i][0] = 1; } for(int nn = 0; nn \u0026lt; n; nn++){ cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; y; if(t == \u0026#39;A\u0026#39;){ for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y][i] || arr[y+1][i] || arr[y+2][i] || arr[y+3][i]){ if(i + 1 \u0026lt;= c){ arr[y][i+1] = arr[y+1][i+1] = arr[y+2][i+1] = arr[y+3][i+1] = 1; }else{ out++; } break; } } }else if(t == \u0026#39;B\u0026#39;){ for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y][i]){ if(i + 3 \u0026lt;= c){ arr[y][i+1] = arr[y][i+2] = arr[y][i+3] = 1; }else{ out++; } break; } } }else if(t == \u0026#39;C\u0026#39;){ for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y][i] || arr[y+1][i]){ if(i + 2 \u0026lt;= c){ arr[y][i+1] = arr[y][i+2] = arr[y+1][i+1] = arr[y+1][i+2] = 1; }else{ out++; } break; } } }else if(t == \u0026#39;D\u0026#39;){ for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y+1][i] || arr[y][i+2]){ if(i + 3 \u0026lt;= c){ arr[y+1][i+1] = arr[y+1][i+2] = arr[y+1][i+3] = arr[y][i+3] = 1; }else{ out++; } break; } } }else if(t == \u0026#39;E\u0026#39;){ for(int i = c + 1; i \u0026gt;= 0; i--){ if(arr[y][i+1] || arr[y+1][i] || arr[y+2][i]){ if(i + 2 \u0026lt;= c){ arr[y][i+2] = arr[y+1][i+1] = arr[y+1][i+2] = arr[y+2][i+1] = arr[y+2][i+2] = 1; }else{ out++; } break; } } } } int blank = 0; for (int i = 0; i \u0026lt; r; i++){ for(int j = 1; j \u0026lt;= c; j++){ if(arr[i][j] == 0) blank++; } } cout \u0026lt;\u0026lt; blank \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; out \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2022-10/","summary":"\u003ch1 id=\"1-巴士站牌\"\u003e1. 巴士站牌\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入並初始化\u003c/strong\u003e: 讀取站牌總數 \u003ccode\u003en\u003c/code\u003e 和第一個巴士站的座標 (\u003ccode\u003epx\u003c/code\u003e, \u003ccode\u003epy\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化最大/最小值\u003c/strong\u003e: 初始化最大距離 \u003ccode\u003emaxn\u003c/code\u003e 為 0（或一個極小值），最小距離 \u003ccode\u003eminn\u003c/code\u003e 為一個極大值（例如 1000，根據題目範圍 400 已經足夠）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迴圈處理剩餘站牌\u003c/strong\u003e: 使用 \u003ccode\u003efor\u003c/code\u003e 迴圈，從 $i=1$ 迭代到 $n-1$，處理剩下的 $n-1$ 個巴士站（即從第 2 個站到第 $n$ 個站）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e讀取並計算距離\u003c/strong\u003e: 在迴圈中，讀取下一個巴士站的座標 (\u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e)。接著計算目前站 (\u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e) 與前一個站 (\u003ccode\u003epx\u003c/code\u003e, \u003ccode\u003epy\u003c/code\u003e) 之間的曼哈頓距離 \u003ccode\u003ed\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新最大值和最小值\u003c/strong\u003e: 比較剛算出的距離 \u003ccode\u003ed\u003c/code\u003e 與 \u003ccode\u003emaxn\u003c/code\u003e 和 \u003ccode\u003eminn\u003c/code\u003e。\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003ed\u003c/code\u003e 大於 \u003ccode\u003emaxn\u003c/code\u003e，則更新 \u003ccode\u003emaxn = d\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ed\u003c/code\u003e 小於 \u003ccode\u003eminn\u003c/code\u003e，則更新 \u003ccode\u003eminn = d\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新前一站位置\u003c/strong\u003e: 在迴圈結束前，將目前的座標 (\u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e) 存為 \u0026ldquo;前一個\u0026rdquo; 座標 (\u003ccode\u003epx\u003c/code\u003e, \u003ccode\u003epy\u003c/code\u003e)，供下次迴圈計算距離時使用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 迴圈結束後，\u003ccode\u003emaxn\u003c/code\u003e 和 \u003ccode\u003eminn\u003c/code\u003e 即為所求的最大值和最小值，將它們依序輸出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入並初始化\"\u003e讀取輸入並初始化\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;iostream\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epy\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emaxn\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eminn\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1000\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003epx\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003epy\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼包含了必要的標頭檔和命名空間。在 \u003ccode\u003emain\u003c/code\u003e 函式中，宣告所有需要的變數。\u003ccode\u003en\u003c/code\u003e 是總站數，\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ey\u003c/code\u003e 用於儲存當前讀取的座標，\u003ccode\u003epx\u003c/code\u003e 和 \u003ccode\u003epy\u003c/code\u003e 用於儲存前一個站的座標，\u003ccode\u003emaxn\u003c/code\u003e 和 \u003ccode\u003eminn\u003c/code\u003e 初始化為 0 和 1000，\u003ccode\u003ed\u003c/code\u003e 用於儲存距離。接著，讀取總站數 \u003ccode\u003en\u003c/code\u003e 以及第一個站的座標 \u003ccode\u003epx\u003c/code\u003e 和 \u003ccode\u003epy\u003c/code\u003e。\u003c/p\u003e","title":"APCS-2022-10"},{"content":"1. 程式考試 解題步驟 讀取提交次數與初始化變數: 讀取總提交次數 n。初始化 maxScore (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，maxtime (第一次達最高分的時間) 為 0，以及 errors (嚴重錯誤次數) 為 0。 迴圈處理提交紀錄: 使用 for 迴圈，執行 n 次，代表 n 筆提交紀錄。 讀取單筆紀錄並更新狀態: 在迴圈中，每次讀取時間 t 和分數 s。 如果 s 為 -1，表示這是一次嚴重錯誤，將 errors 計數加 1。 否則 (s 不是 -1)，檢查 s 是否嚴格大於目前的 maxScore。 如果是，表示找到了新的最高分，更新 maxScore = s 和 maxtime = t。 如果 s 等於 maxScore，則不執行任何操作，以保留第一次獲得最高分的時間。 計算總分: 迴圈結束後，根據公式 maxScore - n - errors * 2 計算總分 score。 處理負分狀況: 檢查 score 是否小於 0。如果是，則將 score 設為 0 (或直接輸出 0)。 輸出結果: 輸出最終分數 score，接著輸出一個空格，最後輸出 maxtime。 分段步驟程式碼 讀取提交次數與初始化變數 1 2 int n,t,s,maxtime=0,maxScore=-1,errors=0; cin \u0026gt;\u0026gt; n; 這段程式碼讀取總提交次數 n。並初始化四個重要變數：\nt 和 s 用於在迴圈中儲存每次讀取的時間和分數。 maxtime 用於儲存第一次獲得最高分的時間。 maxScore 儲存目前為止的最高分，初始化為 -1，因為 0 是一個有效的最低分。 errors 用於計算嚴重錯誤 (-1) 的次數。 迴圈處理每次提交 1 2 3 4 5 6 7 8 9 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s; if(s == -1){ errors++; }else if(maxScore \u0026lt; s){ maxtime = t; maxScore = s; } } 這段程式碼使用 for 迴圈遍歷 n 筆提交紀錄。\n每次讀入時間 t 和分數 s。 使用 if-else if 結構來判斷： 如果 s == -1，errors 計數器加 1。 否則，如果 s \u0026gt; maxScore ( else if(maxScore \u0026lt; s) )，表示這是一個新的最高分，此時更新 maxScore 和 maxtime。 注意：如果 s == maxScore，這個條件不會觸發，maxtime 不會被更新，這就保證了 maxtime 儲存的是第一次達到最高分的時間。 計算總分並輸出結果 1 2 3 4 5 6 7 int score = maxScore - n - errors * 2; if(score \u0026lt; 0){ cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; }else{ cout \u0026lt;\u0026lt; score; } cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; maxtime; 這段程式碼在迴圈結束後執行。\n首先根據題目公式 最高分 - 總提交次數 - 總嚴重錯誤次數 * 2 計算總分 score。 接著，判斷 score 是否小於 0。如果是，則按題目要求輸出 0；否則輸出計算出的 score。 最後，輸出一個空格和儲存的 maxtime。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n,t,s,maxtime=0,maxScore=-1,errors=0; cin \u0026gt;\u0026gt; n; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s; if(s == -1){ errors++; }else if(maxScore \u0026lt; s){ maxtime = t; maxScore = s; } } int score = maxScore - n - errors * 2; if(score \u0026lt; 0){ cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; }else{ cout \u0026lt;\u0026lt; score; } cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; maxtime; } 2. 造字程式 解題步驟 讀取基本資訊: 讀取字串長度 k、修改次數 q、輸出行數 r，以及初始字串 s。 宣告儲存陣列: 宣告一個 2D 字元陣列 c[q][k]，用來儲存 q 次修改後的所有字串結果。同時宣告一個 1D 陣列 p[k] 用於暫存每次讀取的排列。 模擬 Q 次修改: 使用一個 for 迴圈，從 i = 0 到 q-1，模擬每一次修改操作。 執行單次修改: 在迴圈內部，首先讀取當次的排列 p。 建立一個暫存字串 tmp 並使其等於當前的字串 s（即舊字串）。 再用一個 for 迴圈，根據排列 p 的規則，將 tmp 的字元複製到 s 中對應的位置，產生新字串。 (核心邏輯：s[p[j]-1] = tmp[j]) 儲存結果: 將本次修改產生的新字串 s 存入 2D 陣列 c 的第 i 列 (row) 中。 依格式輸出: 所有修改完成後，使用巢狀迴圈來輸出。 外層迴圈 i 從 0 到 r-1（代表要輸出的第 i 個字元，共 r 行）。 內層迴圈 j 從 0 到 q-1（代表第 j 次修改的結果）。 在內層迴圈中輸出 c[j][i]，即第 j 次修改結果的第 i 個字元。 外層迴圈每跑完一次，就輸出一行換行符。 分段步驟程式碼 讀取基本資訊與宣告陣列 1 2 3 4 5 int k, q, r; string s; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q \u0026gt;\u0026gt; r \u0026gt;\u0026gt; s; int p[k]; char c[q][k]; 這段程式碼讀取 k, q, r 和初始字串 s。並宣告 p 陣列用來儲存每次讀入的排列，c 陣列用來儲存 q 次修改的全部結果。\n模擬修改過程並儲存結果 1 2 3 4 5 6 7 8 9 10 11 12 for(int i=0;i\u0026lt;q;i++){ for(int j=0;j\u0026lt;k;j++){ cin \u0026gt;\u0026gt; p[j]; } string tmp = s; for(int j=0;j\u0026lt;k;j++){ s[p[j]-1] = tmp[j]; } for(int j=0;j\u0026lt;k;j++){ c[i][j] = s[j]; } } 這段程式碼是解題的核心。\n外層迴圈 for(int i=0;i\u0026lt;q;i++) 執行 q 次修改。 cin \u0026gt;\u0026gt; p[j]; 讀取該次的排列。 string tmp = s; 將當前的字串 s (舊字串) 複製到 tmp。 s[p[j]-1] = tmp[j]; 根據排列 p，將 tmp (舊字串) 的第 j 個字元，放到 s (新字串) 的第 p[j]-1 個位置上。 c[i][j] = s[j]; 將剛產生出來的新字串 s，完整複製到 c[i] 這一列，以便後續輸出。 依格式輸出 1 2 3 4 5 6 for(int i=0;i\u0026lt;r;i++){ for(int j=0;j\u0026lt;q;j++){ cout \u0026lt;\u0026lt; c[j][i]; } cout\u0026lt;\u0026lt;endl; } 這段程式碼負責最後的輸出。\n外層迴圈 i 跑 r 次，代表要輸出 r 行。 內層迴圈 j 跑 q 次，代表 q 次修改的結果。 cout \u0026lt;\u0026lt; c[j][i]; 輸出的順序是： 第 1 行 (i=0)：輸出 c[0][0], c[1][0], c[2][0]\u0026hellip; (所有結果的第 1 個字元) 第 2 行 (i=1)：輸出 c[0][1], c[1][1], c[2][1]\u0026hellip; (所有結果的第 2 個字元) \u0026hellip; 第 r 行 (i=r-1)：輸出 c[0][r-1], c[1][r-1], c[2][r-1]\u0026hellip; (所有結果的第 r 個字元) 這恰好符合題目要求的「轉置」輸出格式。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int k, q, r; string s; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q \u0026gt;\u0026gt; r \u0026gt;\u0026gt; s; int p[k]; char c[q][k]; for(int i=0;i\u0026lt;q;i++){ for(int j=0;j\u0026lt;k;j++){ cin \u0026gt;\u0026gt; p[j]; } string tmp = s; for(int j=0;j\u0026lt;k;j++){ s[p[j]-1] = tmp[j]; } for(int j=0;j\u0026lt;k;j++){ c[i][j] = s[j]; } } for(int i=0;i\u0026lt;r;i++){ for(int j=0;j\u0026lt;q;j++){ cout \u0026lt;\u0026lt; c[j][i]; } cout\u0026lt;\u0026lt;endl; } } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2023-01/","summary":"\u003ch1 id=\"1-程式考試\"\u003e1. 程式考試\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取提交次數與初始化變數\u003c/strong\u003e: 讀取總提交次數 \u003ccode\u003en\u003c/code\u003e。初始化 \u003ccode\u003emaxScore\u003c/code\u003e (最高分) 為 -1 (確保任何 0 分以上的成績都能被正確記錄為初始最高分)，\u003ccode\u003emaxtime\u003c/code\u003e (第一次達最高分的時間) 為 0，以及 \u003ccode\u003eerrors\u003c/code\u003e (嚴重錯誤次數) 為 0。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迴圈處理提交紀錄\u003c/strong\u003e: 使用 \u003ccode\u003efor\u003c/code\u003e 迴圈，執行 \u003ccode\u003en\u003c/code\u003e 次，代表 \u003ccode\u003en\u003c/code\u003e 筆提交紀錄。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e讀取單筆紀錄並更新狀態\u003c/strong\u003e: 在迴圈中，每次讀取時間 \u003ccode\u003et\u003c/code\u003e 和分數 \u003ccode\u003es\u003c/code\u003e。\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003es\u003c/code\u003e 為 -1，表示這是一次嚴重錯誤，將 \u003ccode\u003eerrors\u003c/code\u003e 計數加 1。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e否則\u003c/strong\u003e (\u003ccode\u003es\u003c/code\u003e 不是 -1)，檢查 \u003ccode\u003es\u003c/code\u003e 是否\u003cstrong\u003e嚴格大於\u003c/strong\u003e目前的 \u003ccode\u003emaxScore\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果是，表示找到了新的最高分，更新 \u003ccode\u003emaxScore = s\u003c/code\u003e 和 \u003ccode\u003emaxtime = t\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003es\u003c/code\u003e 等於 \u003ccode\u003emaxScore\u003c/code\u003e，則不執行任何操作，以保留\u003cstrong\u003e第一次\u003c/strong\u003e獲得最高分的時間。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e計算總分\u003c/strong\u003e: 迴圈結束後，根據公式 \u003ccode\u003emaxScore - n - errors * 2\u003c/code\u003e 計算總分 \u003ccode\u003escore\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e處理負分狀況\u003c/strong\u003e: 檢查 \u003ccode\u003escore\u003c/code\u003e 是否小於 0。如果是，則將 \u003ccode\u003escore\u003c/code\u003e 設為 0 (或直接輸出 0)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 輸出最終分數 \u003ccode\u003escore\u003c/code\u003e，接著輸出一個空格，最後輸出 \u003ccode\u003emaxtime\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取提交次數與初始化變數\"\u003e讀取提交次數與初始化變數\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003emaxtime\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003emaxScore\u003c/span\u003e\u003cspan class=\"o\"\u003e=-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eerrors\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取總提交次數 \u003ccode\u003en\u003c/code\u003e。並初始化四個重要變數：\u003c/p\u003e","title":"APCS-2023-01"},{"content":"1. 路徑偵測 解題步驟 讀取輸入: 讀取座標點的總數 n。 初始化狀態: 定義 d 來表示目前方向 (1=右, 2=上, 3=左, 4=下)。 根據題目，初始方向為向右，所以 d = 1。 初始化左轉 l、右轉 r、迴轉 re 的計數器為 0。 讀取第一個點的座標 (x, y)，這將作為我們路徑的起始位置。 迴圈處理路徑: 使用 for 迴圈，從 i=1 到 n-1，讀取剩下的 n-1 個點。 讀取下一個點: 在迴圈中，讀取下一個點的座標 (nx, ny)。 判斷轉向: 使用 if-else if 結構，根據目前方向 d 進行判斷。 在 d 的條件下，比較目前座標 (x, y) 和下一個座標 (nx, ny) 的相對位置。 例如：如果 d=1 (目前向右)，而 ny \u0026gt; y (下一個點在上方)，這代表一次左轉。此時 l++ 並更新 d=2 (新方向為上)。 如果 d=1 (目前向右)，而 nx \u0026lt; x (下一個點在左方)，這代表一次迴轉。此時 re++ 並更新 d=3 (新方向為左)。 依此類推，完成所有四個方向的判斷。 更新目前位置: 在判斷完轉向後，將 x = nx 和 y = ny，使下一個點成為新的目前位置，以供下一次迴圈判斷。 輸出結果: 迴圈結束後，輸出 l, r, re 的值。 分段步驟程式碼 初始化狀態並讀取第一個點 1 2 3 int n,x,y,nx,ny,d=1,l=0,r=0,re=0; cin\u0026gt;\u0026gt;n; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; 這段程式碼讀取點的總數 n。初始化目前方向 d=1 (向右)，左轉 l、右轉 r、迴轉 re 計數器為 0。讀取第一個點的座標 x, y，這也確立了我們的初始位置。\n迴圈處理所有轉向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;nx\u0026gt;\u0026gt;ny; if(d==1){ // 目前向右 if(ny \u0026gt; y){ // 向上 (左轉) l++; d=2; }else if(ny \u0026lt; y){ // 向下 (右轉) r++; d=4; }else if(nx \u0026lt; x){ // 向左 (迴轉) re++; d=3; } }else if(d==2){ // 目前向上 if(nx \u0026gt; x){ // 向右 (右轉) r++; d=1; }else if(nx \u0026lt; x){ // 向左 (左轉) l++; d=3; }else if(ny \u0026lt; y){ // 向下 (迴轉) re++; d=4; } }else if(d==3){ // 目前向左 if(ny \u0026gt; y){ // 向上 (右轉) r++; d=2; }else if(ny \u0026lt; y){ // 向下 (左轉) l++; d=4; }else if(nx \u0026gt; x){ // 向右 (迴轉) re++; d=1; } }else if(d==4){ // 目前向下 if(nx \u0026gt; x){ // 向右 (左轉) l++; d=1; }else if(nx \u0026lt; x){ // 向左 (右轉) r++; d=3; }else if(ny \u0026gt; y){ // 向上 (迴轉) re++; d=2; } } x=nx; // 更新目前位置 y=ny; } 這段程式碼是解題的核心。它遍歷 n-1 次，每次讀取下一個點 (nx, ny)。 接著，它檢查目前的方向 d：\nd=1 (向右): 檢查 Y 軸變化（ny \u0026gt; y 左轉, ny \u0026lt; y 右轉）或 X 軸變化（nx \u0026lt; x 迴轉）。 d=2 (向上): 檢查 X 軸變化（nx \u0026gt; x 右轉, nx \u0026lt; x 左轉）或 Y 軸變化（ny \u0026lt; y 迴轉）。 d=3 (向左): 檢查 Y 軸變化（ny \u0026gt; y 右轉, ny \u0026lt; y 左轉）或 X 軸變化（nx \u0026gt; x 迴轉）。 d=4 (向下): 檢查 X 軸變化（nx \u0026gt; x 左轉, nx \u0026lt; x 右轉）或 Y 軸變化（ny \u0026gt; y 迴轉）。 每次偵測到轉向，就增加對應的計數器 (l, r, re) 並更新方向 d。如果沒有轉向（例如 d=1 且 nx \u0026gt; x），則 d 保持不變。 最後，將 x 和 y 更新為 nx 和 ny，為下一次迴圈做準備。\n輸出結果 1 cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;re; 迴圈結束後，l, r, re 已記錄所有轉向次數，將它們依序輸出。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n,x,y,nx,ny,d=1,l=0,r=0,re=0; cin\u0026gt;\u0026gt;n; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;nx\u0026gt;\u0026gt;ny; if(d==1){ if(ny \u0026gt; y){ l++; d=2; }else if(ny \u0026lt; y){ r++; d=4; }else if(nx \u0026lt; x){ re++; d=3; } }else if(d==2){ if(nx \u0026gt; x){ r++; d=1; }else if(nx \u0026lt; x){ l++; d=3; }else if(ny \u0026lt; y){ re++; d=4; } }else if(d==3){ if(ny \u0026gt; y){ r++; d=2; }else if(ny \u0026lt; y){ l++; d=4; }else if(nx \u0026gt; x){ re++; d=1; } }else if(d==4){ if(nx \u0026gt; x){ l++; d=1; }else if(nx \u0026lt; x){ r++; d=3; }else if(ny \u0026gt; y){ re++; d=2; } } x=nx; y=ny; } cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;re; } 2. 特殊位置 解題步驟 讀取矩陣維度和內容: 讀取 $n$、$m$ 以及 $n \\times m$ 矩陣 a 的所有元素。 初始化答案儲存: 宣告一個 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ans 來儲存所有特殊位置的座標。 遍歷所有位置: 使用兩層 for 迴圈，依序檢查矩陣中的每一個位置 (i, j)。 計算範圍內總和: 對於當前位置 (i, j)，令 x = a[i][j]。接著使用兩層 for 迴圈遍歷矩陣中所有位置 (x_pos, y_pos)。 檢查曼哈頓距離: 計算 (i, j) 與 (x_pos, y_pos) 的曼哈頓距離 |i - x_pos| + |j - y_pos|。 累加總和: 如果距離小於等於 x (即 a[i][j])，則將 a[x_pos][y_pos] 加入總和 sum。 檢查特殊位置條件: 對於 (i, j)，計算完 sum 後，檢查 sum % 10 是否等於 x (即 a[i][j])。如果相等，則將 (i, j) 存入 ans 中。 輸出結果: 遍歷結束後，首先輸出 ans 的大小 (即特殊位置的總數)，然後依序（字典序）輸出 ans 中儲存的每一個座標。 分段步驟程式碼 讀取矩陣維度和內容 1 2 3 4 5 6 7 8 int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a[n][m]; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cin \u0026gt;\u0026gt; a[i][j]; } } 這段程式碼讀取矩陣的維度 $n$ 和 $m$，並使用兩層迴圈讀取 $n \\times m$ 個矩陣元素，存儲在 a 陣列中。\n初始化答案儲存 1 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ans; 這段程式碼初始化一個 vector，其元素型別為 pair\u0026lt;int, int\u0026gt;，用來儲存所有找到的特殊位置座標。\n遍歷、計算並檢查特殊位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ int sum = 0; for(int x=0;x\u0026lt;n;x++){ for(int y=0;y\u0026lt;m;y++){ if( (abs(i-x) + abs(j-y)) \u0026lt;= a[i][j]){ sum+=a[x][y]; } } } if(sum%10==a[i][j]){ ans.push_back({i,j}); } } } 這是解題的核心。\n最外層的兩層迴圈 (i, j) 用於遍歷矩陣中的每一個位置。 對於每個 (i, j)，初始化 sum = 0。 內層的兩層迴圈 (x, y) 用於遍歷所有矩陣位置，以計算曼哈頓距離。 if 判斷式檢查 (x, y) 是否在 (i, j) 的曼哈頓距離 a[i][j] 範圍內。 如果在範圍內，將 a[x][y] 累加到 sum。 內層迴圈結束後，檢查 sum % 10 是否等於 a[i][j]。如果成立，表示 (i, j) 是一個特殊位置，將其座標 (i, j) 加入 ans 中。 輸出最終答案 1 2 3 4 cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for(int i=0;i\u0026lt;ans.size();i++){ cout \u0026lt;\u0026lt; ans[i].first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i].second \u0026lt;\u0026lt; endl; } 這段程式碼首先輸出 ans.size()，即特殊位置的總數。接著，使用一個迴圈遍歷 ans，並依序輸出儲存的每個座標。由於 ans 是按照 (i, j) 字典序（先行後列）的順序加入的，因此輸出時自然會符合字典序。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cmath\u0026gt; // 雖然 abs 在 iostream 中常被隱含，但標準 C++ 中 abs(int) 在 \u0026lt;cmath\u0026gt; using namespace std; int main(){ int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a[n][m]; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cin \u0026gt;\u0026gt; a[i][j]; } } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ans; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ int sum = 0; for(int x=0;x\u0026lt;n;x++){ for(int y=0;y\u0026lt;m;y++){ if( (abs(i-x) + abs(j-y)) \u0026lt;= a[i][j]){ sum+=a[x][y]; } } } if(sum%10==a[i][j]){ ans.push_back({i,j}); } } } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for(int i=0;i\u0026lt;ans.size();i++){ cout \u0026lt;\u0026lt; ans[i].first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans[i].second \u0026lt;\u0026lt; endl; } } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2023-06/","summary":"\u003ch1 id=\"1-路徑偵測\"\u003e1. 路徑偵測\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入\u003c/strong\u003e: 讀取座標點的總數 \u003ccode\u003en\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化狀態\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e定義 \u003ccode\u003ed\u003c/code\u003e 來表示目前方向 (1=右, 2=上, 3=左, 4=下)。\u003c/li\u003e\n\u003cli\u003e根據題目，初始方向為向右，所以 \u003ccode\u003ed = 1\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e初始化左轉 \u003ccode\u003el\u003c/code\u003e、右轉 \u003ccode\u003er\u003c/code\u003e、迴轉 \u003ccode\u003ere\u003c/code\u003e 的計數器為 0。\u003c/li\u003e\n\u003cli\u003e讀取第一個點的座標 \u003ccode\u003e(x, y)\u003c/code\u003e，這將作為我們路徑的起始位置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迴圈處理路徑\u003c/strong\u003e: 使用 for 迴圈，從 \u003ccode\u003ei=1\u003c/code\u003e 到 \u003ccode\u003en-1\u003c/code\u003e，讀取剩下的 \u003ccode\u003en-1\u003c/code\u003e 個點。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e讀取下一個點\u003c/strong\u003e: 在迴圈中，讀取下一個點的座標 \u003ccode\u003e(nx, ny)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e判斷轉向\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003eif-else if\u003c/code\u003e 結構，根據\u003cstrong\u003e目前方向 \u003ccode\u003ed\u003c/code\u003e\u003c/strong\u003e 進行判斷。\u003c/li\u003e\n\u003cli\u003e在\n\u003ccode\u003ed\u003c/code\u003e 的條件下，比較目前座標 \u003ccode\u003e(x, y)\u003c/code\u003e 和下一個座標 \u003ccode\u003e(nx, ny)\u003c/code\u003e 的相對位置。\u003c/li\u003e\n\u003cli\u003e例如：如果 \u003ccode\u003ed=1\u003c/code\u003e (目前向右)，而 \u003ccode\u003eny \u0026gt; y\u003c/code\u003e (下一個點在上方)，這代表一次\u003cstrong\u003e左轉\u003c/strong\u003e。此時 \u003ccode\u003el++\u003c/code\u003e 並更新 \u003ccode\u003ed=2\u003c/code\u003e (新方向為上)。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ed=1\u003c/code\u003e (目前向右)，而 \u003ccode\u003enx \u0026lt; x\u003c/code\u003e (下一個點在左方)，這代表一次\u003cstrong\u003e迴轉\u003c/strong\u003e。此時 \u003ccode\u003ere++\u003c/code\u003e 並更新 \u003ccode\u003ed=3\u003c/code\u003e (新方向為左)。\u003c/li\u003e\n\u003cli\u003e依此類推，完成所有四個方向的判斷。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新目前位置\u003c/strong\u003e: 在判斷完轉向後，將 \u003ccode\u003ex = nx\u003c/code\u003e 和 \u003ccode\u003ey = ny\u003c/code\u003e，使下一個點成為新的目前位置，以供下一次迴圈判斷。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 迴圈結束後，輸出 \u003ccode\u003el\u003c/code\u003e, \u003ccode\u003er\u003c/code\u003e, \u003ccode\u003ere\u003c/code\u003e 的值。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"初始化狀態並讀取第一個點\"\u003e初始化狀態並讀取第一個點\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003enx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eny\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ere\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取點的總數 \u003ccode\u003en\u003c/code\u003e。初始化目前方向 \u003ccode\u003ed=1\u003c/code\u003e (向右)，左轉 \u003ccode\u003el\u003c/code\u003e、右轉 \u003ccode\u003er\u003c/code\u003e、迴轉 \u003ccode\u003ere\u003c/code\u003e 計數器為 0。讀取第一個點的座標 \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e，這也確立了我們的初始位置。\u003c/p\u003e","title":"APCS-2023-06"},{"content":"1. 機械鼠 解題步驟 讀取初始位置和食物數量：讀取老鼠的初始位置 x 和食物的總數 n。 初始化變數： min：用來儲存最左邊食物的位置，初始為一個極大值 (例如 101)。 max：用來儲存最右邊食物的位置，初始為一個極小值 (例如 -101)。 step：用來計算老鼠左邊的食物數量，初始為 0。 now：用來暫存當前讀取的食物位置。 遍歷所有食物：使用 for 迴圈讀取 n 個食物的位置。 分類食物位置： 在迴圈中，檢查每個食物的位置 now。 如果 now \u0026lt; x，表示食物在老鼠左邊。將左邊食物計數 step 加 1，並更新 min (如果 now 比當前的 min 更小)。 如果 now \u0026gt; x，表示食物在老鼠右邊。更新 max (如果 now 比當前的 max 更大)。 計算右側食物數量：迴圈結束後，右側食物的數量即為 n - step。 比較並輸出： 比較左側食物數量 step 和右側食物數量 n - step。 如果 step 比較大，表示往左走能吃到更多食物。輸出 step 和最左邊的位置 min。 否則 (右側數量大於或等於左側數量)，表示往右走能吃到更多或相等數量的食物。輸出 n - step 和最右邊的位置 max。 分段步驟程式碼 讀取輸入並初始化變數 1 2 3 int x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; int min = 101, max = -101, step = 0, now; 這段程式碼讀取老鼠的初始位置 x 和食物數量 n。接著初始化四個變數：\nmin 設為 101 (大於最大可能位置 100)，用來找最小值。 max 設為 -101 (小於最小可能位置 -100)，用來找最大值。 step 設為 0，用來計算左側食物的數量。 now 用於在迴圈中儲存當前讀取的食物位置。 遍歷並分類食物 1 2 3 4 5 6 7 8 9 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; now; if(now\u0026lt;x){ step++; if(now\u0026lt;min)min=now; }else{ if(now\u0026gt;max)max=now; } } 這段程式碼使用 for 迴圈讀取 n 個食物的位置。\n如果當前食物位置 now 小於 x，表示食物在老鼠左側。step (左側計數) 加 1，並檢查 now 是否比當前的 min 更小，是的話就更新 min。 否則 (食物在右側)，檢查 now 是否比當前的 max 更大，是的話就更新 max。 比較並輸出結果 1 2 3 4 5 if(step \u0026gt; n - step){ cout \u0026lt;\u0026lt; step \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; min; }else{ cout \u0026lt;\u0026lt; n - step \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; max; } 這段程式碼比較左側食物的數量 step 和右側食物的數量 n - step。\n如果 step (左側) 比較多，就輸出左側的數量 step 和最左側的位置 min。 如果 n - step (右側) 比較多或兩者相等，就輸出右側的數量 n - step 和最右側的位置 max。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int main(){ int x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; int min = 101, max = -101, step = 0, now; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; now; if(now\u0026lt;x){ step++; if(now\u0026lt;min)min=now; }else{ if(now\u0026gt;max)max=now; } } if(step \u0026gt; n - step){ cout \u0026lt;\u0026lt; step \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; min; }else{ cout \u0026lt;\u0026lt; n - step \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; max; } } 2. 卡牌遊戲 解題步驟 讀取表格大小和內容: 讀取 $n$、$m$ 以及 $n \\times m$ 表格的所有數字。 初始化分數: 初始化總分 score = 0。 模擬消除過程: 使用一個 while 迴圈來模擬消除過程。這個迴圈會一直執行，直到某一輪「沒有任何一對牌」被成功消除為止。 標記本輪狀態: 在 while 迴圈的開頭，設定一個布林變數 chk = false，用來追蹤這一輪是否發生了消除。 遍歷尋找配對: 使用兩層 for 迴圈遍歷表格中的每個格子 (i, j)。 如果格子 (i, j) 尚未被消除 (我們用 $\\geq 0$ 的值表示尚未消除)，則開始尋找配對。 檢查垂直方向: 從 (i, j) 向下 (即 r 從 i+1 到 n-1) 檢查同一行 j 上的格子 (r, j)。 如果找到 num[i][j] == num[r][j]，表示找到配對。此時： 將 num[i][j] 的值加入 score。 將 num[i][j] 和 num[r][j] 都設為 -1 (標記為已消除)。 設定 chk = true (表示本輪有成功消除)。 break 停止垂直搜尋。 如果在找到配對前，先遇到一個 num[r][j] \u0026gt;= 0 (即一個尚未消除的 不同 數字)，表示路徑被阻擋，break 停止垂直搜尋。 檢查水平方向: (在檢查水平前，再次檢查 num[i][j] 是否 $\\geq 0$，因為它可能剛好在垂直檢查中被消除了)。 從 (i, j) 向右 (即 r 從 j+1 到 m-1) 檢查同一列 i 上的格子 (i, r)。 套用與垂直檢查相同的邏輯：找到配對就加分、標記為 -1、設 chk = true 並 break；遇到障礙物也 break。 輸出最終分數: 當 while 迴圈結束 (因為 chk 保持為 false) 時，表示所有可消除的配對都已處理完畢，輸出總分 score。 分段步驟程式碼 讀取輸入與初始化 1 2 3 4 5 6 7 8 int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int num[n][m] = {}, score = 0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cin \u0026gt;\u0026gt; num[i][j]; } } 這段程式碼讀取表格的行數 n 和列數 m。接著，宣告一個 $n \\times m$ 的二維陣列 num 來儲存表格內容，並初始化分數 score 為 0。最後，使用巢狀迴圈讀取所有格子的數值。\n模擬消除迴圈 1 2 3 4 5 6 7 8 9 bool chk = true; while(chk){ chk = false; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ // ... 檢查邏輯 ... } } } 這段程式碼是模擬的核心。while(chk) 迴圈會持續執行，只要上一輪 (chk = true) 有成功消除。每輪開始時，先將 chk 重設為 false。接著，使用兩層 for 迴圈遍歷表格中的每一個格子 (i, j)。\n檢查垂直與水平配對 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if(num[i][j] \u0026lt; 0) continue; // 如果 (i, j) 已消除，跳過 // 檢查垂直方向 for(int r=i+1;r\u0026lt;n;r++){ if(num[i][j]==num[r][j]){ // 找到配對 score += num[i][j]; num[i][j] = -1; // 標記為已消除 num[r][j] = -1; // 標記為已消除 chk = true; // 標記本輪有消除 break; // 停止垂直搜尋 } if(num[r][j]\u0026gt;=0){ // 遇到障礙物 break; // 停止垂直搜尋 } } if(num[i][j] \u0026lt; 0) continue; // 再次檢查 (可能被垂直消除了) // 檢查水平方向 for(int r=j+1;r\u0026lt;m;r++){ if(num[i][j]==num[i][r]){ // 找到配對 score += num[i][j]; num[i][j] = -1; // 標記為已消除 num[i][r] = -1; // 標記為已消除 chk = true; // 標記本輪有消除 break; // 停止水平搜尋 } if(num[i][r]\u0026gt;=0){ // 遇到障礙物 break; // 停止水平搜尋 } } 這段程式碼位於 for(j...) 迴圈內部。\n首先檢查 (i, j) 是否已被消除 (值 \u0026lt; 0)，若是則 continue。 垂直檢查: 向下搜尋 (r, j)。如果找到相同的值，則加分、將兩者都設為 -1、將 chk 設為 true，並 break。如果先找到 $\\geq 0$ 的不同值 (障礙物)，也 break。 水平檢查: 再次檢查 (i, j) (因為它可能剛被垂直檢查消除)。如果未被消除，則向右搜尋 (i, r)，執行與垂直檢查相同的邏輯。 輸出最終分數 1 cout \u0026lt;\u0026lt; score; 當 while(chk) 迴圈結束 (即 chk 在一整輪中都保持為 false)，表示沒有更多可以消除的配對。此時，輸出累計的總分 score。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int num[n][m] = {}, score = 0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cin \u0026gt;\u0026gt; num[i][j]; } } bool chk = true; while(chk){ chk = false; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ if(num[i][j] \u0026lt; 0) continue; for(int r=i+1;r\u0026lt;n;r++){ if(num[i][j]==num[r][j]){ score += num[i][j]; num[i][j] = -1; num[r][j] = -1; chk = true; break; } if(num[r][j]\u0026gt;=0){ break; } } if(num[i][j] \u0026lt; 0) continue; for(int r=j+1;r\u0026lt;m;r++){ if(num[i][j]==num[i][r]){ score += num[i][j]; num[i][j] = -1; num[i][r] = -1; chk = true; break; } _ if(num[i][r]\u0026gt;=0){ break; } } } } } cout \u0026lt;\u0026lt; score; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2023-10/","summary":"\u003ch1 id=\"1-機械鼠\"\u003e1. 機械鼠\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取初始位置和食物數量\u003c/strong\u003e：讀取老鼠的初始位置 \u003ccode\u003ex\u003c/code\u003e 和食物的總數 \u003ccode\u003en\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化變數\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emin\u003c/code\u003e：用來儲存最左邊食物的位置，初始為一個極大值 (例如 101)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emax\u003c/code\u003e：用來儲存最右邊食物的位置，初始為一個極小值 (例如 -101)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estep\u003c/code\u003e：用來計算老鼠左邊的食物數量，初始為 0。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enow\u003c/code\u003e：用來暫存當前讀取的食物位置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e遍歷所有食物\u003c/strong\u003e：使用 \u003ccode\u003efor\u003c/code\u003e 迴圈讀取 \u003ccode\u003en\u003c/code\u003e 個食物的位置。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分類食物位置\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e在迴圈中，檢查每個食物的位置 \u003ccode\u003enow\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003enow \u0026lt; x\u003c/code\u003e，表示食物在老鼠左邊。將左邊食物計數 \u003ccode\u003estep\u003c/code\u003e 加 1，並更新 \u003ccode\u003emin\u003c/code\u003e (如果 \u003ccode\u003enow\u003c/code\u003e 比當前的 \u003ccode\u003emin\u003c/code\u003e 更小)。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003enow \u0026gt; x\u003c/code\u003e，表示食物在老鼠右邊。更新 \u003ccode\u003emax\u003c/code\u003e (如果 \u003ccode\u003enow\u003c/code\u003e 比當前的 \u003ccode\u003emax\u003c/code\u003e 更大)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e計算右側食物數量\u003c/strong\u003e：迴圈結束後，右側食物的數量即為 \u003ccode\u003en - step\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e比較並輸出\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e比較左側食物數量 \u003ccode\u003estep\u003c/code\u003e 和右側食物數量 \u003ccode\u003en - step\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003estep\u003c/code\u003e 比較大，表示往左走能吃到更多食物。輸出 \u003ccode\u003estep\u003c/code\u003e 和最左邊的位置 \u003ccode\u003emin\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e否則 (右側數量大於或等於左側數量)，表示往右走能吃到更多或相等數量的食物。輸出 \u003ccode\u003en - step\u003c/code\u003e 和最右邊的位置 \u003ccode\u003emax\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入並初始化變數\"\u003e讀取輸入並初始化變數\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emin\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e101\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emax\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e101\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enow\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取老鼠的初始位置 \u003ccode\u003ex\u003c/code\u003e 和食物數量 \u003ccode\u003en\u003c/code\u003e。接著初始化四個變數：\u003c/p\u003e","title":"APCS-2023-10"},{"content":"1. 遊戲選角 解題步驟 讀取角色數量和資料：讀取角色總數 n。使用迴圈讀取 n 次，每次讀取一個角色的攻擊力 a 和防禦力 d。 儲存資料：使用一個二維 vector (或結構陣列) 來儲存每個角色的攻擊力和防禦力。vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s 中，s[i][0] 儲存第 i 個角色的攻擊力，s[i][1] 儲存防禦力。 定義比較函式：要根據「能力值」（$攻擊力^2 + 防禦力^2$）來排序。我們需要自訂一個比較函式 cmp，它接受兩個角色資料 (例如 vector\u0026lt;int\u0026gt; a 和 vector\u0026lt;int\u0026gt; b)。 實作比較邏輯：在 cmp 函式中，計算 a 的能力值 (a[0]*a[0]+a[1]*a[1]) 和 b 的能力值 (b[0]*b[0]+b[1]*b[1])。為了得到第二大的值，我們需要從大到小 (descending) 排序，所以函式應回傳 a 的能力值是否大於 b 的能力值。 排序：使用 std::sort 函式，搭配自訂的 cmp 比較函式，對儲存所有角色資料的 vector 進行排序。 輸出結果：排序後，vector 中的第 0 個元素 ( s[0] ) 具有最大的能力值。因此，第 1 個元素 ( s[1] ) 具有第二大的能力值。輸出 s[1][0] (攻擊力) 和 s[1][1] (防禦力)。 分段步驟程式碼 包含函式庫與自訂比較函式 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; // 自訂比較函式 // 根據能力值 (a*a + d*d) 由大到小排序 bool cmp(vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b){ return a[0]*a[0]+a[1]*a[1] \u0026gt; b[0]*b[0]+b[1]*b[1]; } 這段程式碼包含了必要的函式庫 (iostream, vector, algorithm)。 並定義了一個比較函式 cmp，用於 sort。它計算兩個輸入 vector (分別代表兩個角色) 的能力值平方和，並回傳第一個是否大於第二個，以實現降冪排序。\n讀取輸入並儲存 1 2 3 4 5 6 7 8 9 int main(){ int n; cin \u0026gt;\u0026gt; n ; // 宣告一個 n x 2 的二維 vector 來儲存 n 個角色的攻擊力和防禦力 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s(n,vector\u0026lt;int\u0026gt;(2)); for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; s[i][0] \u0026gt;\u0026gt; s[i][1]; } // ... 在 main 函式中，首先讀取角色數量 n。然後，宣告一個名為 s 的二維 vector，它有 n 列，每列有 2 個元素。接著，使用迴圈讀取 n 行輸入，將攻擊力和防禦力分別存入 s[i][0] 和 s[i][1]。\n排序與輸出 1 2 3 4 5 6 7 8 // ... // 使用 std::sort 並傳入自訂的 cmp 函式來排序 sort(s.begin(),s.end(),cmp); // 排序後，s[0] 是能力值最大的，s[1] 是第二大的 // 輸出 s[1] 的攻擊力和防禦力 cout \u0026lt;\u0026lt; s[1][0] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s[1][1]; } 這段程式碼呼叫 std::sort，對 s 向量從頭到尾 (s.begin() 到 s.end()) 進行排序，並使用 cmp 函式作為排序的標準。 排序完成後，s[1] 中儲存的就是能力值第二大的角色資料。最後，輸出 s[1][0] (攻擊力) 和 s[1][1] (防禦力)，並以空格分隔。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; // 自訂比較函式 // 比較兩個角色 (a, b) 的能力值 // 能力值 = 攻擊力^2 + 防禦力^2 // 回傳 true 表示 a 應該排在 b 前面 (降冪排序) bool cmp(vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b){ return a[0]*a[0]+a[1]*a[1] \u0026gt; b[0]*b[0]+b[1]*b[1]; } int main(){ int n; cin \u0026gt;\u0026gt; n ; // 讀取角色數量 // 宣告 n x 2 的二維 vector 儲存資料 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s(n,vector\u0026lt;int\u0026gt;(2)); // 迴圈讀取 n 個角色的攻擊力 (s[i][0]) 和防禦力 (s[i][1]) for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; s[i][0] \u0026gt;\u0026gt; s[i][1]; } // 使用 std::sort 和自訂的 cmp 函式對角色 // 根據能力值進行降冪排序 sort(s.begin(),s.end(),cmp); // 排序後，s[0] 是第一名，s[1] 是第二名 // 輸出第二名角色的攻擊力和防禦力 cout \u0026lt;\u0026lt; s[1][0] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s[1][1]; } 2. 蜜蜂觀察 解題步驟 讀取輸入: 讀取蜂巢大小 $m$、$n$ 以及總步數 $k$。 儲存蜂巢地圖: 建立一個 $m \\times n$ 的二維資料結構（例如 vector\u0026lt;string\u0026gt;），並讀取 $m$ 行字串來儲存蜂巢上每個格子的字母。 初始化狀態: 設定 Bob 的起始位置 (x, y) 在左下角，即 (m-1, 0)。 建立一個大小為 52 的整數陣列 abc 並全部初始化為 0，用來分別統計 26 個大寫字母和 26 個小寫字母出現的次數。 模擬移動過程: 使用一個 for 迴圈執行 $k$ 次，代表 Bob 的 $k$ 步移動。 在迴圈中，首先讀取該步驟的移動方向 step。 檢查邊界並移動: 根據 step 的值 (0-5)，判斷移動後的 新位置是否會超出蜂巢邊界（撞牆）。 如果不會超出邊界，則更新 x 和 y 座標。 如果會超出邊界，x 和 y 座標保持不變（停在原地）。 記錄路徑與字元: 輸出當前位置 (x, y) 上的字元 comb[x][y]。 將 abc 陣列中對應的字元計數加 1。需區分大小寫，例如 \u0026lsquo;A\u0026rsquo;-\u0026lsquo;Z\u0026rsquo; 對應 0-25，\u0026lsquo;a\u0026rsquo;-\u0026lsquo;z\u0026rsquo; 對應 26-51。 計算並輸出字元種類數: 迴圈結束後，宣告一個變數 diff 來計算種類數。 遍歷 abc 陣列 (0 到 51)，如果 abc[i] \u0026gt; 0（表示該字元至少出現過一次），則將 diff 加 1。 最後，換行並輸出 diff 的值。 分段步驟程式碼 讀取輸入與儲存蜂巢地圖 1 2 3 4 5 6 int m,n,k; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;string\u0026gt; comb(m); for(int i=0;i\u0026lt;m;i++){ cin \u0026gt;\u0026gt; comb[i]; } 這段程式碼讀取蜂巢大小 $m$、$n$ 和步數 $k$。然後使用 vector\u0026lt;string\u0026gt; 讀取並儲存 $m \\times n$ 的蜂巢地圖。\n初始化狀態 1 2 int x=m-1,y=0, step; int abc[52] = {}; 這段程式碼初始化 Bob 的起始位置 x=m-1、y=0（左下角）。並初始化一個大小為 52 的計數陣列 abc 為全 0，用來統計 52 種（大小寫相異）字母的出現次數。\n模擬移動過程 (迴圈與移動邏輯) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 for(int i=0;i\u0026lt;k;i++){ cin \u0026gt;\u0026gt; step; if(step==0){ if(x-1\u0026gt;=0){ // 往上 (Up) x--; } } else if(step==1){ if(y+1\u0026lt;n){ // 往右 (Right) y++; } } else if(step==2){ if(x+1\u0026lt;m \u0026amp;\u0026amp; y+1\u0026lt;n){ // 往右下 (Down-Right) x++; y++; } } else if(step==3){ if(x+1\u0026lt;m){ // 往下 (Down) x++; } } else if(step==4){ if(y-1\u0026gt;=0){ // 往左 (Left) y--; } } else if(step==5){ if(x-1\u0026gt;=0 \u0026amp;\u0026amp; y-1\u0026gt;=0){ // 往左上 (Up-Left) x--; y--; } } // ... (記錄路徑與字元) 這段程式碼是 k 步移動的主迴圈。\n讀取每一步的方向 step。 使用 if-else if 結構判斷 6 種方向。 在更新座標 x 和 y 之前，先檢查新位置是否仍在 $m \\times n$ 的範圍內。如果超出範圍（撞牆），則不更新座標，Bob 停在原地。 記錄路徑與字元 (在迴圈內) 1 2 3 4 5 6 7 cout \u0026lt;\u0026lt; comb[x][y]; if (comb[x][y] \u0026gt;= \u0026#39;a\u0026#39;){ abc[comb[x][y]-\u0026#39;a\u0026#39;+26]++; }else{ abc[comb[x][y]-\u0026#39;A\u0026#39;]++; } } // for 迴圈結束 這段程式碼在 for 迴圈內，緊接在移動邏輯之後。\ncout \u0026lt;\u0026lt; comb[x][y]; 輸出當前（移動後或停在原地）位置的字元，累加成路徑字串。 if-else 判斷當前字元是小寫還大寫： 大寫：\u0026lsquo;A\u0026rsquo; 對應 abc[0]，\u0026lsquo;B\u0026rsquo; 對應 abc[1] \u0026hellip; 小寫：\u0026lsquo;a\u0026rsquo; 對應 abc[26]，\u0026lsquo;b\u0026rsquo; 對應 abc[27] \u0026hellip; 並將對應的計數器加 1。 計算並輸出字元種類數 1 2 3 4 5 int diff = 0; for(int i=0;i\u0026lt;52;i++){ diff += abc[i]\u0026gt;0 ; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;diff; 這段程式碼在 for 迴圈結束後執行。\n初始化種類數 diff 為 0。 遍歷 abc 陣列，abc[i] \u0026gt; 0 這個布林表達式在 C++ 中會被轉為 1 (true) 或 0 (false)。 因此，diff 只會累加那些至少出現過一次 (計數 \u0026gt; 0) 的字元種類。 最後，cout \u0026lt;\u0026lt; endl; 換行，並輸出總種類數 diff。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ int m,n,k; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;string\u0026gt; comb(m); for(int i=0;i\u0026lt;m;i++){ cin \u0026gt;\u0026gt; comb[i]; } int x=m-1,y=0, step; int abc[52] = {}; for(int i=0;i\u0026lt;k;i++){ cin \u0026gt;\u0026gt; step; if(step==0){ if(x-1\u0026gt;=0){ x--; } } else if(step==1){ if(y+1\u0026lt;n){ y++; } } else if(step==2){ if(x+1\u0026lt;m \u0026amp;\u0026amp; y+1\u0026lt;n){ x++; y++; } } else if(step==3){ if(x+1\u0026lt;m){ x++; } } else if(step==4){ if(y-1\u0026gt;=0){ y--; } } else if(step==5){ if(x-1\u0026gt;=0 \u0026amp;\u0026amp; y-1\u0026gt;=0){ x--; y--; } } cout \u0026lt;\u0026lt; comb[x][y]; if (comb[x][y] \u0026gt;= \u0026#39;a\u0026#39;){ abc[comb[x][y]-\u0026#39;a\u0026#39;+26]++; }else{ abc[comb[x][y]-\u0026#39;A\u0026#39;]++; } } int diff = 0; for(int i=0;i\u0026lt;52;i++){ diff += abc[i]\u0026gt;0 ; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;diff; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2024-01/","summary":"\u003ch1 id=\"1-遊戲選角\"\u003e1. 遊戲選角\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取角色數量和資料\u003c/strong\u003e：讀取角色總數 \u003ccode\u003en\u003c/code\u003e。使用迴圈讀取 \u003ccode\u003en\u003c/code\u003e 次，每次讀取一個角色的攻擊力 \u003ccode\u003ea\u003c/code\u003e 和防禦力 \u003ccode\u003ed\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e儲存資料\u003c/strong\u003e：使用一個二維 \u003ccode\u003evector\u003c/code\u003e (或結構陣列) 來儲存每個角色的攻擊力和防禦力。\u003ccode\u003evector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s\u003c/code\u003e 中，\u003ccode\u003es[i][0]\u003c/code\u003e 儲存第 \u003ccode\u003ei\u003c/code\u003e 個角色的攻擊力，\u003ccode\u003es[i][1]\u003c/code\u003e 儲存防禦力。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e定義比較函式\u003c/strong\u003e：要根據「能力值」（$攻擊力^2 + 防禦力^2$）來排序。我們需要自訂一個比較函式 \u003ccode\u003ecmp\u003c/code\u003e，它接受兩個角色資料 (例如 \u003ccode\u003evector\u0026lt;int\u0026gt; a\u003c/code\u003e 和 \u003ccode\u003evector\u0026lt;int\u0026gt; b\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e實作比較邏輯\u003c/strong\u003e：在 \u003ccode\u003ecmp\u003c/code\u003e 函式中，計算 \u003ccode\u003ea\u003c/code\u003e 的能力值 (\u003ccode\u003ea[0]*a[0]+a[1]*a[1]\u003c/code\u003e) 和 \u003ccode\u003eb\u003c/code\u003e 的能力值 (\u003ccode\u003eb[0]*b[0]+b[1]*b[1]\u003c/code\u003e)。為了得到\u003cstrong\u003e第二大\u003c/strong\u003e的值，我們需要從大到小 (descending) 排序，所以函式應回傳 \u003ccode\u003ea\u003c/code\u003e 的能力值是否\u003cstrong\u003e大於\u003c/strong\u003e \u003ccode\u003eb\u003c/code\u003e 的能力值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e排序\u003c/strong\u003e：使用 \u003ccode\u003estd::sort\u003c/code\u003e 函式，搭配自訂的 \u003ccode\u003ecmp\u003c/code\u003e 比較函式，對儲存所有角色資料的 \u003ccode\u003evector\u003c/code\u003e 進行排序。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e：排序後，\u003ccode\u003evector\u003c/code\u003e 中的第 0 個元素 ( \u003ccode\u003es[0]\u003c/code\u003e ) 具有最大的能力值。因此，第 1 個元素 ( \u003ccode\u003es[1]\u003c/code\u003e ) 具有\u003cstrong\u003e第二大\u003c/strong\u003e的能力值。輸出 \u003ccode\u003es[1][0]\u003c/code\u003e (攻擊力) 和 \u003ccode\u003es[1][1]\u003c/code\u003e (防禦力)。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"包含函式庫與自訂比較函式\"\u003e包含函式庫與自訂比較函式\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;iostream\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;vector\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;algorithm\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 自訂比較函式\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 根據能力值 (a*a + d*d) 由大到小排序\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003ecmp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼包含了必要的函式庫 (\u003ccode\u003eiostream\u003c/code\u003e, \u003ccode\u003evector\u003c/code\u003e, \u003ccode\u003ealgorithm\u003c/code\u003e)。\n並定義了一個比較函式 \u003ccode\u003ecmp\u003c/code\u003e，用於 \u003ccode\u003esort\u003c/code\u003e。它計算兩個輸入 \u003ccode\u003evector\u003c/code\u003e (分別代表兩個角色) 的能力值平方和，並回傳第一個是否大於第二個，以實現降冪排序。\u003c/p\u003e","title":"APCS-2024-01"},{"content":"1. 跳柵遊戲 解題步驟 讀取初始生命值和陷阱條件: 讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。 初始化位置和生命值: 初始化位置 p 為 0，生命值為 k。 模擬遊戲過程: 使用 while 迴圈模擬遊戲過程，直到生命值小於等於 0。 更新位置和生命值: 在每次迴圈中，根據當前生命值更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失。 輸出最終位置: 當生命值小於等於 0 時，輸出當前位置 p。 分段步驟程式碼 讀取初始生命值和陷阱條件 1 2 3 4 int k, x1, x2, y1, y2; cin \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1; cin \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; 這段程式碼讀取初始生命值 k，以及兩個陷阱的條件 x1、y1 和 x2、y2。\n初始化位置和生命值 1 int p = 0; 這段程式碼初始化位置 p 為 0。\n模擬遊戲過程 1 2 3 4 5 6 7 8 9 10 11 while(k \u0026gt; 0){ p += k; int dmg = 0; if(p % x1 == 0){ dmg += y1; } if(p % x2 == 0){ dmg += y2; } k -= dmg; } 這段程式碼模擬遊戲過程。在每次迴圈中，根據當前生命值 k 更新位置 p，並根據 p 是否為 x1 或 x2 的倍數計算生命值的損失 dmg。然後，更新生命值 k。\n輸出最終位置 1 cout \u0026lt;\u0026lt; p; 這段程式碼輸出最終位置 p。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int k, x1, x2, y1, y2; cin \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1; cin \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int p = 0; while(k\u0026gt;0){ p += k; int dmg = 0; if(p % x1 == 0){ dmg += y1; } if(p % x2 == 0){ dmg += y2; } k -= dmg; } cout \u0026lt;\u0026lt; p; } 2. 轉盤得分 解題步驟 讀取輸入: 讀取輪盤數量 m、每個輪盤的字元數量 n、以及遊戲回合數 k。接著讀取 m 個輪盤的初始狀態（字串）。 模擬遊戲過程: 對於每個遊戲回合，讀取每個輪盤的轉動距離，並根據轉動距離更新輪盤的狀態。 計算每回合的分數: 對於每個回合，統計每個位置上出現次數最多的字元，將其出現次數累加到該回合的分數中。 累加總分: 將每個回合的分數累加到總分中。 輸出總分: 最終輸出遊戲的總分。 分段步驟程式碼 讀取輸入 1 2 3 4 5 6 int m, n, k; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;string\u0026gt; wheel(m); for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; wheel[i]; } 這段程式碼讀取輸入的 m、n、k，並使用 vector\u0026lt;string\u0026gt; 儲存 m 個輪盤的初始狀態。\n模擬遊戲過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 for (int loop = 0; loop \u0026lt; k; loop++) { for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; rotate; rotate %= n; if (rotate \u0026lt; 0) rotate += n; string rotated_wheel = \u0026#34;\u0026#34;; for (int j = n - rotate; j \u0026lt; n; j++) { rotated_wheel += wheel[i][j]; } for (int j = 0; j \u0026lt; n - rotate; j++) { rotated_wheel += wheel[i][j]; } wheel[i] = rotated_wheel; } } 這段程式碼模擬每個遊戲回合的過程。對於每個輪盤，讀取轉動距離 rotate，並將其對 n 取模以確保轉動距離在 [0, n) 範圍內。如果 rotate 為負數，則加上 n 以轉換為等效的正轉動距離。接著，根據 rotate 更新輪盤的狀態。\n計算每回合的分數 1 2 3 4 5 6 7 8 9 10 11 12 int score = 0; for (int i = 0; i \u0026lt; n; i++) { int count[26] = {0}; for (int j = 0; j \u0026lt; m; j++) { count[wheel[j][i] - \u0026#39;a\u0026#39;]++; } int max_count = 0; for (int j = 0; j \u0026lt; 26; j++) { if (count[j] \u0026gt; max_count) max_count = count[j]; } score += max_count; } 這段程式碼計算每個回合的分數。對於每個位置 i，統計 m 個輪盤對應位置的字元出現次數，並找出出現次數最多的字元 max_count。將 max_count 累加到 score 中。\n累加總分與輸出 1 2 total_score += score; cout \u0026lt;\u0026lt; total_score; 這段程式碼將每個回合的分數 score 累加到總分 total_score 中，並最終輸出 total_score。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { // 讀取輸入 int m, n, k; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;string\u0026gt; wheel(m); for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; wheel[i]; } int rotate; int total_score = 0; // 模擬遊戲過程 for (int loop = 0; loop \u0026lt; k; loop++) { for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; rotate; // 計算等效轉動距離 rotate %= n; if (rotate \u0026lt; 0) rotate += n; string rotated_wheel = \u0026#34;\u0026#34;; // 更新輪盤狀態 for (int j = n - rotate; j \u0026lt; n; j++) { rotated_wheel += wheel[i][j]; } for (int j = 0; j \u0026lt; n - rotate; j++) { rotated_wheel += wheel[i][j]; } wheel[i] = rotated_wheel; } // 計算每回合的分數 int score = 0; for (int i = 0; i \u0026lt; n; i++) { int count[26] = {0}; // 統計字元出現次數 for (int j = 0; j \u0026lt; m; j++) { count[wheel[j][i] - \u0026#39;a\u0026#39;]++; } int max_count = 0; // 找出出現次數最多的字元 for (int j = 0; j \u0026lt; 26; j++) { if (count[j] \u0026gt; max_count) max_count = count[j]; } score += max_count; } // 累加總分 total_score += score; // cout\u0026lt;\u0026lt;score\u0026lt;\u0026lt;endl; // 可用於 debug } // 輸出總分 cout \u0026lt;\u0026lt; total_score; return 0; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2025-06/","summary":"\u003ch1 id=\"1-跳柵遊戲\"\u003e1. 跳柵遊戲\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取初始生命值和陷阱條件\u003c/strong\u003e: 讀取初始生命值 \u003ccode\u003ek\u003c/code\u003e，以及兩個陷阱的條件 \u003ccode\u003ex1\u003c/code\u003e、\u003ccode\u003ey1\u003c/code\u003e 和 \u003ccode\u003ex2\u003c/code\u003e、\u003ccode\u003ey2\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化位置和生命值\u003c/strong\u003e: 初始化位置 \u003ccode\u003ep\u003c/code\u003e 為 0，生命值為 \u003ccode\u003ek\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模擬遊戲過程\u003c/strong\u003e: 使用 while 迴圈模擬遊戲過程，直到生命值小於等於 0。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新位置和生命值\u003c/strong\u003e: 在每次迴圈中，根據當前生命值更新位置 \u003ccode\u003ep\u003c/code\u003e，並根據 \u003ccode\u003ep\u003c/code\u003e 是否為 \u003ccode\u003ex1\u003c/code\u003e 或 \u003ccode\u003ex2\u003c/code\u003e 的倍數計算生命值的損失。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出最終位置\u003c/strong\u003e: 當生命值小於等於 0 時，輸出當前位置 \u003ccode\u003ep\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取初始生命值和陷阱條件\"\u003e讀取初始生命值和陷阱條件\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ey1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ey2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取初始生命值 \u003ccode\u003ek\u003c/code\u003e，以及兩個陷阱的條件 \u003ccode\u003ex1\u003c/code\u003e、\u003ccode\u003ey1\u003c/code\u003e 和 \u003ccode\u003ex2\u003c/code\u003e、\u003ccode\u003ey2\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"初始化位置和生命值\"\u003e初始化位置和生命值\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼初始化位置 \u003ccode\u003ep\u003c/code\u003e 為 0。\u003c/p\u003e\n\u003ch3 id=\"模擬遊戲過程\"\u003e模擬遊戲過程\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003edmg\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003ex1\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003edmg\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ey1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003ex2\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003edmg\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ey2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"n\"\u003edmg\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼模擬遊戲過程。在每次迴圈中，根據當前生命值 \u003ccode\u003ek\u003c/code\u003e 更新位置 \u003ccode\u003ep\u003c/code\u003e，並根據 \u003ccode\u003ep\u003c/code\u003e 是否為 \u003ccode\u003ex1\u003c/code\u003e 或 \u003ccode\u003ex2\u003c/code\u003e 的倍數計算生命值的損失 \u003ccode\u003edmg\u003c/code\u003e。然後，更新生命值 \u003ccode\u003ek\u003c/code\u003e。\u003c/p\u003e","title":"APCS-2025-06"},{"content":"1. 特技表演 解題步驟 讀取輸入資料: 讀取大樓的總數 n，接著使用一個 for 迴圈讀取 n 棟大樓分別的高度，並將它們儲存在一個陣列 h 中。 初始化變數: 初始化兩個整數變數。max_d 用來儲存找到的「最長」滑翔路徑長度，初始為 0。d 用來儲存「當前」正在計算的連續滑翔路徑長度，初始為 1（因為任何一棟大樓本身都構成長度為 1 的路徑）。 遍歷大樓陣列: 使用 for 迴圈從第一棟大樓 (i = 0) 檢查到倒數第二棟大樓 (i \u0026lt; n-1)。 判斷路徑是否延伸: 在迴圈中，比較目前大樓 h[i] 和下一棟大樓 h[i+1] 的高度。 如果 h[i] \u0026gt; h[i+1]，表示符合「越來越低」的條件，滑翔路徑可以繼續，因此將當前路徑長度 d 增加 1 (d++)。 如果 h[i] \u0026lt;= h[i+1]，表示路徑中斷（高度沒有變低），因此重置當前路徑長度 d 為 1（從 h[i+1] 重新開始計算）。 更新最長路徑: 在每次判斷（或重置）d 之後，都要檢查 d 是否大於 max_d。如果 d 更大，就更新 max_d = d。 輸出結果: 迴圈結束後，max_d 中儲存的就是整個過程中最長的路徑長度，將其輸出。 分段步驟程式碼 讀取輸入資料 1 2 3 4 5 6 int n; cin \u0026gt;\u0026gt; n; int h[n]; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; h[i]; } 這段程式碼首先讀取大樓的數量 n，然後宣告一個大小為 n 的陣列 h，並使用迴圈讀取每棟大樓的高度。\n初始化變數 1 int max_d = 0, d=1; 這段程式碼初始化 max_d 為 0（最終的最長路徑）和 d 為 1（當前計算的路徑）。\n遍歷、比較並更新最長路徑 1 2 3 4 5 6 7 8 9 10 11 12 for(int i=0;i\u0026lt;n-1;i++){ if(h[i]\u0026gt;h[i+1]){ d++; } else{ d = 1; } if(d\u0026gt;max_d){ max_d = d; } } 這段程式碼是解題的核心。它遍歷 n-1 次（比較 h[0] 和 h[1]、h[1] 和 h[2]\u0026hellip;）。\n如果 h[i] \u0026gt; h[i+1]，當前路徑 d 增加。 否則，路徑中斷，d 重置為 1。 每一次迴圈都會檢查 d 是否是新的最大值 max_d。 輸出結果 1 cout \u0026lt;\u0026lt; max_d; 這段程式碼在所有比較完成後，輸出儲存的最長路徑 max_d。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n; cin \u0026gt;\u0026gt; n; int h[n]; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; h[i]; } int max_d = 0, d=1; for(int i=0;i\u0026lt;n-1;i++){ if(h[i]\u0026gt;h[i+1]){ d++; } else{ d = 1; } if(d\u0026gt;max_d){ max_d = d; } } cout \u0026lt;\u0026lt; max_d; } 2. 電子畫布 解題步驟 引入函式庫與宣告: 引入 iostream (用於輸入輸出) 和 vector (用於建立二維畫布)。 宣告輔助函式: 宣告一個計算曼哈頓距離的函式 m_dis 的原型。 讀取基本資訊: 在 main 函式中，讀取畫布高度 h、寬度 w 和操作次數 n。 初始化畫布: 使用 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; 建立一個 h x w 的二維向量 board，並將所有初始值設為 0。 模擬操作: 使用一個 for 迴圈執行 n 次： 讀取該次操作的座標 (r, c)、範圍 t 和顏色值 x。 使用 巢狀迴圈 遍歷畫布上的 每一個 座標 (hh, ww) (從 0 到 h-1，0 到 w-1)。 呼叫 m_dis(hh, ww, r, c) 計算當前座標與操作中心 (r, c) 的曼哈頓距離。 如果距離小於等於 t，則將 board[hh][ww] 的值加上 x。 輸出結果: n 次操作都完成後，使用巢狀迴圈遍歷 board，並依序印出每個格子的最終數值。 實作輔助函式: 在 main 函式之後，實作 m_dis 函式，計算並回傳 |hh - r| + |ww - c|。 分段步驟程式碼 引入函式庫與函式原型 1 2 3 4 5 6 7 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; // 宣告計算曼哈頓距離的函式原型 int m_dis(int,int,int,int); 這段程式碼引入必要的函式庫，並宣告 m_dis 函式，以便 main 函式可以呼叫它。\n讀取輸入與初始化畫布 1 2 3 4 5 6 7 int main(){ int h, w, n; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; n; // 使用 vector 建立 h x w 的二維畫布，並全部初始化為 0 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board(h,vector\u0026lt;int\u0026gt;(w,0)); // ... } 這段程式碼讀取畫布尺寸和操作次數，並動態建立一個 h x w 的二維向量 board。\n模擬 N 次畫筆操作 1 2 3 4 5 6 7 8 9 10 11 12 13 int r, c, t, x; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x; // 讀取單次操作 // 遍歷畫布上的每一個點 for(int hh=0;hh\u0026lt;h;hh++){ for(int ww=0;ww\u0026lt;w;ww++){ // 檢查是否在曼哈頓距離 t 以內 if(m_dis(hh, ww, r, c)\u0026lt;=t){ board[hh][ww] += x; // 累加顏色值 } } } } 這段程式碼是解題的核心。它使用一個迴圈來處理 n 次操作。對於每次操作，它都會遍歷 整個 畫布，檢查每個格子是否在影響範圍內，並如果是，就累加顏色值。\n輸出畫布狀態 1 2 3 4 5 6 7 8 // 遍歷畫布並輸出最終狀態 for(int hh=0;hh\u0026lt;h;hh++){ for(int ww=0;ww\u0026lt;w;ww++){ cout\u0026lt;\u0026lt; board[hh][ww]\u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; // 每印完一行就換行 } } // main 函式結束 這段程式碼在所有操作完成後，依序印出二維向量 board 中的所有值。\n曼哈頓距離函式實作 1 2 3 4 5 6 7 8 9 10 // 實作 m_dis 函式 int m_dis(int hh, int ww, int r, int c){ int h_diff = hh-r; int w_diff = ww-c; // 計算絕對值 if(h_diff\u0026lt;0) h_diff*=-1; if(w_diff\u0026lt;0) w_diff*=-1; // 回傳曼哈頓距離 return h_diff + w_diff; } 這段程式碼實作了計算曼哈頓距離的輔助函式。它計算兩個座標 (hh, ww) 和 (r, c) 之間 x 座標差的絕對值與 y 座標差的絕對值之和。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; // 曼哈頓距離函式原型 int m_dis(int,int,int,int); int main(){ int h, w, n; int r, c, t, x; cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; n; // 初始化 h x w 畫布，全為 0 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board(h,vector\u0026lt;int\u0026gt;(w,0)); // 進行 n 次操作 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x; // 遍歷所有格子 for(int hh=0;hh\u0026lt;h;hh++){ for(int ww=0;ww\u0026lt;w;ww++){ // 如果在範圍內，就加上顏色 if(m_dis(hh, ww, r, c)\u0026lt;=t){ board[hh][ww] += x; } } } } // 輸出最終畫布狀態 for(int hh=0;hh\u0026lt;h;hh++){ for(int ww=0;ww\u0026lt;w;ww++){ cout\u0026lt;\u0026lt; board[hh][ww]\u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; } } // 曼哈頓距離函式實作 int m_dis(int hh, int ww, int r, int c){ int h_diff = hh-r; int w_diff = ww-c; // 取絕對值 if(h_diff\u0026lt;0) h_diff*=-1; if(w_diff\u0026lt;0) w_diff*=-1; return h_diff + w_diff; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2024-06/","summary":"\u003ch1 id=\"1-特技表演\"\u003e1. 特技表演\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入資料\u003c/strong\u003e: 讀取大樓的總數 \u003ccode\u003en\u003c/code\u003e，接著使用一個 \u003ccode\u003efor\u003c/code\u003e 迴圈讀取 \u003ccode\u003en\u003c/code\u003e 棟大樓分別的高度，並將它們儲存在一個陣列 \u003ccode\u003eh\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化變數\u003c/strong\u003e: 初始化兩個整數變數。\u003ccode\u003emax_d\u003c/code\u003e 用來儲存找到的「最長」滑翔路徑長度，初始為 0。\u003ccode\u003ed\u003c/code\u003e 用來儲存「當前」正在計算的連續滑翔路徑長度，初始為 1（因為任何一棟大樓本身都構成長度為 1 的路徑）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e遍歷大樓陣列\u003c/strong\u003e: 使用 \u003ccode\u003efor\u003c/code\u003e 迴圈從第一棟大樓 (\u003ccode\u003ei = 0\u003c/code\u003e) 檢查到倒數第二棟大樓 (\u003ccode\u003ei \u0026lt; n-1\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e判斷路徑是否延伸\u003c/strong\u003e: 在迴圈中，比較目前大樓 \u003ccode\u003eh[i]\u003c/code\u003e 和下一棟大樓 \u003ccode\u003eh[i+1]\u003c/code\u003e 的高度。\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003eh[i] \u0026gt; h[i+1]\u003c/code\u003e，表示符合「越來越低」的條件，滑翔路徑可以繼續，因此將當前路徑長度 \u003ccode\u003ed\u003c/code\u003e 增加 1 (\u003ccode\u003ed++\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003eh[i] \u0026lt;= h[i+1]\u003c/code\u003e，表示路徑中斷（高度沒有變低），因此重置當前路徑長度 \u003ccode\u003ed\u003c/code\u003e 為 1（從 \u003ccode\u003eh[i+1]\u003c/code\u003e 重新開始計算）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新最長路徑\u003c/strong\u003e: 在每次判斷（或重置）\u003ccode\u003ed\u003c/code\u003e 之後，都要檢查 \u003ccode\u003ed\u003c/code\u003e 是否大於 \u003ccode\u003emax_d\u003c/code\u003e。如果 \u003ccode\u003ed\u003c/code\u003e 更大，就更新 \u003ccode\u003emax_d = d\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 迴圈結束後，\u003ccode\u003emax_d\u003c/code\u003e 中儲存的就是整個過程中最長的路徑長度，將其輸出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入資料\"\u003e讀取輸入資料\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼首先讀取大樓的數量 \u003ccode\u003en\u003c/code\u003e，然後宣告一個大小為 \u003ccode\u003en\u003c/code\u003e 的陣列 \u003ccode\u003eh\u003c/code\u003e，並使用迴圈讀取每棟大樓的高度。\u003c/p\u003e","title":"APCS-2024-06"},{"content":"1. 裝飲料 解題步驟 讀取輸入資料: 讀取倒飲料的次數 n，以及杯子兩層的維度 w1, w2, h1, h2。 計算容量並初始化: 根據維度計算下層的容量 low (即 $w_1 \\times w_1 \\times h_1$) 以及杯子的總容量 high (即 low + $w_2 \\times w_2 \\times h_2$)。 初始化狀態變數: 初始化總裝入容量 total 為 0，前一次的高度 prev 為 0，以及答案 (最大高度變化) ans 為 0。 模擬倒水過程: 使用 for 迴圈執行 n 次。 更新總容量與當前高度: 在迴圈中，讀取該次倒入的容量 water，並將其加入 total。 判斷水位高度: 如果 total \u0026lt;= low，表示水位還在下層，curr 高度為 total / (w1*w1)。 如果 total \u0026lt;= high，表示水位已達上層，curr 高度為 h1 + (total - low) / (w2*w2)。 如果 total \u0026gt; high，表示水已裝滿，curr 高度為 h1 + h2。 更新最大變化量: 計算本次的高度變化 curr - prev，如果這個值大於 ans，則更新 ans。 更新前次高度: 將 prev 更新為 curr，以供下次迴圈使用。 輸出結果: 迴圈結束後，輸出 ans。 分段步驟程式碼 讀取輸入資料 1 2 3 int n, w1, w2, h1, h2, water; cin\u0026gt;\u0026gt;n; cin\u0026gt;\u0026gt;w1\u0026gt;\u0026gt;w2\u0026gt;\u0026gt;h1\u0026gt;\u0026gt;h2; 這段程式碼讀取倒飲料的次數 n 和杯子的四個維度參數。\n計算容量並初始化變數 1 2 int low = w1*w1*h1, high = low + w2*w2*h2; int total = 0, prev=0, curr, ans=0; 這段程式碼計算下層容量 low 和總容量 high。並初始化總容量 total、前次高度 prev 和最大高度差 ans。\n模擬 n 次倒水過程並計算高度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;water; total+=water; if(total\u0026lt;=low){ curr = total/(w1*w1); }else if(total\u0026lt;=high){ curr = h1+(total-low)/(w2*w2); }else{ curr = h1+h2; } if(curr-prev \u0026gt; ans){ ans = curr-prev; } prev = curr; } 這段程式碼是解題的核心。它迴圈 n 次，每次：\n讀取當次倒入的容量 water。 更新總容量 total。 根據 total 和 low、high 的關係，計算出當前的水位高度 curr。 計算本次的高度變化 curr - prev，並更新最大變化量 ans。 將 prev 設為 curr，為下一次計算做準備。 輸出最大變化量 1 cout\u0026lt;\u0026lt;ans; 這段程式碼在所有倒入動作完成後，輸出記錄到的最大高度變化 ans。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int n, w1, w2, h1, h2, water; cin\u0026gt;\u0026gt;n; cin\u0026gt;\u0026gt;w1\u0026gt;\u0026gt;w2\u0026gt;\u0026gt;h1\u0026gt;\u0026gt;h2; int low = w1*w1*h1, high = low + w2*w2*h2; int total = 0, prev=0, curr, ans=0; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;water; total+=water; if(total\u0026lt;=low){ curr = total/(w1*w1); }else if(total\u0026lt;=high){ curr = h1+(total-low)/(w2*w2); }else{ curr = h1+h2; } if(curr-prev \u0026gt; ans){ ans = curr-prev; } prev = curr; // cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;ans; return 0; } 2. 蒐集寶石 解題步驟 讀取輸入: 讀取地圖大小 M、N，倍數 k，以及機器人初始位置 r、c。 初始化地圖與邊界: 宣告一個比 M x N 稍大的二維陣列 (例如 102 x 102)。讀取 M x N 的地圖資訊，並在地圖的四周圍上一圈牆壁 (-1)。這樣可以簡化後續的邊界判斷。 初始化機器人狀態: 初始化方向 d = 0 (0:右, 1:下, 2:左, 3:上)。 初始化分數 score = 0。 初始化撿到的寶石數 ans = 0。 將 r 和 c 加 1，以配合我們在地圖周圍加上的牆壁邊界 (變為 1-based 索引)。 模擬遊戲過程 (主迴圈): 使用 while 迴圈模擬遊戲，迴圈繼續的條件是機器人當前位置 g[r][c] 的寶石數不為 0 (規則 1)。 執行規則 2 (撿寶石): ans 增加 1。 score 加上 g[r][c] 的寶石數。 g[r][c] 減 1 (撿走一顆)。 執行規則 3 (檢查分數): 檢查 score 是否為 k 的倍數。如果是，方向 d 向右轉 90 度 (d = (d + 1) % 4)。 執行規則 4 (移動與轉向): 使用一個 for 迴圈（最多 4 次）來尋找下一步。 根據當前方向 d 計算出下一步的座標 (new_r, new_c)。 檢查 g[new_r][new_c] 是否為牆壁 (-1)。 如果不是牆壁: 更新機器人位置 r = new_r, c = new_c，並 break 這個 for 迴圈（代表成功移動，準備進入下一次 while 迴圈）。 如果是牆壁: 機器人向右轉 90 度 (d = (d + 1) % 4)，並繼續 for 迴圈，嘗試新的方向。 輸出結果: 當 while 迴圈結束時 (機器人停在寶石數為 0 的格子)，輸出 ans。 分段步驟程式碼 讀取輸入與初始化邊界 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int M,N,k,r,c; int g[102][102]; cin\u0026gt;\u0026gt;M\u0026gt;\u0026gt;N\u0026gt;\u0026gt;k\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c; // 初始化四周邊界為牆壁 (-1) for(int i=0;i\u0026lt;=M+1;i++){ g[i][0]=-1; g[i][N+1]=-1; } for(int i=0;i\u0026lt;=N+1;i++){ g[0][i]=-1; g[M+1][i+1]=-1; // 注意：這裡應為 g[M+1][i] } // 讀取地圖資訊 for(int i=1;i\u0026lt;=M;i++){ for(int j=1;j\u0026lt;=N;j++){ cin\u0026gt;\u0026gt;g[i][j]; } } (註：原始程式碼中 g[M+1][i+1] 應為 g[M+1][i] 才能正確關閉下邊界，但在此範例中不影響主要邏輯) 這段程式碼讀取基本參數，並在 g[1][1] 到 g[M][N] 的外圍都填上 -1，這樣機器人移動時無需額外判斷是否超出 M x N 範圍，只要檢查是否撞牆 (-1) 即可。 初始化機器人狀態 1 2 int d=0, score=0, ans=0; r++;c++; d=0 代表初始方向向右。 score 和 ans 均從 0 開始。 r++ 和 c++ 將 0-based 索引的輸入轉換為 1-based 索引，以對應我們加了邊界的地圖。 模擬遊戲過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 while(g[r][c]!=0){ // 規則 2: 撿寶石並更新分數 ans++; score += g[r][c]; g[r][c]--; // 規則 3: 根據分數判斷是否右轉 if(score%k==0){ d = (d+1)%4; } // 規則 4: 尋找下一步並移動 for(int j=0;j\u0026lt;4;j++){ int new_r=r,new_c=c; if(d==0) new_c++; else if(d==1) new_r++; else if(d==2) new_c--; else if(d==3) new_r--; if(g[new_r][new_c]!=-1){ // 檢查是否為牆壁 r=new_r; c=new_c; break; // 找到路，移動並結束 } d = (d+1)%4; // 撞牆，向右轉 } } while(g[r][c]!=0): 這是規則 1，只要當前格子寶石數不為 0 就繼續。 規則 2 \u0026amp; 3: 程式碼直接對應題目規則。 規則 4 (for 迴圈): 這是最關鍵的部分。 它首先嘗試當前方向 d。 如果 g[new_r][new_c] 不是 -1 (牆壁)，就更新 r, c 並 break，完成移動。 如果 g[new_r][new_c] 是 -1，就執行 d = (d+1)%4 (向右轉)，for 迴圈繼續，嘗試新的方向。 這個 for 迴圈保證機器人最終會找到一個非牆壁的方向並移動過去。 輸出最終結果 1 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 當 while 迴圈終止 (踩到 0)，輸出總共撿到的寶石數 ans。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int M,N,k,r,c; int g[102][102]; cin\u0026gt;\u0026gt;M\u0026gt;\u0026gt;N\u0026gt;\u0026gt;k\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c; // 初始化邊界 (padding) for(int i=0;i\u0026lt;=M+1;i++){ g[i][0]=-1; g[i][N+1]=-1; } // 修正：應為 g[M+1][i] for(int i=0;i\u0026lt;=N+1;i++){ g[0][i]=-1; g[M+1][i]=-1; // 修正原始碼中的 g[M+1][i+1] } // 讀取地圖 for(int i=1;i\u0026lt;=M;i++){ for(int j=1;j\u0026lt;=N;j++){ cin\u0026gt;\u0026gt;g[i][j]; } } // 初始化機器人狀態 int d=0, score=0, ans=0; r++;c++; // 轉為 1-based 索引 // 遊戲主迴圈 while(g[r][c]!=0){ // 規則 2 ans++; score += g[r][c]; g[r][c]--; // 規則 3 if(score%k==0){ d = (d+1)%4; } // 規則 4 for(int j=0;j\u0026lt;4;j++){ int new_r=r,new_c=c; if(d==0) new_c++; // 右 else if(d==1) new_r++; // 下 else if(d==2) new_c--; // 左 else if(d==3) new_r--; // 上 if(g[new_r][new_c]!=-1){ // 檢查是否撞牆 r=new_r; c=new_c; break; // 成功移動 } d = (d+1)%4; // 撞牆，右轉 } } // 輸出結果 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2024-10/","summary":"\u003ch1 id=\"1-裝飲料\"\u003e1. 裝飲料\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入資料\u003c/strong\u003e: 讀取倒飲料的次數 \u003ccode\u003en\u003c/code\u003e，以及杯子兩層的維度 \u003ccode\u003ew1\u003c/code\u003e, \u003ccode\u003ew2\u003c/code\u003e, \u003ccode\u003eh1\u003c/code\u003e, \u003ccode\u003eh2\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e計算容量並初始化\u003c/strong\u003e: 根據維度計算下層的容量 \u003ccode\u003elow\u003c/code\u003e (即 $w_1 \\times w_1 \\times h_1$) 以及杯子的總容量 \u003ccode\u003ehigh\u003c/code\u003e (即 \u003ccode\u003elow\u003c/code\u003e + $w_2 \\times w_2 \\times h_2$)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化狀態變數\u003c/strong\u003e: 初始化總裝入容量 \u003ccode\u003etotal\u003c/code\u003e 為 0，前一次的高度 \u003ccode\u003eprev\u003c/code\u003e 為 0，以及答案 (最大高度變化) \u003ccode\u003eans\u003c/code\u003e 為 0。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模擬倒水過程\u003c/strong\u003e: 使用 for 迴圈執行 \u003ccode\u003en\u003c/code\u003e 次。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新總容量與當前高度\u003c/strong\u003e: 在迴圈中，讀取該次倒入的容量 \u003ccode\u003ewater\u003c/code\u003e，並將其加入 \u003ccode\u003etotal\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e判斷水位高度\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003etotal \u0026lt;= low\u003c/code\u003e，表示水位還在下層，\u003ccode\u003ecurr\u003c/code\u003e 高度為 \u003ccode\u003etotal / (w1*w1)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003etotal \u0026lt;= high\u003c/code\u003e，表示水位已達上層，\u003ccode\u003ecurr\u003c/code\u003e 高度為 \u003ccode\u003eh1 + (total - low) / (w2*w2)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003etotal \u0026gt; high\u003c/code\u003e，表示水已裝滿，\u003ccode\u003ecurr\u003c/code\u003e 高度為 \u003ccode\u003eh1 + h2\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新最大變化量\u003c/strong\u003e: 計算本次的高度變化 \u003ccode\u003ecurr - prev\u003c/code\u003e，如果這個值大於 \u003ccode\u003eans\u003c/code\u003e，則更新 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更新前次高度\u003c/strong\u003e: 將 \u003ccode\u003eprev\u003c/code\u003e 更新為 \u003ccode\u003ecurr\u003c/code\u003e，以供下次迴圈使用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出結果\u003c/strong\u003e: 迴圈結束後，輸出 \u003ccode\u003eans\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入資料\"\u003e讀取輸入資料\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ew1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ew2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eh1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eh2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ewater\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ew1\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ew2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eh1\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eh2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼讀取倒飲料的次數 \u003ccode\u003en\u003c/code\u003e 和杯子的四個維度參數。\u003c/p\u003e","title":"APCS-2024-10"},{"content":"1. 等紅綠燈 解題步驟 讀取輸入: 讀取綠燈秒數 green、紅燈秒數 red，以及小朋友的人數 n。 計算週期與初始化: 計算一個完整的紅綠燈週期 loop = green + red。初始化總等待時間 delay 為 0。 遍歷小朋友: 使用 for 迴圈，依序處理 n 個小朋友。 讀取騎車時間並計算抵達時刻: 在迴圈中，讀取每個小朋友的騎車時間 t。使用模數運算 (%) 計算 t % loop，這代表小朋友在一個週期中的哪個時間點抵達終點。 判斷是否遇到紅燈: 檢查抵達時間 t % loop 是否大於等於綠燈時間 green。如果是，表示小朋友在紅燈時段抵達。 累計等待時間: 如果在紅燈時段抵達，計算需要等待的時間（loop - (t % loop)），並將其累加到總等待時間 delay。 輸出總和: 迴圈結束後，delay 變數中儲存了所有小朋友的總等待時間，將其輸出。 分段步驟程式碼 讀取輸入與初始化 1 2 3 int green, red, n, t, delay = 0; cin \u0026gt;\u0026gt; green \u0026gt;\u0026gt; red \u0026gt;\u0026gt; n; int loop = green + red; 這段程式碼宣告所有需要的變數。green 和 red 分別儲存綠燈和紅燈的秒數，n 為小朋友人數，t 用於暫存每個小朋友的時間，delay 用於累計總等待時間並初始化為 0。接著讀取 green、red 和 n，並計算出完整的紅綠燈週期 loop。\n遍歷小朋友並計算等待時間 1 2 3 4 5 6 7 for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; t; t %= loop; if(t \u0026gt;= green){ delay += loop - t; } } 這段程式碼使用 for 迴圈處理 n 個小朋友。\ncin \u0026gt;\u0026gt; t;：讀取當前小朋友騎完一圈的時間 t。 t %= loop;：這是解題的關鍵。我們只關心小朋友在紅綠燈週期的 哪個時間點 抵達，而不在乎他繞了幾圈。取 t 對 loop 的餘數，可以得到他在週期中的抵達時間（範圍會是 0 到 loop-1）。 if(t \u0026gt;= green)：判斷這個抵達時間是否在紅燈時段。綠燈時段是 [0, green-1]，紅燈時段是 [green, loop-1]。 delay += loop - t;：如果是在紅燈時段（t）抵達，他需要等到週期結束（loop），因此等待時間為 loop - t。將這段時間累加到 delay。 輸出總等待時間 1 cout \u0026lt;\u0026lt; delay ; 迴圈結束後，delay 已經累計了所有小朋友的等待時間，將其輸出。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int green, red, n, t, delay = 0; cin \u0026gt;\u0026gt; green \u0026gt;\u0026gt; red \u0026gt;\u0026gt; n; int loop = green + red; for(int i=0;i\u0026lt;n;i++){ cin \u0026gt;\u0026gt; t; t %= loop; if(t \u0026gt;= green){ delay += loop - t; } } cout \u0026lt;\u0026lt; delay ; return 0; } 2. 字串操作 解題步驟 讀取輸入與初始化: 讀取初始字串 s 和操作次數 k。並儲存字串的長度 s_len 以方便後續使用。 迴圈處理 K 次操作: 使用一個 for 迴圈，從 i=0 到 k-1，執行 k 次操作。 讀取並判斷操作類型: 在 for 迴圈中，首先讀取當次的操作類型 op。 執行操作: 如果 op == 0 (兩兩交換): 寫一個 for 迴圈，j 從 0 開始，每次遞增 2 (即 0, 2, 4, \u0026hellip;)。在迴圈中，使用一個 temp 變數來交換 s[j] 和 s[j+1]。 如果 op == 1 (兩兩排序): 同樣使用一個 j 迴圈 (步長為 2)。在迴圈中，檢查 if(s[j] \u0026gt; s[j+1])，如果條件成立（即順序錯誤），則交換 s[j] 和 s[j+1]。 如果 op == 2 (完美重排): 宣告一個暫存字串 s_temp 並將 s 複製過去。接著，寫一個 for 迴圈，i 從 0 跑到 s_len/2 - 1。在迴圈中，將 s_temp 的前半段 s_temp[i] 放到 s 的偶數索引 s[2*i]，並將 s_temp 的後半段 s_temp[i + s_len/2] 放到 s 的奇數索引 s[2*i+1]。 輸出最終字串: 在 k 次操作的 for 迴圈結束後，輸出最終的字串 s。 分段步驟程式碼 讀取輸入與初始化 1 2 3 4 string s; int k, op; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int s_len = s.length(); 這段程式碼讀取初始字串 s 和操作次數 k，並將 s 的長度儲存在 s_len 變數中。\n迴圈處理 K 次操作 1 2 3 4 for(int i=0;i\u0026lt;k;i++){ cin \u0026gt;\u0026gt; op; // ... 根據 op 執行對應操作 ... } 這段程式碼建立一個迴圈，會執行 k 次。在每次迴圈開始時，讀取使用者輸入的操作類型 op。\n操作 0: 兩兩交換 1 2 3 4 5 6 7 if(op == 0){ for(int j=0;j\u0026lt;s_len;j+=2){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } 如果 op 為 0，此迴圈會遍歷字串的索引 0, 2, 4, \u0026hellip;，並將 s[j] 和 s[j+1] 進行交換。\n操作 1: 兩兩排序 1 2 3 4 5 6 7 8 9 else if(op == 1){ for(int j=0;j\u0026lt;s_len;j+=2){ if(s[j] \u0026gt; s[j+1]){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } } 如果 op 為 1，此迴圈同樣遍歷索引 0, 2, 4, \u0026hellip;。但只在 s[j] 的字典序大於 s[j+1] 時才進行交換，確保每對字元都按字典序排列。\n操作 2: 完美重排 1 2 3 4 5 6 7 else{ string s_temp = s; for(int i=0;i\u0026lt;s_len/2;i++){ s[2*i] = s_temp[i]; s[2*i+1] = s_temp[i+s_len/2]; } } 如果 op 為 2，首先建立一個 s_temp 來保存 s 的原始狀態。然後迴圈 i 從 0 執行到 s_len/2 - 1，將 s_temp 的前半段 s_temp[i] 和後半段 s_temp[i + s_len/2] 交錯放入 s 的 s[2*i] 和 s[2*i+1] 位置。\n輸出最終結果 1 cout \u0026lt;\u0026lt; s; 在 k 次操作全部執行完畢後，輸出字串 s 的最終內容。\n完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ string s; int k, op; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int s_len = s.length(); for(int i=0;i\u0026lt;k;i++){ cin \u0026gt;\u0026gt; op; if(op == 0){ for(int j=0;j\u0026lt;s_len;j+=2){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } else if(op == 1){ for(int j=0;j\u0026lt;s_len;j+=2){ if(s[j] \u0026gt; s[j+1]){ char temp = s[j]; s[j] = s[j+1]; s[j+1] = temp; } } } else{ string s_temp = s; for(int i=0;i\u0026lt;s_len/2;i++){ s[2*i] = s_temp[i]; s[2*i+1] = s_temp[i+s_len/2]; } } } cout \u0026lt;\u0026lt; s; return 0; } ","permalink":"https://aura.codex.tw/posts/apcs/apcs-2025-01/","summary":"\u003ch1 id=\"1-等紅綠燈\"\u003e1. 等紅綠燈\u003c/h1\u003e\n\u003ch2 id=\"解題步驟\"\u003e解題步驟\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e讀取輸入\u003c/strong\u003e: 讀取綠燈秒數 \u003ccode\u003egreen\u003c/code\u003e、紅燈秒數 \u003ccode\u003ered\u003c/code\u003e，以及小朋友的人數 \u003ccode\u003en\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e計算週期與初始化\u003c/strong\u003e: 計算一個完整的紅綠燈週期 \u003ccode\u003eloop = green + red\u003c/code\u003e。初始化總等待時間 \u003ccode\u003edelay\u003c/code\u003e 為 0。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e遍歷小朋友\u003c/strong\u003e: 使用 \u003ccode\u003efor\u003c/code\u003e 迴圈，依序處理 \u003ccode\u003en\u003c/code\u003e 個小朋友。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e讀取騎車時間並計算抵達時刻\u003c/strong\u003e: 在迴圈中，讀取每個小朋友的騎車時間 \u003ccode\u003et\u003c/code\u003e。使用模數運算 (\u003ccode\u003e%\u003c/code\u003e) 計算 \u003ccode\u003et % loop\u003c/code\u003e，這代表小朋友在一個週期中的哪個時間點抵達終點。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e判斷是否遇到紅燈\u003c/strong\u003e: 檢查抵達時間 \u003ccode\u003et % loop\u003c/code\u003e 是否大於等於綠燈時間 \u003ccode\u003egreen\u003c/code\u003e。如果是，表示小朋友在紅燈時段抵達。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e累計等待時間\u003c/strong\u003e: 如果在紅燈時段抵達，計算需要等待的時間（\u003ccode\u003eloop - (t % loop)\u003c/code\u003e），並將其累加到總等待時間 \u003ccode\u003edelay\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e輸出總和\u003c/strong\u003e: 迴圈結束後，\u003ccode\u003edelay\u003c/code\u003e 變數中儲存了所有小朋友的總等待時間，將其輸出。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"分段步驟程式碼\"\u003e分段步驟程式碼\u003c/h2\u003e\n\u003ch3 id=\"讀取輸入與初始化\"\u003e讀取輸入與初始化\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003egreen\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ered\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edelay\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003egreen\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ered\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eloop\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egreen\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ered\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e這段程式碼宣告所有需要的變數。\u003ccode\u003egreen\u003c/code\u003e 和 \u003ccode\u003ered\u003c/code\u003e 分別儲存綠燈和紅燈的秒數，\u003ccode\u003en\u003c/code\u003e 為小朋友人數，\u003ccode\u003et\u003c/code\u003e 用於暫存每個小朋友的時間，\u003ccode\u003edelay\u003c/code\u003e 用於累計總等待時間並初始化為 0。接著讀取 \u003ccode\u003egreen\u003c/code\u003e、\u003ccode\u003ered\u003c/code\u003e 和 \u003ccode\u003en\u003c/code\u003e，並計算出完整的紅綠燈週期 \u003ccode\u003eloop\u003c/code\u003e。\u003c/p\u003e","title":"APCS-2025-01"},{"content":"Week2 2487. Remove Nodes From Linked List Leetcode Link My Solution\n1004. Max Consecutive Ones III Leetcode Link My Solution\n933. Number of Recent Calls Leetcode Link My Solution\n104. Maximum Depth of Binary Tree Leetcode Link My Solution\n374. Guess Number Higher or Lower Leetcode Link My Solution\n452. Minimum Number of Arrows to Burst Balloons Leetcode Link My Solution\n1657. Determine if Two Strings Are Close Leetcode Link My Solution\n2816. Double a Number Represented as a Linked List Leetcode Link My Solution\n506. Relative Ranks Leetcode Link My Solution\n3075. Maximize Happiness of Selected Children Leetcode Link My Solution\n786. K-th Smallest Prime Fraction Leetcode Link My Solution\n857. Minimum Cost to Hire K Workers Leetcode Link My Solution\n872. Leaf-Similar Trees Leetcode Link My Solution\n790. Domino and Tromino Tiling Leetcode Link My Solution\n2373. Largest Local Values in a Matrix Leetcode Link My Solution\n3146. Permutation Difference between Two Strings Leetcode Link My Solution\n3147. Taking Maximum Energy From the Mystic Dungeon Leetcode Link My Solution\n3148. Maximum Difference Score in a Grid Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2024-05-w2/","summary":"\u003ch1 id=\"week2\"\u003eWeek2\u003c/h1\u003e\n\u003ch5 id=\"2487-remove-nodes-from-linked-list\"\u003e2487. Remove Nodes From Linked List\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/remove-nodes-from-linked-list/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2487\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1004-max-consecutive-ones-iii\"\u003e1004. Max Consecutive Ones III\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/max-consecutive-ones-iii/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1004\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"933-number-of-recent-calls\"\u003e933. Number of Recent Calls\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/number-of-recent-calls/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/933\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"104-maximum-depth-of-binary-tree\"\u003e104. Maximum Depth of Binary Tree\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/104\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"374-guess-number-higher-or-lower\"\u003e374. Guess Number Higher or Lower\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/guess-number-higher-or-lower/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/374\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"452-minimum-number-of-arrows-to-burst-balloons\"\u003e452. Minimum Number of Arrows to Burst Balloons\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/452\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1657-determine-if-two-strings-are-close\"\u003e1657. Determine if Two Strings Are Close\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/determine-if-two-strings-are-close/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1657\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2816-double-a-number-represented-as-a-linked-list\"\u003e2816. Double a Number Represented as a Linked List\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2816\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2024/05 W2"},{"content":" ","permalink":"https://aura.codex.tw/posts/leetcode/temp/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"\"\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"LeetCode 2024/05 W2"},{"content":"2441. Largest Positive Integer That Exists With Its Negative Solution 1 檢查數值，如果是正數+1，如果是負數+2，當數值剛好為 3 時代表正數與負數都有出現，正數負數都只會加一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int findMaxK(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int table[1001] = {0}; int ans = -1; for (auto num : nums) { if (num \u0026gt; 0) { if (table[num] == 0 || table[num] == 2) { table[num] += 1; } } else { if (table[-num] == 0 || table[-num] == 1) { table[-num] += 2; } } cout \u0026lt;\u0026lt; table[abs(num)] \u0026lt;\u0026lt; endl; if (table[abs(num)] == 3) { ans = max(ans, abs(num)); } } return ans; } }; Solution 2 將陣列用絕對值大小排序，再來就是從大到小檢查，找出最先出現第 i 數與第 i+1 數互為正負數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: static bool cmp(int a, int b) { if (abs(a) == abs(b)) { return a \u0026gt; b; } return abs(a) \u0026gt; abs(b); } int findMaxK(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end(), cmp); int n = nums.size(); for (int i = 0; i \u0026lt; n - 1; i++) { if (nums[i] == -nums[i + 1]) { return nums[i]; } } return -1; } }; Solution 3 將陣列大到小排序，雙指標從兩側找出最先符合條件的數字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int findMaxK(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); int left = 0, right = nums.size() - 1; while (left \u0026lt; right) { if (nums[left] * -1 == nums[right]) { return nums[right]; } else if (nums[left] * -1 \u0026lt; nums[right]) { right--; } else { left++; } } return -1; } }; ","permalink":"https://aura.codex.tw/posts/leetcode-writeup/leetcode-writeup-2441-largest-positive-integer-that-exists-with-its-negative/","summary":"\u003ch1 id=\"2441-largest-positive-integer-that-exists-with-its-negative\"\u003e2441. \u003ca href=\"https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description/\"\u003eLargest Positive Integer That Exists With Its Negative\u003c/a\u003e\u003c/h1\u003e\n\u003ch1 id=\"solution-1\"\u003eSolution 1\u003c/h1\u003e\n\u003cp\u003e檢查數值，如果是正數+1，如果是負數+2，當數值剛好為 3 時代表正數與負數都有出現，正數負數都只會加一次。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003efindMaxK\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1001\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"nl\"\u003enum\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e)]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e)]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eans\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"solution-2\"\u003eSolution 2\u003c/h1\u003e\n\u003cp\u003e將陣列用絕對值大小排序，再來就是從大到小檢查，找出最先出現第 i 數與第 i+1 數互為正負數。\u003c/p\u003e","title":"LeetCode-Writeup 2441. Largest Positive Integer That Exists With Its Negative"},{"content":"Container Container status 1 2 docker ps docker ps -q # Only get running Container ID Run container 1 2 3 4 5 6 docker run --name={NAME} \\ # Container name -d \\ # Running in the background -e {PARAM-NAME}={PARAM-VALUE} \\ # Parameters -v {OUTSIDE-PATH}:{INSIDE-PATH} \\ # Volume PATH -p {OUTSIDE-PORT}:{INSIDE-PORT} \\ # Port forwarding {REPOSITORY/IMAGE-Name} Start container 1 docker start {CONTAINER-ID/NAMES} Stop container 1 docker stop {CONTAINER-ID/NAMES} Control container 1 docker exec -it {CONTAINER-ID/NAMES} bash Remove container 1 docker rm {CONTAINER-ID/NAMES} Container logs 1 docker logs {CONTAINER-ID/NAMES} images Images list 1 docker image ls Remove image 1 docker image rm {REPOSITORY} Build image 1 docker build -t {IMAGE-Name} {PATH} Push image 1 docker push {IMAGE-Name} With Github Login ghcr.io with docker on terminal Get a \u0026ldquo;personal access token (classic)\u0026rdquo; from Developer Page\nlogin by terminal\n1 2 export CR_PAT=ghp_xxxxx echo $CR_PAT | docker login ghcr.io -u {Github ID} --password-stdin ","permalink":"https://aura.codex.tw/posts/docker-tutorial/","summary":"\u003ch1 id=\"container\"\u003eContainer\u003c/h1\u003e\n\u003ch2 id=\"container-status\"\u003eContainer status\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker ps\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker ps -q \u003cspan class=\"c1\"\u003e# Only get running Container ID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"run-container\"\u003eRun container\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run --name\u003cspan class=\"o\"\u003e={\u003c/span\u003eNAME\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e \u003cspan class=\"c1\"\u003e# Container name\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            -d \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e           \u003cspan class=\"c1\"\u003e# Running in the background\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            -e \u003cspan class=\"o\"\u003e{\u003c/span\u003ePARAM-NAME\u003cspan class=\"o\"\u003e}={\u003c/span\u003ePARAM-VALUE\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e   \u003cspan class=\"c1\"\u003e# Parameters\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            -v \u003cspan class=\"o\"\u003e{\u003c/span\u003eOUTSIDE-PATH\u003cspan class=\"o\"\u003e}\u003c/span\u003e:\u003cspan class=\"o\"\u003e{\u003c/span\u003eINSIDE-PATH\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e \u003cspan class=\"c1\"\u003e# Volume PATH\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            -p \u003cspan class=\"o\"\u003e{\u003c/span\u003eOUTSIDE-PORT\u003cspan class=\"o\"\u003e}\u003c/span\u003e:\u003cspan class=\"o\"\u003e{\u003c/span\u003eINSIDE-PORT\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\ \u003c/span\u003e \u003cspan class=\"c1\"\u003e# Port forwarding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"o\"\u003e{\u003c/span\u003eREPOSITORY/IMAGE-Name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"start-container\"\u003eStart container\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker start \u003cspan class=\"o\"\u003e{\u003c/span\u003eCONTAINER-ID/NAMES\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"stop-container\"\u003eStop container\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker stop \u003cspan class=\"o\"\u003e{\u003c/span\u003eCONTAINER-ID/NAMES\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"control-container\"\u003eControl container\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e -it \u003cspan class=\"o\"\u003e{\u003c/span\u003eCONTAINER-ID/NAMES\u003cspan class=\"o\"\u003e}\u003c/span\u003e bash\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"remove-container\"\u003eRemove container\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker rm \u003cspan class=\"o\"\u003e{\u003c/span\u003eCONTAINER-ID/NAMES\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"container-logs\"\u003eContainer logs\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker logs \u003cspan class=\"o\"\u003e{\u003c/span\u003eCONTAINER-ID/NAMES\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"images\"\u003eimages\u003c/h1\u003e\n\u003ch2 id=\"images-list\"\u003eImages list\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker image ls\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"remove-image\"\u003eRemove image\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker image rm \u003cspan class=\"o\"\u003e{\u003c/span\u003eREPOSITORY\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"build-image\"\u003eBuild image\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker build -t \u003cspan class=\"o\"\u003e{\u003c/span\u003eIMAGE-Name\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003ePATH\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"push-image\"\u003ePush image\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker push \u003cspan class=\"o\"\u003e{\u003c/span\u003eIMAGE-Name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"with-github\"\u003eWith Github\u003c/h1\u003e\n\u003ch2 id=\"login-ghcrio-with-docker-on-terminal\"\u003eLogin ghcr.io with docker on terminal\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eGet a \u0026ldquo;personal access token (classic)\u0026rdquo; from \u003ca href=\"https://github.com/settings/tokens\"\u003eDeveloper Page\u003c/a\u003e\u003c/p\u003e","title":"Docker Tutorial"},{"content":"Week1 2997. Minimum Number of Operations to Make Array XOR Equal to K Leetcode Link My Solution\n2000. Reverse Prefix of Word Leetcode Link My Solution\n2441. Largest Positive Integer That Exists With Its Negative Leetcode Link My Solution\n7. Reverse Integer Leetcode Link My Solution\n8. String to Integer (atoi) Leetcode Link My Solution\n165. Compare Version Numbers Leetcode Link My Solution\n39. Combination Sum Leetcode Link My Solution\n881. Boats to Save People Leetcode Link My Solution\n374. Guess Number Higher or Lower Leetcode Link My Solution\n1137. N-th Tribonacci Number Leetcode Link My Solution\n3136. Valid Word Leetcode Link My Solution\n3137. Minimum Number of Operations to Make Word K-Periodic Leetcode Link My Solution\n3138. Minimum Length of Anagram Concatenation Leetcode Link My Solution\n237. Delete Node in a Linked List Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2024-05-w1/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"2997-minimum-number-of-operations-to-make-array-xor-equal-to-k\"\u003e2997. Minimum Number of Operations to Make Array XOR Equal to K\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2997\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2000-reverse-prefix-of-word\"\u003e2000. Reverse Prefix of Word\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/reverse-prefix-of-word\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2000\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2441-largest-positive-integer-that-exists-with-its-negative\"\u003e2441. Largest Positive Integer That Exists With Its Negative\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2441\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"7-reverse-integer\"\u003e7. Reverse Integer\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/reverse-integer/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/7\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"8-string-to-integer-atoi\"\u003e8. String to Integer (atoi)\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/string-to-integer-atoi/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/8\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"165-compare-version-numbers\"\u003e165. Compare Version Numbers\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/compare-version-numbers/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/165\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"39-combination-sum\"\u003e39. Combination Sum\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/combination-sum/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/39\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"881-boats-to-save-people\"\u003e881. Boats to Save People\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/boats-to-save-people/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/881\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2024/05 W1"},{"content":"2370. Longest Ideal Subsequence 這題是個基礎的 DP 題，很值得練習。\nIdea 1 TLE 第一種方法，就是當前的字往前檢查可以接的字有哪些，選最高的。\nMain function 第 n 個字時，會檢查 n-1 到 1 的字字串的長度\n1 2 3 4 5 6 for(int i=0;i\u0026lt;n;i++){ temp=0; for(int j=i-1;j\u0026gt;=0;j--){ ... } } 先檢查當前的字和前面的字距離有沒有小於等於 k，如果有才符合題目條件。\n有的話再檢查是否大於目前記錄到的長度。\n1 2 3 4 5 if(abs(s[i]-s[j])\u0026lt;=k){ if(seq[j]\u0026gt;temp){ temp=seq[j]; } } 找到前面可以接續的最長長度後，加上自己把值存進自己位置的陣列，讓下一個字往前檢查時可以讀到。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\n1 2 seq[i]=temp+1; ans=max(ans,seq[i]); Full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int longestIdealString(string s, int k) { int n=s.size(),ans=0,temp=0; vector\u0026lt;int\u0026gt; seq(n); for(int i=0;i\u0026lt;n;i++){ temp=0; for(int j=i-1;j\u0026gt;=0;j--){ if(abs(s[i]-s[j])\u0026lt;=k){ if(seq[j]\u0026gt;temp){ temp=seq[j]; } } } seq[i]=temp+1; ans=max(ans,seq[i]); } return ans; } }; Solution 1 第一個方法好理解，但問題是每次往前檢查不知道要檢查到第幾個，因此都檢查到第一個，執行時間是 O(n^2)，雖然有用到 DP 的概念，但不怎麼有效率。\n如何有效的紀錄每個字的狀態？\n第二種方法，不同於紀錄字串每個位置的長度，而是用每個字母紀錄最長的長度。\n因為字元差需要在 k 之間，因此只需檢查當前字母+-k 的字母就可以，\n舉例像是字母 c，k=1，那只需檢查 abcdefgh 就行。\n檢查後將新的值放到 c 的位置，讓下一個字可以繼續更新。\nMain function 每個字都還是要跑一遍，用nowWordIdx將當前的字轉換成數字 0 ~ 25\n1 2 3 4 5 for(int i=0;i\u0026lt;n;i++){ temp=0; nowWordIdx=s[i]-\u0026#39;a\u0026#39;; ... } 透過nowWordIdx，我僅需檢查 +-k 的字，但要注意nowWordIdx-k需大於 0，nowWordIdx+k需小於 25，避免超出範圍。\n1 2 3 4 5 for(int j=max(nowWordIdx-k,0);j\u0026lt;=min(nowWordIdx+k,25);j++){ if(cnt[j]\u0026gt;temp){ temp=cnt[j]; } } 當前的字找到最長的值後，加上自己後存在自己字母索引的地方，讓下一個字檢查時可以更新。\n題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\n1 2 cnt[nowWordIdx]=temp+1; ans=max(ans,temp+1); Full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int longestIdealString(string s, int k) { int n=s.size(),ans=0,temp=0,nowWordIdx; vector\u0026lt;int\u0026gt; cnt(26,0); for(int i=0;i\u0026lt;n;i++){ temp=0; nowWordIdx=s[i]-\u0026#39;a\u0026#39;; for(int j=max(nowWordIdx-k,0);j\u0026lt;=min(nowWordIdx+k,25);j++){ if(cnt[j]\u0026gt;temp){ temp=cnt[j]; } } cnt[nowWordIdx]=temp+1; ans=max(ans,temp+1); } return ans; } }; ","permalink":"https://aura.codex.tw/posts/leetcode-writeup/leetcode-writeup-2370-longest-ideal-subsequence/","summary":"\u003ch1 id=\"2370-longest-ideal-subsequence\"\u003e2370. \u003ca href=\"https://leetcode.com/problems/longest-ideal-subsequence/description/\"\u003eLongest Ideal Subsequence\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e這題是個基礎的 DP 題，很值得練習。\u003c/p\u003e\n\u003ch1 id=\"idea-1-tle\"\u003eIdea 1 TLE\u003c/h1\u003e\n\u003cp\u003e第一種方法，就是當前的字往前檢查可以接的字有哪些，選最高的。\u003c/p\u003e\n\u003ch2 id=\"main-function\"\u003eMain function\u003c/h2\u003e\n\u003cp\u003e第 \u003ccode\u003en\u003c/code\u003e 個字時，會檢查 \u003ccode\u003en-1\u003c/code\u003e 到 \u003ccode\u003e1\u003c/code\u003e 的字字串的長度\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e先檢查當前的字和前面的字距離有沒有小於等於 \u003ccode\u003ek\u003c/code\u003e，如果有才符合題目條件。\u003c/p\u003e\n\u003cp\u003e有的話再檢查是否大於目前記錄到的長度。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e找到前面可以接續的最長長度後，加上自己把值存進自己位置的陣列，讓下一個字往前檢查時可以讀到。\u003c/p\u003e\n\u003cp\u003e題目要求回傳最長的符合題意的字串長度，因此用個變數順便紀錄，這樣最後直接回傳即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"full-code\"\u003eFull code\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003elongestIdealString\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003etemp\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"solution-1\"\u003eSolution 1\u003c/h1\u003e\n\u003cp\u003e第一個方法好理解，但問題是每次往前檢查不知道要檢查到第幾個，因此都檢查到第一個，執行時間是 \u003ccode\u003eO(n^2)\u003c/code\u003e，雖然有用到 DP 的概念，但不怎麼有效率。\u003c/p\u003e","title":"LeetCode-Writeup 2370. Longest Ideal Subsequence"},{"content":"310. Minimum Height Trees 這題問題不難，難在要如何在時間內完成。\nIdea 1 TLE 70/71 Main function 先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\n1 2 3 4 5 6 for (auto edge : edges) { dict[edge[0]].push_back(edge[1]); dict[edge[1]].push_back(edge[0]); dictCnt[edge[0]]++; dictCnt[edge[1]]++; } 再來就是從第 0 個節點開始，迴圈找跟第 0 個節點連結的節點後，用遞迴的方式往下尋找以第 0 個節點為首的最常深度，以下用第 0 個節點開始作為範例。 如果當前節點連結數只有 1，代表他只和第 0 個節點有連接，因此不須往下檢查。\n1 2 3 if (dictCnt[i] == 1) { continue; } 如果有大於 1 的連接數，則可繼續往下，檢查第 0 個節點是否有更深的深度。 depth 為當前節點所記錄的深度，ansDepth 為整體最短深度，當前節點深度已經大於記錄到的最短深度時，則代表一定不會是答案，則跳出了不需浪費時間檢查。\n1 2 3 4 5 6 for (auto now : dict[i]) { depth = max(depth, maxDepth(i, now, ansDepth)); if (depth \u0026gt; ansDepth) { break; } } 因為題目是要找出哪些節點做為根節點有最低深度，因此如果當前節點深度與目前最低深度的節點相同，則同為答案，如果小於最低深度，代表有更小深度的根節點，則最小深度要重新記錄。\n1 2 3 4 5 6 if (depth == ansDepth) { ans.push_back(i); } else if (depth \u0026lt; ansDepth) { ansDepth = depth; ans = {i}; } Recursion 那我的要遞迴什麼? 當找到子節點又有除了根節點以外的連結，則須往下檢查深度。 參數有三個：根節點值、當前節點值、最低深度\n先用一個 for 迴圈，去尋訪一次當前節點有的所有連接節點。 如果當前節點的連接只有 1，代表只和根節點有連接，因此不必浪費時間檢查。\n1 2 3 4 5 6 7 for (auto node : dict[now]) { if (dictCnt[node] == 1) { continue; } . . . 如果當前節點的子節點為根節點，則跳過，反之其他都要往下尋找， 如果當前深度已經大於目前最低深度了，則可提前跳出。\n1 2 3 4 5 6 if (node != last) { depth = max(depth, maxDepth(now, node, ansDepth)); if (ansDepth \u0026lt; depth) { return depth + 1; } } 最後回傳深度，只當前節點(1)加上當前節點的深度(depth)。\n1 return 1 + depth; Full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dict; vector\u0026lt;int\u0026gt; dictCnt; int maxDepth(int last, int now, int ansDepth) { int depth = 0; for (auto node : dict[now]) { if (dictCnt[node] == 1) { continue; } if (node != last) { depth = max(depth, maxDepth(now, node, ansDepth)); if (ansDepth \u0026lt; depth) { return depth + 1; } } } return 1 + depth; } vector\u0026lt;int\u0026gt; findMinHeightTrees(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { if(edges.size()==1){ return edges[0]; } dict.resize(n); dictCnt.resize(n); for (auto edge : edges) { dict[edge[0]].push_back(edge[1]); dict[edge[1]].push_back(edge[0]); dictCnt[edge[0]]++; dictCnt[edge[1]]++; } int minDepth = INT_MAX, ansDepth = INT_MAX, depth; vector\u0026lt;int\u0026gt; ans; for (int i = 0; i \u0026lt; n; i++) { depth = 1; if (dictCnt[i] == 1) { continue; } for (auto now : dict[i]) { depth = max(depth, maxDepth(i, now, ansDepth)); if (depth \u0026gt; ansDepth) { break; } } if (depth == ansDepth) { ans.push_back(i); } else if (depth \u0026lt; ansDepth) { ansDepth = depth; ans = {i}; } } return ans; } }; Solution 1 Main function 上述方法會超時，因為你從根節點出發，你無法得知多久會到子節點，因此另外一個想法為從子節點出發到根節點。\n先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\n1 2 3 4 5 6 for (auto edge : edges) { tree[edge[0]].push_back(edge[1]); tree[edge[1]].push_back(edge[0]); treeCnt[edge[0]]++; treeCnt[edge[1]]++; } 透過紀錄節點連接數量的 vector，找尋連接只有 1 的節點，因為這些節點只有與他們的根節點連接，因此連接數只有 1。\n端節點：只連結數只有 1 個末端節點 這裡的 leafs 則是用做記錄所有端節點\n1 2 3 4 5 6 7 vector\u0026lt;int\u0026gt; leafs; for (int i = 0; i \u0026lt; treeCnt.size(); i++) { if (treeCnt[i] == 1) { treeCnt[i]--; leafs.push_back(i); } } Recursion 遞迴的概念是要將每次的端節點拔除後，如果他的根節點變為端節點，則在下一輪拔除，拔到最後一層節點沒根節點後，則他們都是根節點。 參數有一個：當前的端節點\n首先先尋訪與當前端節點有連接的節點，如果當前節點的連接數不為 0，代表還有連接，則需進一步執行。\n1 2 3 4 5 6 7 for (auto leaf : leafs) { for (auto node : tree[leaf]) { if (treeCnt[node] != 0) { ... } } } 接下來就是要在當前節點的數量減一，把當前節點與端節點拔除。 當此時當前節點變為 1 時，代表他又只與一個根節點連接，因此把它作為新的端節點。\n1 2 3 4 5 6 if (treeCnt[node] != 0) { treeCnt[node]--; if (treeCnt[node] == 1) { newLeafs.push_back(node); } } 最後，如果沒有新的端節點產生，則代表已經到了最後一層了，因此剩餘的都是最後一層根節點，也就是答案。 如果還有新的端節點，則需在往下檢查下一層的節點。\n1 2 3 4 if (newLeafs.size() == 0) { return leafs; } return maxDepth(newLeafs); Conclusion 第二個方法能通，是因為不是去檢查該節點是不是根節點，而是把不是根節點的拔一拔後，剩餘的就是根節點。 一次拔除多個端節點，可以有效地降低相同節點被尋訪的次數，讓整體時間降低。\n方法一的遞迴是每個節點到下一個節點，因此遞迴數量很大。\n方法二的遞迴是每層的端節點到下一層，每次遞迴可以檢查多的節點，而且理論上越接近根節點分支就會變少，可以大幅降低遞迴數量。\nFull code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; tree; vector\u0026lt;int\u0026gt; treeCnt; vector\u0026lt;int\u0026gt; maxDepth(vector\u0026lt;int\u0026gt; leafs) { vector\u0026lt;int\u0026gt; newLeafs; for (auto leaf : leafs) { for (auto node : tree[leaf]) { if (treeCnt[node] != 0) { treeCnt[node]--; if (treeCnt[node] == 1) { newLeafs.push_back(node); } } } } if (newLeafs.size() == 0) { return leafs; } return maxDepth(newLeafs); } vector\u0026lt;int\u0026gt; findMinHeightTrees(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { if (n == 1) { return {0}; } tree.resize(n); treeCnt.resize(n); for (auto edge : edges) { tree[edge[0]].push_back(edge[1]); tree[edge[1]].push_back(edge[0]); treeCnt[edge[0]]++; treeCnt[edge[1]]++; } vector\u0026lt;int\u0026gt; leafs; for (int i = 0; i \u0026lt; treeCnt.size(); i++) { if (treeCnt[i] == 1) { treeCnt[i]--; leafs.push_back(i); } } return maxDepth(leafs); } }; ","permalink":"https://aura.codex.tw/posts/leetcode-writeup/leetcode-writeup-310-minimum-height-trees/","summary":"\u003ch1 id=\"310-minimum-height-trees\"\u003e310. \u003ca href=\"https://leetcode.com/problems/minimum-height-trees/description/\"\u003eMinimum Height Trees\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e這題問題不難，難在要如何在時間內完成。\u003c/p\u003e\n\u003ch1 id=\"idea-1-tle-7071\"\u003eIdea 1 TLE 70/71\u003c/h1\u003e\n\u003ch2 id=\"main-function\"\u003eMain function\u003c/h2\u003e\n\u003cp\u003e先將所有的連結建立成一個字典，紀錄節點連接的其他節點，以及用另一個 vector 紀錄節點連接其他節點的數量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"nl\"\u003eedge\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eedges\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edict\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]].\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edict\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]].\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edictCnt\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edictCnt\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eedge\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e再來就是從第 0 個節點開始，迴圈找跟第 0 個節點連結的節點後，用遞迴的方式往下尋找以第 0 個節點為首的最常深度，以下用第 0 個節點開始作為範例。\n如果當前節點連結數只有 1，代表他只和第 0 個節點有連接，因此不須往下檢查。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edictCnt\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果有大於 1 的連接數，則可繼續往下，檢查第 0 個節點是否有更深的深度。\ndepth 為當前節點所記錄的深度，ansDepth 為整體最短深度，當前節點深度已經大於記錄到的最短深度時，則代表一定不會是答案，則跳出了不需浪費時間檢查。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"nl\"\u003enow\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003edict\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edepth\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edepth\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emaxDepth\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enow\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eansDepth\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edepth\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eansDepth\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e因為題目是要找出哪些節點做為根節點有最低深度，因此如果當前節點深度與目前最低深度的節點相同，則同為答案，如果小於最低深度，代表有更小深度的根節點，則最小深度要重新記錄。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edepth\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eansDepth\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"nf\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edepth\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eansDepth\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eansDepth\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edepth\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eans\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"recursion\"\u003eRecursion\u003c/h2\u003e\n\u003cp\u003e那我的要遞迴什麼?\n當找到子節點又有除了根節點以外的連結，則須往下檢查深度。\n參數有三個：根節點值、當前節點值、最低深度\u003c/p\u003e","title":"LeetCode-Writeup 310. Minimum Height Trees"},{"content":"319. Bulb Switcher 這題還蠻有趣的，有三個接續的概念，兩個可過的解法\nIdea 1 TLE 換個問題問，是否有辦法知道每個燈泡會在何時開關 開關次數是奇數最後會亮，偶數會暗，因此只要知道該燈泡是奇數次就可以知道最後是亮著了。\n那怎麼知道每顆燈在何時會開關？ 第 6 顆燈泡為例，開關的時間點會在 1, 2, 3, 6 次觸發，偶數次是暗 第 10 顆燈泡為例，開關的時間點會在 1, 2, 5, 10 次觸發，偶數次是暗 第 36 顆燈泡為例，開關的時間點會在 1, 2, 3, 4, 6, 9, 12, 18, 36 次觸發，奇數次是亮\n數感好的話，應該會發現第 n 顆燈泡會開關的時間點會是在 n 的\u0026quot;因數\u0026quot;時進行開關。 換句話說只要知道每個數字是奇數還是偶數就可以知道最後是亮還是暗了。\nFull code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool factorIsOdd(int n){ int cnt=0; for(int i=1;i\u0026lt;=n;i++){ cnt+=(n%i==0); } return cnt%2==1; } int bulbSwitch(int n) { int ans=0; for(int i=1;i\u0026lt;=n;i++){ ans+=factorIsOdd(i); } return ans; } Solution 1 方法一概念是正確的，但寫完會發現，TLE\u0026hellip;，題目給的 n 太大了。 回到剛剛的因數分解。 6 的因數有 1, 2, 3, 6，4 個 8 的因數有 1, 2, 4, 8，4 個 36 的因數有 1, 2, 3, 4, 6, 9, 12, 18, 36，9 個\n有沒有辦法取得\u0026quot;奇數個因數\u0026quot;的數， 所有的因數分解中，數字一定是成雙成對的，以 48 為例 1x48、2x24、3x16、4x12 \u0026hellip;etc\n那有沒有數字的因數中有成雙成對，但數量又是奇數的？ 數感好的話，應該會發現\u0026quot;平方數\u0026quot;的因數數量是奇數，以 16 為例。 1x16、2x8、\u0026ldquo;4x4\u0026rdquo; 因為平方數開根號的數就是自己 x 自己， 平方數因數量就會是奇數了（偶數組合與根號數）\nFull code 1 2 3 4 5 6 7 8 int bulbSwitch(int n) { int ans=0,root; for(int i=1;i\u0026lt;=n;i++){ root=sqrt(i); ans+=(i==root*root); } return ans; } Solution 2 方法二概念正確，但會發現你的執行速度不是 Beat100%\n想要追求極致的話，是否有方法比 O(n)還快？ 是否能透過計算取得 n 內的所有平方數數量？\nn=16 時，有 1, 4, 9, 16，四個 n=17 時，有 1, 4, 9, 16，四個 \u0026hellip; n=24 時，有 1, 4, 9, 16，四個 n=25 時，有 1, 4, 9, 16, 25，五個\n數感好的話，應該會發現，n=16~24 都是四個，n=25 才是五個，如果用開根號來計算的話： n=16 時，sqrt(n) = 4 n=17 時，sqrt(n) = 4.12 \u0026hellip; n=24 時，sqrt(n) = 4.89 n=25 時，sqrt(n) = 5\n因此只要對 n 直接開根號的話，就可以取得該數內的平方數了，又因為 funtion 的回傳型態是整數，更不用擔心被小數影響結果。\nFull code 1 2 3 int bulbSwitch(int n) { return sqrt(n); } ","permalink":"https://aura.codex.tw/posts/leetcode-writeup/leetcode-writeup-319-bulb-switcher/","summary":"\u003ch1 id=\"319-bulb-switcher\"\u003e319. \u003ca href=\"https://leetcode.com/problems/bulb-switcher/description/\"\u003eBulb Switcher\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e這題還蠻有趣的，有三個接續的概念，兩個可過的解法\u003c/p\u003e\n\u003ch1 id=\"idea-1-tle\"\u003eIdea 1 TLE\u003c/h1\u003e\n\u003cp\u003e換個問題問，是否有辦法知道每個燈泡會在何時開關\n開關次數是奇數最後會亮，偶數會暗，因此只要知道該燈泡是奇數次就可以知道最後是亮著了。\u003c/p\u003e\n\u003cp\u003e那怎麼知道每顆燈在何時會開關？\n第 6 顆燈泡為例，開關的時間點會在 1, 2, 3, 6 次觸發，偶數次是暗\n第 10 顆燈泡為例，開關的時間點會在 1, 2, 5, 10 次觸發，偶數次是暗\n第 36 顆燈泡為例，開關的時間點會在 1, 2, 3, 4, 6, 9, 12, 18, 36 次觸發，奇數次是亮\u003c/p\u003e\n\u003cp\u003e數感好的話，應該會發現第 n 顆燈泡會開關的時間點會是在 n 的\u0026quot;因數\u0026quot;時進行開關。\n換句話說只要知道每個數字是奇數還是偶數就可以知道最後是亮還是暗了。\u003c/p\u003e\n\u003ch2 id=\"full-code\"\u003eFull code\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003efactorIsOdd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"o\"\u003e+=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ebulbSwitch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"o\"\u003e+=\u003c/span\u003e\u003cspan class=\"n\"\u003efactorIsOdd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"solution-1\"\u003eSolution 1\u003c/h1\u003e\n\u003cp\u003e方法一概念是正確的，但寫完會發現，TLE\u0026hellip;，題目給的 n 太大了。\n回到剛剛的因數分解。\n6 的因數有 1, 2, 3, 6，4 個\n8 的因數有 1, 2, 4, 8，4 個\n36 的因數有 1, 2, 3, 4, 6, 9, 12, 18, 36，9 個\u003c/p\u003e","title":"LeetCode-Writeup 319. Bulb Switcher"},{"content":"Week1 205. Isomorphic Strings Leetcode Link My Solution\n1544. Make The String Great Leetcode Link My Solution\n1249. Minimum Remove to Make Valid Parentheses Leetcode Link My Solution\nWeek2 771. Jewels and Stones Leetcode Link My Solution\n42. Trapping Rain Water Leetcode Link My Solution\n404. Sum of Left Leaves Leetcode Link My Solution\n3114. Latest Time You Can Obtain After Replacing Characters Leetcode Link My Solution\n3115. Maximum Prime Difference Leetcode Link My Solution\nWeek3 129. Sum Root to Leaf Numbers Leetcode Link My Solution\n334. Increasing Triplet Subsequence Leetcode Link My Solution\n623. Add One Row to Tree Leetcode Link My Solution\n1732. Find the Highest Altitude Leetcode Link My Solution\n1207. Unique Number of Occurrences Leetcode Link My Solution\n700. Search in a Binary Search Tree Leetcode Link My Solution\n988. Smallest String Starting From Leaf Leetcode Link My Solution\n463. Island Perimeter Leetcode Link My Solution\n319. Bulb Switcher Leetcode Link My Solution\n200. Number of Islands Leetcode Link My Solution\n456. 132 Pattern Leetcode Link My Solution\n1992. Find All Groups of Farmland Leetcode Link My Solution\n3120. Count the Number of Special Characters I Leetcode Link My Solution\n3121. Count the Number of Special Characters II Leetcode Link My Solution\n139. Word Break Leetcode Link My Solution\n137. Single Number II Leetcode Link My Solution\n1971. Find if Path Exists in Graph Leetcode Link My Solution\nWeek4 310. Minimum Height Trees Leetcode Link My Solution\n1137. N-th Tribonacci Number Leetcode Link My Solution\n2370. Longest Ideal Subsequence Leetcode Link My Solution\n3131. Find the Integer Added to Array I Leetcode Link My Solution\n3132. Find the Integer Added to Array II Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2024-04/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"205-isomorphic-strings\"\u003e205. Isomorphic Strings\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/isomorphic-strings\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/205\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1544-make-the-string-great\"\u003e1544. Make The String Great\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/make-the-string-great\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1544\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1249-minimum-remove-to-make-valid-parentheses\"\u003e1249. Minimum Remove to Make Valid Parentheses\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1249\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"week2\"\u003eWeek2\u003c/h1\u003e\n\u003ch5 id=\"771-jewels-and-stones\"\u003e771. Jewels and Stones\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/jewels-and-stones\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/771\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"42-trapping-rain-water\"\u003e42. Trapping Rain Water\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/trapping-rain-water\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/42\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"404-sum-of-left-leaves\"\u003e404. Sum of Left Leaves\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/sum-of-left-leaves\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/404\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3114-latest-time-you-can-obtain-after-replacing-characters\"\u003e3114. Latest Time You Can Obtain After Replacing Characters\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/latest-time-you-can-obtain-after-replacing-characters\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3114\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3115-maximum-prime-difference\"\u003e3115. Maximum Prime Difference\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/maximum-prime-difference\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3115\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"week3\"\u003eWeek3\u003c/h1\u003e\n\u003ch5 id=\"129-sum-root-to-leaf-numbers\"\u003e129. Sum Root to Leaf Numbers\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/129\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2024/04"},{"content":"Week1 1750. Minimum Length of String After Deleting Similar Ends Leetcode Link My Solution\n876. Middle of the Linked List Leetcode Link My Solution\n141. Linked List Cycle Leetcode Link My Solution\n3005. Count Elements With Maximum Frequency Leetcode Link My Solution\n1768. Merge Strings Alternately Leetcode Link My Solution\n2540. Minimum Common Value Leetcode Link My Solution\n3074. Apple Redistribution into Boxes Leetcode Link My Solution\n3075. Maximize Happiness of Selected Children Leetcode Link My Solution\n3076. Shortest Uncommon Substring in an Array Leetcode Link My Solution\n349. Intersection of Two Arrays Leetcode Link My Solution\nWeek2 791. Custom Sort String Leetcode Link My Solution\n238. Product of Array Except Self Leetcode Link My Solution\nWeek3 452. Minimum Number of Arrows to Burst Balloons Leetcode Link My Solution\n1669. Merge In Between Linked Lists Leetcode Link My Solution\n206. Reverse Linked List Leetcode Link My Solution\n143. Reorder List Leetcode Link My Solution\n287. Find the Duplicate Number Leetcode Link My Solution\n442. Find All Duplicates in an Array Leetcode Link My Solution\nWeek4 41. First Missing Positive Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2024-03/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"1750-minimum-length-of-string-after-deleting-similar-ends\"\u003e1750. Minimum Length of String After Deleting Similar Ends\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1750\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"876-middle-of-the-linked-list\"\u003e876. Middle of the Linked List\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/middle-of-the-linked-list/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/876\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"141-linked-list-cycle\"\u003e141. Linked List Cycle\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/linked-list-cycle/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/141\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3005-count-elements-with-maximum-frequency\"\u003e3005. Count Elements With Maximum Frequency\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/count-elements-with-maximum-frequency/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3005\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1768-merge-strings-alternately\"\u003e1768. Merge Strings Alternately\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/merge-strings-alternately/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1768\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2540-minimum-common-value\"\u003e2540. Minimum Common Value\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-common-value/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2540\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3074-apple-redistribution-into-boxes\"\u003e3074. Apple Redistribution into Boxes\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/apple-redistribution-into-boxes/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3074\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3075-maximize-happiness-of-selected-children\"\u003e3075. Maximize Happiness of Selected Children\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/maximize-happiness-of-selected-children/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3075\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"3076-shortest-uncommon-substring-in-an-array\"\u003e3076. Shortest Uncommon Substring in an Array\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/shortest-uncommon-substring-in-an-array/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/3076\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2024/03"},{"content":"Basic Clone a repo 1 git clone {url.git} Add some files 1 git add {filename} Get commit history 1 git log Commit 1 git commit -m \u0026#34;text\u0026#34; Pull 1 git pull Push 1 git push {branch-name} Branch Get now branch and all branch list 1 git branch Create branch 1 git branch {branch-name} Branch Naming Example 1 2 3 4 5 6 git branch feat/{id}-xxx # add new feature git branch fix/{id}-xxx # fix some bugs git branch refactor/{id}-xxx # Refactor the code git branch docs/{id}-xxx # Update Files git branch style/{id}-xxx # Coding style, formatter git branch chore/{id}-xxx # Change working process, tools ...etc Switch branch 1 2 git switch {branch-name} git switch -c {branch-name} # if branch not exist, auto create Merge branch 1 2 3 git switch {Target-branch-name} git merge {branch-name} git push origin {Target-branch-name} checkout check commit and files 1 2 3 git checkout {commit-id} git checkout {commit-id} -- {file-path} git checkout main With Docker Login ghcr.io with docker on terminal Get a \u0026ldquo;personal access token (classic)\u0026rdquo; from Developer Page\nlogin by terminal\n1 2 export CR_PAT=ghp_xxxxx echo $CR_PAT | docker login ghcr.io -u {Github ID} --password-stdin ","permalink":"https://aura.codex.tw/posts/github-tutorial/","summary":"\u003ch1 id=\"basic\"\u003eBasic\u003c/h1\u003e\n\u003ch2 id=\"clone-a-repo\"\u003eClone a repo\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone \u003cspan class=\"o\"\u003e{\u003c/span\u003eurl.git\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"add-some-files\"\u003eAdd some files\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add \u003cspan class=\"o\"\u003e{\u003c/span\u003efilename\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"get-commit-history\"\u003eGet commit history\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"commit\"\u003eCommit\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit -m \u003cspan class=\"s2\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"pull\"\u003ePull\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit pull\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"push\"\u003ePush\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit push \u003cspan class=\"o\"\u003e{\u003c/span\u003ebranch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"branch\"\u003eBranch\u003c/h1\u003e\n\u003ch2 id=\"get-now-branch-and-all-branch-list\"\u003eGet now branch and all branch list\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"create-branch\"\u003eCreate branch\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch \u003cspan class=\"o\"\u003e{\u003c/span\u003ebranch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"branch-naming-example\"\u003eBranch Naming Example\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch feat/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx   \u003cspan class=\"c1\"\u003e# add new feature\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch fix/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx    \u003cspan class=\"c1\"\u003e# fix some bugs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch refactor/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx \u003cspan class=\"c1\"\u003e# Refactor the code\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch docs/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx   \u003cspan class=\"c1\"\u003e# Update Files\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch style/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx  \u003cspan class=\"c1\"\u003e# Coding style, formatter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit branch chore/\u003cspan class=\"o\"\u003e{\u003c/span\u003eid\u003cspan class=\"o\"\u003e}\u003c/span\u003e-xxx  \u003cspan class=\"c1\"\u003e# Change working process, tools ...etc\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"switch-branch\"\u003eSwitch branch\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit switch \u003cspan class=\"o\"\u003e{\u003c/span\u003ebranch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit switch -c \u003cspan class=\"o\"\u003e{\u003c/span\u003ebranch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e# if branch not exist, auto create\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"merge-branch\"\u003eMerge branch\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit switch \u003cspan class=\"o\"\u003e{\u003c/span\u003eTarget-branch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit merge \u003cspan class=\"o\"\u003e{\u003c/span\u003ebranch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit push origin \u003cspan class=\"o\"\u003e{\u003c/span\u003eTarget-branch-name\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"checkout\"\u003echeckout\u003c/h1\u003e\n\u003ch2 id=\"check-commit-and-files\"\u003echeck commit and files\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout \u003cspan class=\"o\"\u003e{\u003c/span\u003ecommit-id\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout \u003cspan class=\"o\"\u003e{\u003c/span\u003ecommit-id\u003cspan class=\"o\"\u003e}\u003c/span\u003e -- \u003cspan class=\"o\"\u003e{\u003c/span\u003efile-path\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout main\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"with-docker\"\u003eWith Docker\u003c/h1\u003e\n\u003ch2 id=\"login-ghcrio-with-docker-on-terminal\"\u003eLogin ghcr.io with docker on terminal\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eGet a \u0026ldquo;personal access token (classic)\u0026rdquo; from \u003ca href=\"https://github.com/settings/tokens\"\u003eDeveloper Page\u003c/a\u003e\u003c/p\u003e","title":"Github Tutorial"},{"content":"Week1 1768. Merge Strings Alternately Leetcode Link My Solution\n1071. Greatest Common Divisor of Strings Leetcode Link My Solution\n1431. Kids With the Greatest Number of Candies Leetcode Link My Solution\n605. Can Place Flowers Leetcode Link My Solution\n345. Reverse Vowels of a String Leetcode Link My Solution\n151. Reverse Words in a String Leetcode Link My Solution\n2917. Find the K-or of an Array Leetcode Link My Solution\n2918. Minimum Equal Sum of Two Arrays After Replacing Zeros Leetcode Link My Solution\nWeek2 283. Move Zeroes Leetcode Link My Solution\n392. Is Subsequence Leetcode Link My Solution\n643. Maximum Average Subarray I Leetcode Link My Solution\n1732. Find the Highest Altitude Leetcode Link My Solution\n724. Find Pivot Index Leetcode Link My Solution\n238. Product of Array Except Self Leetcode Link My Solution\n2923. Find Champion I Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2023-11/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"1768-merge-strings-alternately\"\u003e1768. Merge Strings Alternately\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/merge-strings-alternately/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1768\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1071-greatest-common-divisor-of-strings\"\u003e1071. Greatest Common Divisor of Strings\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/greatest-common-divisor-of-strings/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1071\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1431-kids-with-the-greatest-number-of-candies\"\u003e1431. Kids With the Greatest Number of Candies\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1431\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"605-can-place-flowers\"\u003e605. Can Place Flowers\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/can-place-flowers/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/605\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"345-reverse-vowels-of-a-string\"\u003e345. Reverse Vowels of a String\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/reverse-vowels-of-a-string/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/345\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"151-reverse-words-in-a-string\"\u003e151. Reverse Words in a String\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/reverse-words-in-a-string/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/151\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2917-find-the-k-or-of-an-array\"\u003e2917. Find the K-or of an Array\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-the-k-or-of-an-array/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2917\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2918-minimum-equal-sum-of-two-arrays-after-replacing-zeros\"\u003e2918. Minimum Equal Sum of Two Arrays After Replacing Zeros\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2918\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2023/11"},{"content":"Week1 2413. Smallest Even Multiple Leetcode Link My Solution\n2409. Count Days Spent Together Leetcode Link My Solution\n2455. Average Value of Even Numbers That Are Divisible by Three Leetcode Link My Solution\n2485. Find the Pivot Integer Leetcode Link My Solution\n2465. Number of Distinct Averages Leetcode Link My Solution\n2264. Largest 3-Same-Digit Number in String Leetcode Link My Solution\n2367. Number of Arithmetic Triplets Leetcode Link My Solution\n2395. Find Subarrays With Equal Sum Leetcode Link My Solution\n2605. Form Smallest Number From Two Digit Arrays Leetcode Link My Solution\n2843. Count Symmetric Integers Leetcode Link My Solution\n50. pow(x, n) Leetcode Link My Solution\n260. Single Number III Leetcode Link My Solution\n309. Best Time to Buy and Sell Stock with Cooldown Leetcode Link My Solution\n2873. Maximum Value of an Ordered Triplet I Leetcode Link My Solution\n2875. Minimum Size Subarray in Infinite Array Leetcode Link My Solution\n2894. Divisible and Non-divisible Sums Difference Leetcode Link My Solution\n2895. Minimum Processing Time Leetcode Link My Solution\nWeek2 2469. Convert the Temperature Leetcode Link My Solution\n2432. The Employee That Worked on the Longest Task Leetcode Link My Solution\n2578. Split With Minimum Sum Leetcode Link My Solution\n2481. Minimum Cuts to Divide a Circle Leetcode Link My Solution\n2639. Find the Width of Columns of a Grid Leetcode Link My Solution\n1093. Statistics from a Large Sample Leetcode Link My Solution\n2903. Find Indices With Index and Value Difference I Leetcode Link My Solution\n2904. Shortest and Lexicographically Smallest Beautiful String Leetcode Link My Solution\n2905. Find Indices With Index and Value Difference II Leetcode Link My Solution\n2906. Construct Product Matrix Leetcode Link My Solution\nWeek3 2000. Reverse Prefix of Word Leetcode Link My Solution\n2287. Rearrange Characters to Make Target String Leetcode Link My Solution\n1848. Minimum Distance to the Target Element Leetcode Link My Solution\n2562. Find the Array Concatenation Value Leetcode Link My Solution\n2108. Find First Palindromic String in the Array Leetcode Link My Solution\n1315. Sum of Nodes with Even-Valued Grandparent Leetcode Link My Solution\n2908. Minimum Sum of Mountain Triplets I Leetcode Link My Solution\n2909. Minimum Sum of Mountain Triplets II Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2023-10/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"2413-smallest-even-multiple\"\u003e2413. Smallest Even Multiple\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/smallest-even-multiple/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2413\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2409-count-days-spent-together\"\u003e2409. Count Days Spent Together\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/count-days-spent-together/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2409\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2455-average-value-of-even-numbers-that-are-divisible-by-three\"\u003e2455. Average Value of Even Numbers That Are Divisible by Three\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2455\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2485-find-the-pivot-integer\"\u003e2485. Find the Pivot Integer\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-the-pivot-integer/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2485\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2465-number-of-distinct-averages\"\u003e2465. Number of Distinct Averages\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/number-of-distinct-averages/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2465\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2264-largest-3-same-digit-number-in-string\"\u003e2264. Largest 3-Same-Digit Number in String\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/largest-3-same-digit-number-in-string/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2264\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2367-number-of-arithmetic-triplets\"\u003e2367. Number of Arithmetic Triplets\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/number-of-arithmetic-triplets/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2367\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2395-find-subarrays-with-equal-sum\"\u003e2395. Find Subarrays With Equal Sum\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-subarrays-with-equal-sum/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2395\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2023/10"},{"content":"Week1 2341. Maximum Number of Pairs in Array Leetcode Link My Solution\n2331. Evaluate Boolean Binary Tree Leetcode Link My Solution\n2500. Delete Greatest Value in Each Row Leetcode Link My Solution\n2744. Find Maximum Number of String Pairs Leetcode Link My Solution\n2833. Furthest Point From Origin Leetcode Link My Solution\n2834. Find the Minimum Possible Sum of a Beautiful Array Leetcode Link My Solution\nWeek2 404. Sum of Left Leaves Leetcode Link My Solution\n263. Ugly Number Leetcode Link My Solution\n448. Find All Numbers Disappeared in an Array Leetcode Link My Solution\n653. Two Sum IV - Input is a BST Leetcode Link My Solution\n1010. Pairs of Songs With Total Durations Divisible by 60 Leetcode Link My Solution\n2848. Points That Intersect With Cars Leetcode Link My Solution\n2849. Determine if a Cell Is Reachable at a Given Time Leetcode Link My Solution\nWeek3 1078. Occurrences After Bigram Leetcode Link My Solution\n2582. Pass the Pillow Leetcode Link My Solution\n2586. Count the Number of Vowel Strings in Range Leetcode Link My Solution\n2855. Minimum Right Shifts to Sort the Array Leetcode Link My Solution\n240. Search a 2D Matrix II Leetcode Link My Solution\n2859. Sum of Values at Indices With K Set Bits Leetcode Link My Solution\n2860. Happy Students Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2023-09/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"2341-maximum-number-of-pairs-in-array\"\u003e2341. Maximum Number of Pairs in Array\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/maximum-number-of-pairs-in-array/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2341\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2331-evaluate-boolean-binary-tree\"\u003e2331. Evaluate Boolean Binary Tree\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/evaluate-boolean-binary-tree/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2331\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2500-delete-greatest-value-in-each-row\"\u003e2500. Delete Greatest Value in Each Row\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/delete-greatest-value-in-each-row/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2500\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2744-find-maximum-number-of-string-pairs\"\u003e2744. Find Maximum Number of String Pairs\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-maximum-number-of-string-pairs/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2744\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2833-furthest-point-from-origin\"\u003e2833. Furthest Point From Origin\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/furthest-point-from-origin/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2833\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2834-find-the-minimum-possible-sum-of-a-beautiful-array\"\u003e2834. Find the Minimum Possible Sum of a Beautiful Array\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2834\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"week2\"\u003eWeek2\u003c/h1\u003e\n\u003ch5 id=\"404-sum-of-left-leaves\"\u003e404. Sum of Left Leaves\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/sum-of-left-leaves/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/404\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"263-ugly-number\"\u003e263. Ugly Number\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/ugly-number/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/263\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2023/09"},{"content":"連結 Github\n重點專案結構 whisper-hakka ┗┳━ custom_data ┃ ┗━ data_prep.py 資料檢查、產生binary檔案 ┣━ data-char 放字單位的文本 ┃ ┣━ dev ┃ ┃ ┣━ audio_paths symbolic link to wav.scp ┃ ┃ ┣━ spk2utt 語者ID與其語料ID ┃ ┃ ┣━ text 語料ID與語料文本 ┃ ┃ ┣━ utt2spk 語料ID與其語者ID ┃ ┃ ┗━ wav.scp 語料ID與語料路徑 ┃ ┣━ test ┃ ┃ ┗━ 同(dev) ┃ ┗━ train ┃ ┗━ 同(dev) ┣━ data-pinyin 放詞單位的文本 ┃ ┗━ 同(data-char) ┣━ evaluate ┃ ┗━ evaluate_on_custom_dataset.py 驗證腳本 ┣━ train ┃ ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本 ┃ ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本 ┣━ requirements.txt library套件 ┗━ run.sh 所有會執行的指令 安裝虛擬環境 建議用虛擬環境 virtual environment 建置 python 環境，可以避免原始套件衝突。\n# 建立虛擬環境 # python3 -m venv name-of-venv python3 -m venv env # 啟動虛擬環境 source env/bin/activate 當成功使用虛擬環境時，命令列左側會顯示在虛擬環境中。\n# before user@SERVER:/path-to-project$ # after (env) user@SERVER:/path-to-project$ 安裝 Python 套件 python3 -m pip install --upgrade pip pip install -r requirements.txt 資料準備 接著進行資料準備，所有集合都放在data-char底下，一個資料夾為一個集合。 需準備的資料有： text\nID_1 text-in-ID_1 ID_2 text-in-ID_2 ID_3 text-in-ID_3 wav.scp\nID_1 path-to-ID_1 ID_2 path-to-ID_2 ID_3 path-to-ID_3 建議data-char放中文字的 text(字為單位)，data-pinyin放英文字的 text(詞為單位)。\n接下來可以使用run.sh內的指令進行驗證，執行後會在output_data_dir的地方放生成後的 binary 檔案。\npython3 custom_data/data_prep.py \\ --source_data_dir path-to-your-location \\ --output_data_dir path-to-your-data-location Ex: python3 custom_data/data_prep.py \\ --source_data_dir data-pinyin/train \\ --output_data_dir output_data-pinyin/train 如果輸出Data preparation done代表沒問題，可以進行下一步。\n開始訓練 資料準備完成後，即可進行訓練，可以執行以下指令(以字元為例) nproc_per_node為 GPU 數量\ntorchrun --nproc_per_node=1 train/fine-tune_on_custom_dataset.py \\ --model_name openai/whisper-base \\ # 基礎模型 --language zh \\ # 調適的語言 --sampling_rate 16000 \\ # 取樣率 --num_proc 4 \\ # 同時只用多少CPU核心執行取樣轉換，越快越好 --train_strategy epoch \\ # 訓練週期單位(epoch/steps) --learning_rate 6.25e-6 \\ # 學習率 --warmup 1000 \\ --train_batchsize 12 \\ # 訓練batch --eval_batchsize 6 \\ # 驗證batch --num_epochs 20 \\ # 訓練週期數 --resume_from_ckpt None \\ --output_dir op_dir_epoch-char \\ # 輸出路徑資料夾名，記得修改，不然容易忘記 --train_datasets output_data-char/train \\ # 訓練集路徑 --eval_datasets output_data-char/dev # 驗證集路徑 完成訓練後，可以透過終端上每個checkpoint的 WER 去評估哪個模型比較好。\n訓練好的模型資料結構(僅說明重點) 以預設名op_dir_epoch-char舉例\nwhisper-hakka ┗━━ op_dir_epoch-char ┣━ checkpoint-(num) ┃ ┣━ config.json 參數檔 ┃ ┗━ pytorch_model.bin 模型 ┣━ 每個checkpoint資料夾內的檔案 ┗━ README.md 訓練狀態 測試 選擇好最好的 checkpoint 後，就可以進行測試看看該模型效果如何，通常 checkpoint 前 3 名都有機會有好的結果，不一定會是 checkpoint 最好的為最好模型。\npython3 evaluate/evaluate_on_custom_dataset.py \\ --is_public_repo False \\ --ckpt_dir \u0026#34;op_dir_epoch-char/checkpoint\u0026#34; \\ # checkpoint路徑 --temp_ckpt_folder \u0026#34;temp-char\u0026#34; \\ # 暫存位置 --language zh \\ # 語言 --eval_datasets output_data-char/test \\ # 測試集路徑 --device 0 \\ --batch_size 8 \\ # 測試batch --output_dir predictions_dir-char # 測試後輸出檔案 測試後即可跟去輸出的 WER(詞錯誤率)與 CER(字錯誤率)去選擇最好的模型。\n輸出模型 此腳本並無提供模型輸出的指令，可以使用以下我寫的程式碼：\n1 2 3 4 5 from multiple_datasets.hub_default_utils import convert_hf_whisper model_name_or_path = \u0026#39;path-to-checkpoint\u0026#39; whisper_checkpoint_path = \u0026#39;model-name.pt\u0026#39; convert_hf_whisper(model_name_or_path, whisper_checkpoint_path) 此方法生成的模型可以使用在 python 的 whisper 套件。\n","permalink":"https://aura.codex.tw/posts/openai-whisper-fine-tuning-script-by-fsr2023/","summary":"\u003ch1 id=\"連結\"\u003e連結\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/yfliao/whisper-hakka\"\u003eGithub\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"重點專案結構\"\u003e重點專案結構\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewhisper-hakka\n ┗┳━ custom_data\n  ┃   ┗━ data_prep.py 資料檢查、產生binary檔案\n  ┣━ data-char 放字單位的文本\n  ┃   ┣━ dev\n  ┃   ┃   ┣━ audio_paths symbolic link to wav.scp\n  ┃   ┃   ┣━ spk2utt 語者ID與其語料ID\n  ┃   ┃   ┣━ text    語料ID與語料文本\n  ┃   ┃   ┣━ utt2spk 語料ID與其語者ID\n  ┃   ┃   ┗━ wav.scp 語料ID與語料路徑\n  ┃   ┣━ test\n  ┃   ┃   ┗━ 同(dev)\n  ┃   ┗━ train\n  ┃       ┗━ 同(dev)\n  ┣━ data-pinyin 放詞單位的文本\n  ┃   ┗━ 同(data-char)\n  ┣━ evaluate\n  ┃   ┗━ evaluate_on_custom_dataset.py 驗證腳本\n  ┣━ train\n  ┃   ┣━ fine-tune_on_custom_dataset.py 使用本地語料訓練腳本\n  ┃   ┗━ fine-tune_on_hf_dataset.py 使用huggingface語料訓練腳本\n  ┣━ requirements.txt library套件\n  ┗━ run.sh 所有會執行的指令\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"安裝虛擬環境\"\u003e安裝虛擬環境\u003c/h1\u003e\n\u003cp\u003e建議用虛擬環境 virtual environment 建置 python 環境，可以避免原始套件衝突。\u003c/p\u003e","title":"Openai Whisper Fine-Tuning Script by FSR2023"},{"content":"Week1 108. Convert Sorted Array to Binary Search Tree Leetcode Link My Solution\n303. Range Sum Query - Immutable Leetcode Link My Solution\n202. Happy Number Leetcode Link My Solution\n232. Implement Queue using Stacks Leetcode Link My Solution\n2162. Minimum Cost to Set Cooking Time Leetcode Link My Solution\n2810. Faulty Keyboard Leetcode Link My Solution\n2811. Check if it is Possible to Split Array Leetcode Link My Solution\n2812. Find the Safest Path in a Grid Leetcode Link My Solution\n2813. Maximum Elegance of a K-Length Subsequence Leetcode Link My Solution\nWeek2 2441. Largest Positive Integer That Exists With Its Negative Leetcode Link My Solution\n2520. Count the Digits That Divide a Number Leetcode Link My Solution\n2299. Strong Password Checker II Leetcode Link My Solution\n2423. Remove Letter To Equalize Frequency Leetcode Link My Solution\n957. Prison Cells After N Days Leetcode Link My Solution\n900. RLE Iterator Leetcode Link My Solution\n2815. Max Pair Sum in an Array Leetcode Link My Solution\n2816. Double a Number Represented as a Linked List Leetcode Link My Solution\nWeek3 1929. Concatenation of Array Leetcode Link My Solution\n1886. Determine Whether Matrix Can Be Obtained By Rotation Leetcode Link My Solution\n1752. Check if Array Is Sorted and Rotated Leetcode Link My Solution\n1518. Water Bottles Leetcode Link My Solution\n57. Insert Interval Leetcode Link My Solution\n229. Majority Element II Leetcode Link My Solution\n2828. Check if a String Is an Acronym of Words Leetcode Link My Solution\n2829. Determine the Minimum Sum of a k-avoiding Array Leetcode Link My Solution\n2831. Find the Longest Equal Subarray Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2023-08/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"108-convert-sorted-array-to-binary-search-tree\"\u003e108. Convert Sorted Array to Binary Search Tree\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/108\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"303-range-sum-query---immutable\"\u003e303. Range Sum Query - Immutable\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/range-sum-query-immutable/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/303\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"202-happy-number\"\u003e202. Happy Number\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/happy-number/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/202\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"232-implement-queue-using-stacks\"\u003e232. Implement Queue using Stacks\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/implement-queue-using-stacks/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/232\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2162-minimum-cost-to-set-cooking-time\"\u003e2162. Minimum Cost to Set Cooking Time\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/minimum-cost-to-set-cooking-time/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2162\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2810-faulty-keyboard\"\u003e2810. Faulty Keyboard\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/faulty-keyboard/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2810\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2811-check-if-it-is-possible-to-split-array\"\u003e2811. Check if it is Possible to Split Array\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/check-if-it-is-possible-to-split-array/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2811\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2812-find-the-safest-path-in-a-grid\"\u003e2812. Find the Safest Path in a Grid\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-the-safest-path-in-a-grid/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2812\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2023/08"},{"content":"連結 Github\n重點專案結構 whisper_hakka ┗┳━ audio ┃ ┣━ test ┃ ┃ ┗━ test語料存放區 ┃ ┣━ train ┃ ┃ ┗━ train語料存放區 ┃ ┗━ metadata.csv 檔案路徑與文本內容 ┣━ model ┃ ┗━ 模型存放區 ┣━ fine_tune.ipynb jupyter訓練腳本 ┗━ huggingface_token huggingfacer金鑰 安裝 cuda cuda wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.run sudo sh cuda_11.4.0_470.42.01_linux.run 如果要獨立裝 driver，就把 driver 取消\ndriver sudo apt-get install nvidia-driver-470 Huggingface 金鑰申請 請到huggingface 官網 右上的選項 → Settings → Access Tokens 點選New token，Name自訂，Role選write Generate a token後，將產生的token複製貼上到專案的huggingface_token\n程式碼說明 建立模型名稱 請輸入檔案名稱\n1 model_name=\u0026#39;model name\u0026#39; 登入 hugging face 將訓練完成的模型上傳到存放在 huggingface，可以減少本地端空間占用。 Token請自行去 huggingface 申請\n1 2 3 from huggingface_hub.hf_api import HfFolder token=open(\u0026#39;huggingface_token\u0026#39;,\u0026#39;r\u0026#39;).readlines()[0].split(\u0026#39;\\n\u0026#39;)[0] HfFolder.save_token(token) 載入音檔資料 會從data_dir底下拉語料進行使用\n1 2 3 4 from datasets import load_dataset common_voice = load_dataset(\u0026#34;./\u0026#34;, data_dir=\u0026#34;audio\u0026#34;,use_auth_token=True) # 可以使用以下程式碼查看dataset結構 print(common_voice) 載入 Openai 建立好的模型 使用 openai 提供的基礎模型，模型大小或語言，請自行更換\n1 2 3 4 from transformers import WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessor feature_extractor = WhisperFeatureExtractor.from_pretrained(\u0026#34;openai/whisper-base\u0026#34;) tokenizer = WhisperTokenizer.from_pretrained(\u0026#34;openai/whisper-base\u0026#34;, language=\u0026#34;zh\u0026#34;, task=\u0026#34;transcribe\u0026#34;) processor = WhisperProcessor.from_pretrained(\u0026#34;openai/whisper-base\u0026#34;, language=\u0026#34;zh\u0026#34;, task=\u0026#34;transcribe\u0026#34;) 語料轉換取樣率 音檔取樣率轉換成 16000HkHz\n1 2 3 4 5 6 7 8 9 10 from datasets import Audio common_voice = common_voice.cast_column(\u0026#34;audio\u0026#34;, Audio(sampling_rate=16000)) def prepare_dataset(batch): audio = batch[\u0026#34;audio\u0026#34;] batch[\u0026#34;input_features\u0026#34;] = feature_extractor(audio[\u0026#34;array\u0026#34;], sampling_rate=audio[\u0026#34;sampling_rate\u0026#34;]).input_features[0] batch[\u0026#34;labels\u0026#34;] = tokenizer(batch[\u0026#34;sentence\u0026#34;]).input_ids return batch common_voice = common_voice.map(prepare_dataset, remove_columns=common_voice.column_names[\u0026#34;train\u0026#34;], num_proc=2) data_collator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import torch from dataclasses import dataclass from typing import Any, Dict, List, Union @dataclass class DataCollatorSpeechSeq2SeqWithPadding: processor: Any def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -\u0026gt; Dict[str, torch.Tensor]: # split inputs and labels since they have to be of different lengths and need different padding methods # first treat the audio inputs by simply returning torch tensors input_features = [{\u0026#34;input_features\u0026#34;: feature[\u0026#34;input_features\u0026#34;]} for feature in features] batch = self.processor.feature_extractor.pad(input_features, return_tensors=\u0026#34;pt\u0026#34;) # get the tokenized label sequences label_features = [{\u0026#34;input_ids\u0026#34;: feature[\u0026#34;labels\u0026#34;]} for feature in features] # pad the labels to max length labels_batch = self.processor.tokenizer.pad(label_features, return_tensors=\u0026#34;pt\u0026#34;) # replace padding with -100 to ignore loss correctly labels = labels_batch[\u0026#34;input_ids\u0026#34;].masked_fill(labels_batch.attention_mask.ne(1), -100) # if bos token is appended in previous tokenization step, # cut bos token here as it\u0026#39;s append later anyways if (labels[:, 0] == self.processor.tokenizer.bos_token_id).all().cpu().item(): labels = labels[:, 1:] batch[\u0026#34;labels\u0026#34;] = labels return batch data_collator = DataCollatorSpeechSeq2SeqWithPadding(processor=processor) compute_metrics 計算 CER(或 WER)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import evaluate metric = evaluate.load(\u0026#34;cer\u0026#34;) def compute_metrics(pred): pred_ids = pred.predictions label_ids = pred.label_ids # replace -100 with the pad_token_id label_ids[label_ids == -100] = tokenizer.pad_token_id # we do not want to group tokens when computing the metrics pred_str = tokenizer.batch_decode(pred_ids, skip_special_tokens=True) label_str = tokenizer.batch_decode(label_ids, skip_special_tokens=True) cer = 100 * metric.compute(predictions=pred_str, references=label_str) return {\u0026#34;cer\u0026#34;: cer} model 1 2 3 4 5 from transformers import WhisperForConditionalGeneration model = WhisperForConditionalGeneration.from_pretrained(\u0026#34;openai/whisper-base\u0026#34;) model.config.forced_decoder_ids = None model.config.suppress_tokens = [] training_args 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from transformers import Seq2SeqTrainingArguments training_args = Seq2SeqTrainingArguments( output_dir=\u0026#34;./model_name\u0026#34;, # 模型名稱，你需要更改 per_device_train_batch_size=16, # 批次大小，你可能會需要調整 gradient_accumulation_steps=1, learning_rate=1e-5, # 學習率，你可能會需要調整 warmup_steps=500, max_steps=4000, # 訓練次數，你可能會需要調整 gradient_checkpointing=True, fp16=True, evaluation_strategy=\u0026#34;steps\u0026#34;, per_device_eval_batch_size=8, predict_with_generate=True, generation_max_length=225, save_steps=1000, eval_steps=1000, logging_steps=25, report_to=[\u0026#34;tensorboard\u0026#34;], load_best_model_at_end=True, metric_for_best_model=\u0026#34;cer\u0026#34;, greater_is_better=False, push_to_hub=True, ) trainer 1 2 3 4 5 6 7 8 9 10 11 12 13 from transformers import Seq2SeqTrainer trainer = Seq2SeqTrainer( args=training_args, model=model, train_dataset=common_voice[\u0026#34;train\u0026#34;], eval_dataset=common_voice[\u0026#34;test\u0026#34;], data_collator=data_collator, compute_metrics=compute_metrics, tokenizer=processor.feature_extractor, ) processor.save_pretrained(training_args.output_dir) 開始訓練 1 trainer.train() 從本地上傳模型到 HuggingFace 1 2 3 4 5 6 7 8 9 10 11 12 kwargs = { \u0026#34;dataset_tags\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;dataset\u0026#34;: \u0026#34;some hakka audio\u0026#34;, # 輸入資料及名稱 \u0026#34;dataset_args\u0026#34;: \u0026#34;config: zh, split: test\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;zh\u0026#34;, \u0026#34;model_name\u0026#34;: \u0026#34;a name\u0026#34;, # 輸入模型名稱 \u0026#34;finetuned_from\u0026#34;: \u0026#34;openai/whisper-base\u0026#34;, # 基礎模型 \u0026#34;tasks\u0026#34;: \u0026#34;automatic-speech-recognition\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;whisper\u0026#34;, } trainer.push_to_hub(**kwargs) 從 HuggingFace 下載模型 你需要更改要下載 model 的位置與存放位置\n1 2 3 4 5 6 from multiple_datasets.hub_default_utils import convert_hf_whisper model_name_or_path = \u0026#39;model_name_on_hugging_face\u0026#39; whisper_checkpoint_path = \u0026#39;save_model_path\u0026#39; convert_hf_whisper(model_name_or_path, whisper_checkpoint_path) reference https://colab.research.google.com/github/sanchit-gandhi/notebooks/blob/main/fine_tune_whisper.ipynb#scrollTo=810ced54-7187-4a06-b2fe-ba6dcca94dc3 https://colab.research.google.com/drive/1RkboArXsuXIEDTE5OHfJe-0Gn7v3gXI1?usp=sharing#scrollTo=-hxbi4vVPpoy https://wandb.ai/parambharat/whisper_finetuning/reports/Fine-tuning-Whisper-ASR-models---VmlldzozMTEzNDE5 https://huggingface.co/jlondonobo/whisper-medium-pt https://github.com/bayartsogt-ya/whisper-multiple-hf-datasets https://github.com/luigisaetta/whisper-app/blob/main/match_layers.ipynb https://www.mlq.ai/openai-whisper-gpt-3-fine-tuning-youtube-video/ https://stackoverflow.com/questions/71561761/how-to-load-a-fine-tuned-pytorch-huggingface-bert-model-from-a-checkpoint-file https://colab.research.google.com/drive/1P4ClLkPmfsaKn2tBbRp0nVjGMRKR-EWz https://huggingface.co/spaces/openai/whisper/discussions/6 https://huggingface.co/blog/fine-tune-whisper https://github.com/openai/whisper/discussions/98\n","permalink":"https://aura.codex.tw/posts/openai-whisper-fine-tuning-hakka/","summary":"\u003ch1 id=\"連結\"\u003e連結\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/AU2A/whisper_finetuning\"\u003eGithub\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"重點專案結構\"\u003e重點專案結構\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewhisper_hakka\n ┗┳━ audio\n  ┃   ┣━ test\n  ┃   ┃   ┗━ test語料存放區\n  ┃   ┣━ train\n  ┃   ┃   ┗━ train語料存放區\n  ┃   ┗━ metadata.csv 檔案路徑與文本內容\n  ┣━ model\n  ┃   ┗━ 模型存放區\n  ┣━ fine_tune.ipynb jupyter訓練腳本\n  ┗━ huggingface_token huggingfacer金鑰\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"安裝-cuda\"\u003e安裝 cuda\u003c/h1\u003e\n\u003ch4 id=\"cuda\"\u003ecuda\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.run\nsudo sh cuda_11.4.0_470.42.01_linux.run\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果要獨立裝 driver，就把 driver 取消\u003c/p\u003e\n\u003ch4 id=\"driver\"\u003edriver\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt-get install nvidia-driver-470\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"huggingface-金鑰申請\"\u003eHuggingface 金鑰申請\u003c/h1\u003e\n\u003cp\u003e請到\u003ca href=\"https://huggingface.co/\"\u003ehuggingface 官網\u003c/a\u003e\n右上的選項 → \u003ccode\u003eSettings\u003c/code\u003e → \u003ccode\u003eAccess Tokens\u003c/code\u003e\n點選\u003ccode\u003eNew token\u003c/code\u003e，\u003ccode\u003eName\u003c/code\u003e自訂，\u003ccode\u003eRole\u003c/code\u003e選\u003ccode\u003ewrite\u003c/code\u003e\n\u003ccode\u003eGenerate a token\u003c/code\u003e後，將產生的\u003ccode\u003etoken\u003c/code\u003e複製貼上到專案的\u003ccode\u003ehuggingface_token\u003c/code\u003e\u003c/p\u003e\n\u003ch1 id=\"程式碼說明\"\u003e程式碼說明\u003c/h1\u003e\n\u003ch4 id=\"建立模型名稱\"\u003e建立模型名稱\u003c/h4\u003e\n\u003cp\u003e請輸入檔案名稱\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emodel_name\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;model name\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"登入-hugging-face\"\u003e登入 hugging face\u003c/h4\u003e\n\u003cp\u003e將訓練完成的模型上傳到存放在 huggingface，可以減少本地端空間占用。\n\u003ccode\u003eToken\u003c/code\u003e請自行去 huggingface 申請\u003c/p\u003e","title":"Openai Whisper Fine-Tuning - Hakka"},{"content":"Week1 1232. Check If It Is a Straight Line Leetcode Link My Solution\n1071. Greatest Common Divisor of Strings Leetcode Link My Solution\n1160. Find Words That Can Be Formed by Characters Leetcode Link My Solution\n1323. Maximum 69 Number Leetcode Link My Solution\n858. Mirror Reflection Leetcode Link My Solution\n946. Validate Stack Sequences Leetcode Link My Solution\n2748. Number of Beautiful Pairs Leetcode Link My Solution\n2750. Ways to Split Array Into Good Subarrays Leetcode Link My Solution\nWeek2 2418. Sort the People Leetcode Link My Solution\n2437. Number of Valid Clock Times Leetcode Link My Solution\n2383. Minimum Hours of Training to Win a Competition Leetcode Link My Solution\n2363. Merge Similar Items Leetcode Link My Solution\n2461. Maximum Sum of Distinct Subarrays With Length K Leetcode Link My Solution\n2419. Longest Subarray With Maximum Bitwise AND Leetcode Link My Solution\n2760. Longest Even Odd Subarray With Threshold Leetcode Link My Solution\n2761. Prime Pairs With Target Sum Leetcode Link My Solution\nWeek3 557. Reverse Words in a String III Leetcode Link My Solution\n345. Reverse Vowels of a String Leetcode Link My Solution\n463. Island Perimeter Leetcode Link My Solution\n160. Intersection of Two Linked Lists Leetcode Link My Solution\n6. Zigzag Conversion Leetcode Link My Solution\n1366. Rank Teams by Votes Leetcode Link My Solution\n2769. Find the Maximum Achievable Number Leetcode Link My Solution\n6899. Maximum Number of Jumps to Reach the Last Index Leetcode Link My Solution\n6912. Longest Non-decreasing Subarray From Two Arrays Leetcode Link My Solution\nWeek4 2656. Maximum Sum With Exactly K Elements Leetcode Link My Solution\n2475. Number of Unequal Triplets in Array Leetcode Link My Solution\n2558. Take Gifts From the Richest Pile Leetcode Link My Solution\n2278. Percentage of Letter in String Leetcode Link My Solution\n275. H-Index II Leetcode Link My Solution\n227. Basic Calculator II Leetcode Link My Solution\n2778. Sum of Squares of Special Elements Leetcode Link My Solution\n2779. Maximum Beauty of an Array After Applying Operation Leetcode Link My Solution\n2780. Minimum Index of a Valid Split Leetcode Link My Solution\nWeek4 1394. Find Lucky Integer in an Array Leetcode Link My Solution\n1332. Remove Palindromic Subsequences Leetcode Link My Solution\n1281. Subtract the Product and Sum of Digits of an Integer Leetcode Link My Solution\n1013. Partition Array Into Three Parts With Equal Sum Leetcode Link My Solution\n2249. Count Lattice Points Inside a Circle Leetcode Link My Solution\n2256. Minimum Average Difference Leetcode Link My Solution\n2788. Split Strings by Separator Leetcode Link My Solution\n2789. Largest Element in an Array after Merge Operations Leetcode Link My Solution\n","permalink":"https://aura.codex.tw/posts/leetcode/leetcode-2023-07/","summary":"\u003ch1 id=\"week1\"\u003eWeek1\u003c/h1\u003e\n\u003ch5 id=\"1232-check-if-it-is-a-straight-line\"\u003e1232. Check If It Is a Straight Line\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/check-if-it-is-a-straight-line/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1232\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1071-greatest-common-divisor-of-strings\"\u003e1071. Greatest Common Divisor of Strings\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/greatest-common-divisor-of-strings/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1071\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1160-find-words-that-can-be-formed-by-characters\"\u003e1160. Find Words That Can Be Formed by Characters\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1160\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"1323-maximum-69-number\"\u003e1323. Maximum 69 Number\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/maximum-69-number/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/1323\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"858-mirror-reflection\"\u003e858. Mirror Reflection\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/mirror-reflection/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/858\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"946-validate-stack-sequences\"\u003e946. Validate Stack Sequences\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/validate-stack-sequences/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/946\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2748-number-of-beautiful-pairs\"\u003e2748. Number of Beautiful Pairs\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/number-of-beautiful-pairs/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2748\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e\n\u003ch5 id=\"2750-ways-to-split-array-into-good-subarrays\"\u003e2750. Ways to Split Array Into Good Subarrays\u003c/h5\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/description/\"\u003eLeetcode Link\u003c/a\u003e \u003ca href=\"https://aura.codex.tw/leetcode/code/2750\"\u003eMy Solution\u003c/a\u003e\u003c/p\u003e","title":"LeetCode 2023/07"},{"content":"連結 Docker Github\nDocker 執行 使用 Docker 時，可以使用以下指令：\n1 2 3 docker run -d -e psw=a_string -e domain=a_domain \\ -e port1=5001 -e port2=5002 \\ -p 5001:443 -p 5002:5002 au2a/hakka-website psw為密碼，需要密碼才能執行，如需要請向我詢問。 domain為網址，設定網頁使用的網址 port1為外部的網頁 port port2為外部的解碼用 port\n-p 443:443網頁使用的是https通道 -p 5002:5002網頁解碼使用的通道\n專案結構 files ┗┳━ decode ┃ ┗━ espnet解碼後的文本 ┣━ initFiles ┃ ┗━ 密碼的md5較驗檔、需要初始化的檔案 ┣━ keys ┃ ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案 ┣━ openai ┃ ┣━ decode ┃ ┃ ┗━openai whisper解碼後的文本 ┃ ┣━ model ┃ ┃ ┗━openai whisper使用的model ┃ ┣━ upload ┃ ┃ ┗━上傳openai whisper解碼的音檔存放區 ┃ ┣━ delete.py 定期刪除存放太久的音檔語文本 ┃ ┣━ download.py 下載youtube檔案轉wav檔 ┃ ┗━ openai_whisper.py Openai whisper解碼主程式 ┣━ upload ┃ ┗━ 上傳espnet解碼的音檔存放區 ┣━ views ┃ ┗━ 網頁 ┣━ website ┃ ┣━ demo ┃ ┃ ┗━範例音檔與文本 ┃ ┣━ files ┃ ┃ ┗━網頁主題、網頁JS程式碼 ┃ ┗━ server.js 伺服器主程式 ┣━ aidecodeList.txt 待whisper解碼清單 ┣━ decodeList.txt 待espnet解碼清單 ┣━ domainName 網址 ┣━ init.py 初始化 ┣━ run.sh docker用啟動執行檔 ┗━ test.sh 測試用啟動執行檔 執行 全部執行 如果要在本地端執行，請執行test.sh\n1 2 3 4 5 6 # 將hakka.corelab.dev文字放入domainName echo \u0026#34;hakka.corelab.dev\u0026#34; \u0026gt; domainName # 初始化所有檔案 python3 init.py # 啟動三個解碼執行緒、自動刪除舊檔案與網頁伺服器 python3 openai/openai_whisper.py \u0026amp; python3 openai/openai_whisper.py \u0026amp; python3 openai/openai_whisper.py \u0026amp; python3 openai/delete.py \u0026amp; node website/server.js 分開執行 請在專案目錄下執行檔案，不然部分指令相對路徑會錯誤\n網頁執行 執行網頁前，需先安裝網頁需要的套件 請先到website/底下安裝\n~/Hakka_Website/website$ npm install 在回到專案目錄執行網頁\n~/Hakka_Website$ node website/server.js whisper 解碼執行 ~/Hakka_Website$ python3 openai/openai_whisper.py 安全憑證 因為網頁有使用的錄音功能，所以網頁需要走https協定，因此需要申請安全憑證。 我是使用LetsEncrypt的安全憑證，每 90 天需要重新申請一次。 參考網站 請將申請後的安全憑證檔案放到keys/底下即可運作網頁。 檔案有三：cert.pem, chain.pem, privkey.pem\n","permalink":"https://aura.codex.tw/posts/hakkaasr-website/","summary":"\u003ch1 id=\"連結\"\u003e連結\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://hub.docker.com/r/au2a/hakka-website\"\u003eDocker\u003c/a\u003e\n\u003ca href=\"https://github.com/AU2A/Hakka_Website\"\u003eGithub\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"docker-執行\"\u003eDocker 執行\u003c/h1\u003e\n\u003cp\u003e使用 Docker 時，可以使用以下指令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run -d -e \u003cspan class=\"nv\"\u003epsw\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ea_string -e \u003cspan class=\"nv\"\u003edomain\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ea_domain \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        -e \u003cspan class=\"nv\"\u003eport1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e5001\u003c/span\u003e -e \u003cspan class=\"nv\"\u003eport2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e5002\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        -p 5001:443 -p 5002:5002 au2a/hakka-website\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003ccode\u003epsw\u003c/code\u003e為密碼，需要密碼才能執行，如需要請向我詢問。\n\u003ccode\u003edomain\u003c/code\u003e為網址，設定網頁使用的網址\n\u003ccode\u003eport1\u003c/code\u003e為外部的網頁 port\n\u003ccode\u003eport2\u003c/code\u003e為外部的解碼用 port\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-p 443:443\u003c/code\u003e網頁使用的是\u003ccode\u003ehttps\u003c/code\u003e通道\n\u003ccode\u003e-p 5002:5002\u003c/code\u003e網頁解碼使用的通道\u003c/p\u003e\n\u003ch1 id=\"專案結構\"\u003e專案結構\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003efiles\n ┗┳━ decode\n  ┃   ┗━ espnet解碼後的文本\n  ┣━ initFiles\n  ┃   ┗━ 密碼的md5較驗檔、需要初始化的檔案\n  ┣━ keys\n  ┃   ┗━ 安全憑證的密碼，和cert.pem, chain.pem, privkey.pem三個憑證檔案\n  ┣━ openai\n  ┃   ┣━ decode\n  ┃   ┃   ┗━openai whisper解碼後的文本\n  ┃   ┣━ model\n  ┃   ┃   ┗━openai whisper使用的model\n  ┃   ┣━ upload\n  ┃   ┃   ┗━上傳openai whisper解碼的音檔存放區\n  ┃   ┣━ delete.py 定期刪除存放太久的音檔語文本\n  ┃   ┣━ download.py 下載youtube檔案轉wav檔\n  ┃   ┗━ openai_whisper.py Openai whisper解碼主程式\n  ┣━ upload\n  ┃   ┗━ 上傳espnet解碼的音檔存放區\n  ┣━ views\n  ┃   ┗━ 網頁\n  ┣━ website\n  ┃   ┣━ demo\n  ┃   ┃   ┗━範例音檔與文本\n  ┃   ┣━ files\n  ┃   ┃   ┗━網頁主題、網頁JS程式碼\n  ┃   ┗━ server.js 伺服器主程式\n  ┣━ aidecodeList.txt 待whisper解碼清單\n  ┣━ decodeList.txt 待espnet解碼清單\n  ┣━ domainName 網址\n  ┣━ init.py 初始化\n  ┣━ run.sh docker用啟動執行檔\n  ┗━ test.sh 測試用啟動執行檔\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"執行\"\u003e執行\u003c/h1\u003e\n\u003ch2 id=\"全部執行\"\u003e全部執行\u003c/h2\u003e\n\u003cp\u003e如果要在本地端執行，請執行\u003ccode\u003etest.sh\u003c/code\u003e\u003c/p\u003e","title":"HakkaASR Website"}]